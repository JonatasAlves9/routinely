(self["webpackChunkroutinely"] = self["webpackChunkroutinely"] || []).push([["vendors-node_modules_react-table_index_js"],{

/***/ "./node_modules/react-table/dist/react-table.development.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-table/dist/react-table.development.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! react */ "./node_modules/react/index.js")) :
  0;
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];

    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }

    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");

    return typeof key === "symbol" ? key : String(key);
  }

  var renderErr = 'Renderer Error ‚òùÔ∏è';
  var actions = {
    init: 'init'
  };
  var defaultRenderer = function defaultRenderer(_ref) {
    var _ref$value = _ref.value,
        value = _ref$value === void 0 ? '' : _ref$value;
    return value;
  };
  var emptyRenderer = function emptyRenderer() {
    return React.createElement(React.Fragment, null, "\xA0");
  };
  var defaultColumn = {
    Cell: defaultRenderer,
    width: 150,
    minWidth: 0,
    maxWidth: Number.MAX_SAFE_INTEGER
  };

  function mergeProps() {
    for (var _len = arguments.length, propList = new Array(_len), _key = 0; _key < _len; _key++) {
      propList[_key] = arguments[_key];
    }

    return propList.reduce(function (props, next) {
      var style = next.style,
          className = next.className,
          rest = _objectWithoutPropertiesLoose(next, ["style", "className"]);

      props = _extends({}, props, {}, rest);

      if (style) {
        props.style = props.style ? _extends({}, props.style || {}, {}, style || {}) : style;
      }

      if (className) {
        props.className = props.className ? props.className + ' ' + className : className;
      }

      if (props.className === '') {
        delete props.className;
      }

      return props;
    }, {});
  }

  function handlePropGetter(prevProps, userProps, meta) {
    // Handle a lambda, pass it the previous props
    if (typeof userProps === 'function') {
      return handlePropGetter({}, userProps(prevProps, meta));
    } // Handle an array, merge each item as separate props


    if (Array.isArray(userProps)) {
      return mergeProps.apply(void 0, [prevProps].concat(userProps));
    } // Handle an object by default, merge the two objects


    return mergeProps(prevProps, userProps);
  }

  var makePropGetter = function makePropGetter(hooks, meta) {
    if (meta === void 0) {
      meta = {};
    }

    return function (userProps) {
      if (userProps === void 0) {
        userProps = {};
      }

      return [].concat(hooks, [userProps]).reduce(function (prev, next) {
        return handlePropGetter(prev, next, _extends({}, meta, {
          userProps: userProps
        }));
      }, {});
    };
  };
  var reduceHooks = function reduceHooks(hooks, initial, meta, allowUndefined) {
    if (meta === void 0) {
      meta = {};
    }

    return hooks.reduce(function (prev, next) {
      var nextValue = next(prev, meta);

      {
        if (!allowUndefined && typeof nextValue === 'undefined') {
          console.info(next);
          throw new Error('React Table: A reducer hook ‚òùÔ∏è just returned undefined! This is not allowed.');
        }
      }

      return nextValue;
    }, initial);
  };
  var loopHooks = function loopHooks(hooks, context, meta) {
    if (meta === void 0) {
      meta = {};
    }

    return hooks.forEach(function (hook) {
      var nextValue = hook(context, meta);

      {
        if (typeof nextValue !== 'undefined') {
          console.info(hook, nextValue);
          throw new Error('React Table: A loop-type hook ‚òùÔ∏è just returned a value! This is not allowed.');
        }
      }
    });
  };
  function ensurePluginOrder(plugins, befores, pluginName, afters) {
    if ( afters) {
      throw new Error("Defining plugins in the \"after\" section of ensurePluginOrder is no longer supported (see plugin " + pluginName + ")");
    }

    var pluginIndex = plugins.findIndex(function (plugin) {
      return plugin.pluginName === pluginName;
    });

    if (pluginIndex === -1) {
      {
        throw new Error("The plugin \"" + pluginName + "\" was not found in the plugin list!\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\n\n  " + pluginName + ".pluginName = '" + pluginName + "'\n");
      }
    }

    befores.forEach(function (before) {
      var beforeIndex = plugins.findIndex(function (plugin) {
        return plugin.pluginName === before;
      });

      if (beforeIndex > -1 && beforeIndex > pluginIndex) {
        {
          throw new Error("React Table: The " + pluginName + " plugin hook must be placed after the " + before + " plugin hook!");
        }
      }
    });
  }
  function functionalUpdate(updater, old) {
    return typeof updater === 'function' ? updater(old) : updater;
  }
  function useGetLatest(obj) {
    var ref = React.useRef();
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  } // SSR has issues with useLayoutEffect still, so use useEffect during SSR

  var safeUseLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;
  function useMountedLayoutEffect(fn, deps) {
    var mountedRef = React.useRef(false);
    safeUseLayoutEffect(function () {
      if (mountedRef.current) {
        fn();
      }

      mountedRef.current = true; // eslint-disable-next-line
    }, deps);
  }
  function useAsyncDebounce(defaultFn, defaultWait) {
    if (defaultWait === void 0) {
      defaultWait = 0;
    }

    var debounceRef = React.useRef({});
    var getDefaultFn = useGetLatest(defaultFn);
    var getDefaultWait = useGetLatest(defaultWait);
    return React.useCallback(
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _len2,
            args,
            _key2,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                for (_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = _args2[_key2];
                }

                if (!debounceRef.current.promise) {
                  debounceRef.current.promise = new Promise(function (resolve, reject) {
                    debounceRef.current.resolve = resolve;
                    debounceRef.current.reject = reject;
                  });
                }

                if (debounceRef.current.timeout) {
                  clearTimeout(debounceRef.current.timeout);
                }

                debounceRef.current.timeout = setTimeout(
                /*#__PURE__*/
                _asyncToGenerator(
                /*#__PURE__*/
                regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          delete debounceRef.current.timeout;
                          _context.prev = 1;
                          _context.t0 = debounceRef.current;
                          _context.next = 5;
                          return getDefaultFn().apply(void 0, args);

                        case 5:
                          _context.t1 = _context.sent;

                          _context.t0.resolve.call(_context.t0, _context.t1);

                          _context.next = 12;
                          break;

                        case 9:
                          _context.prev = 9;
                          _context.t2 = _context["catch"](1);
                          debounceRef.current.reject(_context.t2);

                        case 12:
                          _context.prev = 12;
                          delete debounceRef.current.promise;
                          return _context.finish(12);

                        case 15:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[1, 9, 12, 15]]);
                })), getDefaultWait());
                return _context2.abrupt("return", debounceRef.current.promise);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function () {
        return _ref2.apply(this, arguments);
      };
    }(), [getDefaultFn, getDefaultWait]);
  }
  function makeRenderer(instance, column, meta) {
    if (meta === void 0) {
      meta = {};
    }

    return function (type, userProps) {
      if (userProps === void 0) {
        userProps = {};
      }

      var Comp = typeof type === 'string' ? column[type] : type;

      if (typeof Comp === 'undefined') {
        console.info(column);
        throw new Error(renderErr);
      }

      return flexRender(Comp, _extends({}, instance, {
        column: column
      }, meta, {}, userProps));
    };
  }
  function flexRender(Comp, props) {
    return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;
  }

  function isReactComponent(component) {
    return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);
  }

  function isClassComponent(component) {
    return typeof component === 'function' && function () {
      var proto = Object.getPrototypeOf(component);
      return proto.prototype && proto.prototype.isReactComponent;
    }();
  }

  function isExoticComponent(component) {
    return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);
  }

  function linkColumnStructure(columns, parent, depth) {
    if (depth === void 0) {
      depth = 0;
    }

    return columns.map(function (column) {
      column = _extends({}, column, {
        parent: parent,
        depth: depth
      });
      assignColumnAccessor(column);

      if (column.columns) {
        column.columns = linkColumnStructure(column.columns, column, depth + 1);
      }

      return column;
    });
  }
  function flattenColumns(columns) {
    return flattenBy(columns, 'columns');
  }
  function assignColumnAccessor(column) {
    // First check for string accessor
    var id = column.id,
        accessor = column.accessor,
        Header = column.Header;

    if (typeof accessor === 'string') {
      id = id || accessor;
      var accessorPath = accessor.split('.');

      accessor = function accessor(row) {
        return getBy(row, accessorPath);
      };
    }

    if (!id && typeof Header === 'string' && Header) {
      id = Header;
    }

    if (!id && column.columns) {
      console.error(column);
      throw new Error('A column ID (or unique "Header" value) is required!');
    }

    if (!id) {
      console.error(column);
      throw new Error('A column ID (or string accessor) is required!');
    }

    Object.assign(column, {
      id: id,
      accessor: accessor
    });
    return column;
  }
  function decorateColumn(column, userDefaultColumn) {
    if (!userDefaultColumn) {
      throw new Error();
    }

    Object.assign(column, _extends({
      // Make sure there is a fallback header, just in case
      Header: emptyRenderer,
      Footer: emptyRenderer
    }, defaultColumn, {}, userDefaultColumn, {}, column));
    Object.assign(column, {
      originalWidth: column.width
    });
    return column;
  } // Build the header groups from the bottom up

  function makeHeaderGroups(allColumns, defaultColumn, additionalHeaderProperties) {
    if (additionalHeaderProperties === void 0) {
      additionalHeaderProperties = function additionalHeaderProperties() {
        return {};
      };
    }

    var headerGroups = [];
    var scanColumns = allColumns;
    var uid = 0;

    var getUID = function getUID() {
      return uid++;
    };

    var _loop = function _loop() {
      // The header group we are creating
      var headerGroup = {
        headers: []
      }; // The parent columns we're going to scan next

      var parentColumns = [];
      var hasParents = scanColumns.some(function (d) {
        return d.parent;
      }); // Scan each column for parents

      scanColumns.forEach(function (column) {
        // What is the latest (last) parent column?
        var latestParentColumn = [].concat(parentColumns).reverse()[0];
        var newParent;

        if (hasParents) {
          // If the column has a parent, add it if necessary
          if (column.parent) {
            newParent = _extends({}, column.parent, {
              originalId: column.parent.id,
              id: column.parent.id + "_" + getUID(),
              headers: [column]
            }, additionalHeaderProperties(column));
          } else {
            // If other columns have parents, we'll need to add a place holder if necessary
            var originalId = column.id + "_placeholder";
            newParent = decorateColumn(_extends({
              originalId: originalId,
              id: column.id + "_placeholder_" + getUID(),
              placeholderOf: column,
              headers: [column]
            }, additionalHeaderProperties(column)), defaultColumn);
          } // If the resulting parent columns are the same, just add
          // the column and increment the header span


          if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {
            latestParentColumn.headers.push(column);
          } else {
            parentColumns.push(newParent);
          }
        }

        headerGroup.headers.push(column);
      });
      headerGroups.push(headerGroup); // Start scanning the parent columns

      scanColumns = parentColumns;
    };

    while (scanColumns.length) {
      _loop();
    }

    return headerGroups.reverse();
  }
  var pathObjCache = new Map();
  function getBy(obj, path, def) {
    if (!path) {
      return obj;
    }

    var cacheKey = typeof path === 'function' ? path : JSON.stringify(path);

    var pathObj = pathObjCache.get(cacheKey) || function () {
      var pathObj = makePathArray(path);
      pathObjCache.set(cacheKey, pathObj);
      return pathObj;
    }();

    var val;

    try {
      val = pathObj.reduce(function (cursor, pathPart) {
        return cursor[pathPart];
      }, obj);
    } catch (e) {// continue regardless of error
    }

    return typeof val !== 'undefined' ? val : def;
  }
  function getFirstDefined() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    for (var i = 0; i < args.length; i += 1) {
      if (typeof args[i] !== 'undefined') {
        return args[i];
      }
    }
  }
  function isFunction(a) {
    if (typeof a === 'function') {
      return a;
    }
  }
  function flattenBy(arr, key) {
    var flat = [];

    var recurse = function recurse(arr) {
      arr.forEach(function (d) {
        if (!d[key]) {
          flat.push(d);
        } else {
          recurse(d[key]);
        }
      });
    };

    recurse(arr);
    return flat;
  }
  function expandRows(rows, _ref) {
    var manualExpandedKey = _ref.manualExpandedKey,
        expanded = _ref.expanded,
        _ref$expandSubRows = _ref.expandSubRows,
        expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;
    var expandedRows = [];

    var handleRow = function handleRow(row, addToExpandedRows) {
      if (addToExpandedRows === void 0) {
        addToExpandedRows = true;
      }

      row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];
      row.canExpand = row.subRows && !!row.subRows.length;

      if (addToExpandedRows) {
        expandedRows.push(row);
      }

      if (row.subRows && row.subRows.length && row.isExpanded) {
        row.subRows.forEach(function (row) {
          return handleRow(row, expandSubRows);
        });
      }
    };

    rows.forEach(function (row) {
      return handleRow(row);
    });
    return expandedRows;
  }
  function getFilterMethod(filter, userFilterTypes, filterTypes) {
    return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;
  }
  function shouldAutoRemoveFilter(autoRemove, value, column) {
    return autoRemove ? autoRemove(value, column) : typeof value === 'undefined';
  }
  function unpreparedAccessWarning() {
    throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');
  }
  var passiveSupported = null;
  function passiveEventSupported() {
    // memoize support to avoid adding multiple test events
    if (typeof passiveSupported === 'boolean') return passiveSupported;
    var supported = false;

    try {
      var options = {
        get passive() {
          supported = true;
          return false;
        }

      };
      window.addEventListener('test', null, options);
      window.removeEventListener('test', null, options);
    } catch (err) {
      supported = false;
    }

    passiveSupported = supported;
    return passiveSupported;
  } //

  var reOpenBracket = /\[/g;
  var reCloseBracket = /\]/g;

  function makePathArray(obj) {
    return flattenDeep(obj) // remove all periods in parts
    .map(function (d) {
      return String(d).replace('.', '_');
    }) // join parts using period
    .join('.') // replace brackets with periods
    .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods
    .split('.');
  }

  function flattenDeep(arr, newArr) {
    if (newArr === void 0) {
      newArr = [];
    }

    if (!Array.isArray(arr)) {
      newArr.push(arr);
    } else {
      for (var i = 0; i < arr.length; i += 1) {
        flattenDeep(arr[i], newArr);
      }
    }

    return newArr;
  }

  var defaultGetTableProps = function defaultGetTableProps(props) {
    return _extends({
      role: 'table'
    }, props);
  };

  var defaultGetTableBodyProps = function defaultGetTableBodyProps(props) {
    return _extends({
      role: 'rowgroup'
    }, props);
  };

  var defaultGetHeaderProps = function defaultGetHeaderProps(props, _ref) {
    var column = _ref.column;
    return _extends({
      key: "header_" + column.id,
      colSpan: column.totalVisibleHeaderCount,
      role: 'columnheader'
    }, props);
  };

  var defaultGetFooterProps = function defaultGetFooterProps(props, _ref2) {
    var column = _ref2.column;
    return _extends({
      key: "footer_" + column.id,
      colSpan: column.totalVisibleHeaderCount
    }, props);
  };

  var defaultGetHeaderGroupProps = function defaultGetHeaderGroupProps(props, _ref3) {
    var index = _ref3.index;
    return _extends({
      key: "headerGroup_" + index,
      role: 'row'
    }, props);
  };

  var defaultGetFooterGroupProps = function defaultGetFooterGroupProps(props, _ref4) {
    var index = _ref4.index;
    return _extends({
      key: "footerGroup_" + index
    }, props);
  };

  var defaultGetRowProps = function defaultGetRowProps(props, _ref5) {
    var row = _ref5.row;
    return _extends({
      key: "row_" + row.id,
      role: 'row'
    }, props);
  };

  var defaultGetCellProps = function defaultGetCellProps(props, _ref6) {
    var cell = _ref6.cell;
    return _extends({
      key: "cell_" + cell.row.id + "_" + cell.column.id,
      role: 'cell'
    }, props);
  };

  function makeDefaultPluginHooks() {
    return {
      useOptions: [],
      stateReducers: [],
      useControlledState: [],
      columns: [],
      columnsDeps: [],
      allColumns: [],
      allColumnsDeps: [],
      accessValue: [],
      materializedColumns: [],
      materializedColumnsDeps: [],
      useInstanceAfterData: [],
      visibleColumns: [],
      visibleColumnsDeps: [],
      headerGroups: [],
      headerGroupsDeps: [],
      useInstanceBeforeDimensions: [],
      useInstance: [],
      prepareRow: [],
      getTableProps: [defaultGetTableProps],
      getTableBodyProps: [defaultGetTableBodyProps],
      getHeaderGroupProps: [defaultGetHeaderGroupProps],
      getFooterGroupProps: [defaultGetFooterGroupProps],
      getHeaderProps: [defaultGetHeaderProps],
      getFooterProps: [defaultGetFooterProps],
      getRowProps: [defaultGetRowProps],
      getCellProps: [defaultGetCellProps],
      useFinalInstance: []
    };
  }

  actions.resetHiddenColumns = 'resetHiddenColumns';
  actions.toggleHideColumn = 'toggleHideColumn';
  actions.setHiddenColumns = 'setHiddenColumns';
  actions.toggleHideAllColumns = 'toggleHideAllColumns';
  var useColumnVisibility = function useColumnVisibility(hooks) {
    hooks.getToggleHiddenProps = [defaultGetToggleHiddenProps];
    hooks.getToggleHideAllColumnsProps = [defaultGetToggleHideAllColumnsProps];
    hooks.stateReducers.push(reducer);
    hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);
    hooks.headerGroupsDeps.push(function (deps, _ref) {
      var instance = _ref.instance;
      return [].concat(deps, [instance.state.hiddenColumns]);
    });
    hooks.useInstance.push(useInstance);
  };
  useColumnVisibility.pluginName = 'useColumnVisibility';

  var defaultGetToggleHiddenProps = function defaultGetToggleHiddenProps(props, _ref2) {
    var column = _ref2.column;
    return [props, {
      onChange: function onChange(e) {
        column.toggleHidden(!e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: column.isVisible,
      title: 'Toggle Column Visible'
    }];
  };

  var defaultGetToggleHideAllColumnsProps = function defaultGetToggleHideAllColumnsProps(props, _ref3) {
    var instance = _ref3.instance;
    return [props, {
      onChange: function onChange(e) {
        instance.toggleHideAllColumns(!e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: !instance.allColumnsHidden && !instance.state.hiddenColumns.length,
      title: 'Toggle All Columns Hidden',
      indeterminate: !instance.allColumnsHidden && instance.state.hiddenColumns.length
    }];
  };

  function reducer(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        hiddenColumns: []
      }, state);
    }

    if (action.type === actions.resetHiddenColumns) {
      return _extends({}, state, {
        hiddenColumns: instance.initialState.hiddenColumns || []
      });
    }

    if (action.type === actions.toggleHideColumn) {
      var should = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.includes(action.columnId);
      var hiddenColumns = should ? [].concat(state.hiddenColumns, [action.columnId]) : state.hiddenColumns.filter(function (d) {
        return d !== action.columnId;
      });
      return _extends({}, state, {
        hiddenColumns: hiddenColumns
      });
    }

    if (action.type === actions.setHiddenColumns) {
      return _extends({}, state, {
        hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)
      });
    }

    if (action.type === actions.toggleHideAllColumns) {
      var shouldAll = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.length;
      return _extends({}, state, {
        hiddenColumns: shouldAll ? instance.allColumns.map(function (d) {
          return d.id;
        }) : []
      });
    }
  }

  function useInstanceBeforeDimensions(instance) {
    var headers = instance.headers,
        hiddenColumns = instance.state.hiddenColumns;
    var isMountedRef = React.useRef(false);

    if (!isMountedRef.current) ;

    var handleColumn = function handleColumn(column, parentVisible) {
      column.isVisible = parentVisible && !hiddenColumns.includes(column.id);
      var totalVisibleHeaderCount = 0;

      if (column.headers && column.headers.length) {
        column.headers.forEach(function (subColumn) {
          return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);
        });
      } else {
        totalVisibleHeaderCount = column.isVisible ? 1 : 0;
      }

      column.totalVisibleHeaderCount = totalVisibleHeaderCount;
      return totalVisibleHeaderCount;
    };

    var totalVisibleHeaderCount = 0;
    headers.forEach(function (subHeader) {
      return totalVisibleHeaderCount += handleColumn(subHeader, true);
    });
  }

  function useInstance(instance) {
    var columns = instance.columns,
        flatHeaders = instance.flatHeaders,
        dispatch = instance.dispatch,
        allColumns = instance.allColumns,
        getHooks = instance.getHooks,
        hiddenColumns = instance.state.hiddenColumns,
        _instance$autoResetHi = instance.autoResetHiddenColumns,
        autoResetHiddenColumns = _instance$autoResetHi === void 0 ? true : _instance$autoResetHi;
    var getInstance = useGetLatest(instance);
    var allColumnsHidden = allColumns.length === hiddenColumns.length;
    var toggleHideColumn = React.useCallback(function (columnId, value) {
      return dispatch({
        type: actions.toggleHideColumn,
        columnId: columnId,
        value: value
      });
    }, [dispatch]);
    var setHiddenColumns = React.useCallback(function (value) {
      return dispatch({
        type: actions.setHiddenColumns,
        value: value
      });
    }, [dispatch]);
    var toggleHideAllColumns = React.useCallback(function (value) {
      return dispatch({
        type: actions.toggleHideAllColumns,
        value: value
      });
    }, [dispatch]);
    var getToggleHideAllColumnsProps = makePropGetter(getHooks().getToggleHideAllColumnsProps, {
      instance: getInstance()
    });
    flatHeaders.forEach(function (column) {
      column.toggleHidden = function (value) {
        dispatch({
          type: actions.toggleHideColumn,
          columnId: column.id,
          value: value
        });
      };

      column.getToggleHiddenProps = makePropGetter(getHooks().getToggleHiddenProps, {
        instance: getInstance(),
        column: column
      });
    });
    var getAutoResetHiddenColumns = useGetLatest(autoResetHiddenColumns);
    useMountedLayoutEffect(function () {
      if (getAutoResetHiddenColumns()) {
        dispatch({
          type: actions.resetHiddenColumns
        });
      }
    }, [dispatch, columns]);
    Object.assign(instance, {
      allColumnsHidden: allColumnsHidden,
      toggleHideColumn: toggleHideColumn,
      setHiddenColumns: setHiddenColumns,
      toggleHideAllColumns: toggleHideAllColumns,
      getToggleHideAllColumnsProps: getToggleHideAllColumnsProps
    });
  }

  var defaultInitialState = {};
  var defaultColumnInstance = {};

  var defaultReducer = function defaultReducer(state, action, prevState) {
    return state;
  };

  var defaultGetSubRows = function defaultGetSubRows(row, index) {
    return row.subRows || [];
  };

  var defaultGetRowId = function defaultGetRowId(row, index, parent) {
    return "" + (parent ? [parent.id, index].join('.') : index);
  };

  var defaultUseControlledState = function defaultUseControlledState(d) {
    return d;
  };

  function applyDefaults(props) {
    var _props$initialState = props.initialState,
        initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,
        _props$defaultColumn = props.defaultColumn,
        defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,
        _props$getSubRows = props.getSubRows,
        getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,
        _props$getRowId = props.getRowId,
        getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId,
        _props$stateReducer = props.stateReducer,
        stateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer,
        _props$useControlledS = props.useControlledState,
        useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS,
        rest = _objectWithoutPropertiesLoose(props, ["initialState", "defaultColumn", "getSubRows", "getRowId", "stateReducer", "useControlledState"]);

    return _extends({}, rest, {
      initialState: initialState,
      defaultColumn: defaultColumn,
      getSubRows: getSubRows,
      getRowId: getRowId,
      stateReducer: stateReducer,
      useControlledState: useControlledState
    });
  }

  var useTable = function useTable(props) {
    for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      plugins[_key - 1] = arguments[_key];
    }

    // Apply default props
    props = applyDefaults(props); // Add core plugins

    plugins = [useColumnVisibility].concat(plugins); // Create the table instance

    var instanceRef = React.useRef({}); // Create a getter for the instance (helps avoid a lot of potential memory leaks)

    var getInstance = useGetLatest(instanceRef.current); // Assign the props, plugins and hooks to the instance

    Object.assign(getInstance(), _extends({}, props, {
      plugins: plugins,
      hooks: makeDefaultPluginHooks()
    })); // Allow plugins to register hooks as early as possible

    plugins.filter(Boolean).forEach(function (plugin) {
      plugin(getInstance().hooks);
    }); // Consume all hooks and make a getter for them

    var getHooks = useGetLatest(getInstance().hooks);
    getInstance().getHooks = getHooks;
    delete getInstance().hooks; // Allow useOptions hooks to modify the options coming into the table

    Object.assign(getInstance(), reduceHooks(getHooks().useOptions, applyDefaults(props)));

    var _getInstance = getInstance(),
        data = _getInstance.data,
        userColumns = _getInstance.columns,
        initialState = _getInstance.initialState,
        defaultColumn = _getInstance.defaultColumn,
        getSubRows = _getInstance.getSubRows,
        getRowId = _getInstance.getRowId,
        stateReducer = _getInstance.stateReducer,
        useControlledState = _getInstance.useControlledState; // Setup user reducer ref


    var getStateReducer = useGetLatest(stateReducer); // Build the reducer

    var reducer = React.useCallback(function (state, action) {
      // Detect invalid actions
      if (!action.type) {
        console.info({
          action: action
        });
        throw new Error('Unknown Action üëÜ');
      } // Reduce the state from all plugin reducers


      return [].concat(getHooks().stateReducers, Array.isArray(getStateReducer()) ? getStateReducer() : [getStateReducer()]).reduce(function (s, handler) {
        return handler(s, action, state, getInstance()) || s;
      }, state);
    }, [getHooks, getStateReducer, getInstance]); // Start the reducer

    var _React$useReducer = React.useReducer(reducer, undefined, function () {
      return reducer(initialState, {
        type: actions.init
      });
    }),
        reducerState = _React$useReducer[0],
        dispatch = _React$useReducer[1]; // Allow the user to control the final state with hooks


    var state = reduceHooks([].concat(getHooks().useControlledState, [useControlledState]), reducerState, {
      instance: getInstance()
    });
    Object.assign(getInstance(), {
      state: state,
      dispatch: dispatch
    }); // Decorate All the columns

    var columns = React.useMemo(function () {
      return linkColumnStructure(reduceHooks(getHooks().columns, userColumns, {
        instance: getInstance()
      }));
    }, [getHooks, getInstance, userColumns].concat(reduceHooks(getHooks().columnsDeps, [], {
      instance: getInstance()
    })));
    getInstance().columns = columns; // Get the flat list of all columns and allow hooks to decorate
    // those columns (and trigger this memoization via deps)

    var allColumns = React.useMemo(function () {
      return reduceHooks(getHooks().allColumns, flattenColumns(columns), {
        instance: getInstance()
      }).map(assignColumnAccessor);
    }, [columns, getHooks, getInstance].concat(reduceHooks(getHooks().allColumnsDeps, [], {
      instance: getInstance()
    })));
    getInstance().allColumns = allColumns; // Access the row model using initial columns

    var _React$useMemo = React.useMemo(function () {
      var rows = [];
      var flatRows = [];
      var rowsById = {};
      var allColumnsQueue = [].concat(allColumns);

      while (allColumnsQueue.length) {
        var column = allColumnsQueue.shift();
        accessRowsForColumn({
          data: data,
          rows: rows,
          flatRows: flatRows,
          rowsById: rowsById,
          column: column,
          getRowId: getRowId,
          getSubRows: getSubRows,
          accessValueHooks: getHooks().accessValue,
          getInstance: getInstance
        });
      }

      return [rows, flatRows, rowsById];
    }, [allColumns, data, getRowId, getSubRows, getHooks, getInstance]),
        rows = _React$useMemo[0],
        flatRows = _React$useMemo[1],
        rowsById = _React$useMemo[2];

    Object.assign(getInstance(), {
      rows: rows,
      initialRows: [].concat(rows),
      flatRows: flatRows,
      rowsById: rowsById // materializedColumns,

    });
    loopHooks(getHooks().useInstanceAfterData, getInstance()); // Get the flat list of all columns AFTER the rows
    // have been access, and allow hooks to decorate
    // those columns (and trigger this memoization via deps)

    var visibleColumns = React.useMemo(function () {
      return reduceHooks(getHooks().visibleColumns, allColumns, {
        instance: getInstance()
      }).map(function (d) {
        return decorateColumn(d, defaultColumn);
      });
    }, [getHooks, allColumns, getInstance, defaultColumn].concat(reduceHooks(getHooks().visibleColumnsDeps, [], {
      instance: getInstance()
    }))); // Combine new visible columns with all columns

    allColumns = React.useMemo(function () {
      var columns = [].concat(visibleColumns);
      allColumns.forEach(function (column) {
        if (!columns.find(function (d) {
          return d.id === column.id;
        })) {
          columns.push(column);
        }
      });
      return columns;
    }, [allColumns, visibleColumns]);
    getInstance().allColumns = allColumns;

    {
      var duplicateColumns = allColumns.filter(function (column, i) {
        return allColumns.findIndex(function (d) {
          return d.id === column.id;
        }) !== i;
      });

      if (duplicateColumns.length) {
        console.info(allColumns);
        throw new Error("Duplicate columns were found with ids: \"" + duplicateColumns.map(function (d) {
          return d.id;
        }).join(', ') + "\" in the columns array above");
      }
    } // Make the headerGroups


    var headerGroups = React.useMemo(function () {
      return reduceHooks(getHooks().headerGroups, makeHeaderGroups(visibleColumns, defaultColumn), getInstance());
    }, [getHooks, visibleColumns, defaultColumn, getInstance].concat(reduceHooks(getHooks().headerGroupsDeps, [], {
      instance: getInstance()
    })));
    getInstance().headerGroups = headerGroups; // Get the first level of headers

    var headers = React.useMemo(function () {
      return headerGroups.length ? headerGroups[0].headers : [];
    }, [headerGroups]);
    getInstance().headers = headers; // Provide a flat header list for utilities

    getInstance().flatHeaders = headerGroups.reduce(function (all, headerGroup) {
      return [].concat(all, headerGroup.headers);
    }, []);
    loopHooks(getHooks().useInstanceBeforeDimensions, getInstance()); // Filter columns down to visible ones

    var visibleColumnsDep = visibleColumns.filter(function (d) {
      return d.isVisible;
    }).map(function (d) {
      return d.id;
    }).sort().join('_');
    visibleColumns = React.useMemo(function () {
      return visibleColumns.filter(function (d) {
        return d.isVisible;
      });
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [visibleColumns, visibleColumnsDep]);
    getInstance().visibleColumns = visibleColumns; // Header Visibility is needed by this point

    var _calculateHeaderWidth = calculateHeaderWidths(headers),
        totalColumnsMinWidth = _calculateHeaderWidth[0],
        totalColumnsWidth = _calculateHeaderWidth[1],
        totalColumnsMaxWidth = _calculateHeaderWidth[2];

    getInstance().totalColumnsMinWidth = totalColumnsMinWidth;
    getInstance().totalColumnsWidth = totalColumnsWidth;
    getInstance().totalColumnsMaxWidth = totalColumnsMaxWidth;
    loopHooks(getHooks().useInstance, getInstance()) // Each materialized header needs to be assigned a render function and other
    // prop getter properties here.
    ;
    [].concat(getInstance().flatHeaders, getInstance().allColumns).forEach(function (column) {
      // Give columns/headers rendering power
      column.render = makeRenderer(getInstance(), column); // Give columns/headers a default getHeaderProps

      column.getHeaderProps = makePropGetter(getHooks().getHeaderProps, {
        instance: getInstance(),
        column: column
      }); // Give columns/headers a default getFooterProps

      column.getFooterProps = makePropGetter(getHooks().getFooterProps, {
        instance: getInstance(),
        column: column
      });
    });
    getInstance().headerGroups = React.useMemo(function () {
      return headerGroups.filter(function (headerGroup, i) {
        // Filter out any headers and headerGroups that don't have visible columns
        headerGroup.headers = headerGroup.headers.filter(function (column) {
          var recurse = function recurse(headers) {
            return headers.filter(function (column) {
              if (column.headers) {
                return recurse(column.headers);
              }

              return column.isVisible;
            }).length;
          };

          if (column.headers) {
            return recurse(column.headers);
          }

          return column.isVisible;
        }); // Give headerGroups getRowProps

        if (headerGroup.headers.length) {
          headerGroup.getHeaderGroupProps = makePropGetter(getHooks().getHeaderGroupProps, {
            instance: getInstance(),
            headerGroup: headerGroup,
            index: i
          });
          headerGroup.getFooterGroupProps = makePropGetter(getHooks().getFooterGroupProps, {
            instance: getInstance(),
            headerGroup: headerGroup,
            index: i
          });
          return true;
        }

        return false;
      });
    }, [headerGroups, getInstance, getHooks]);
    getInstance().footerGroups = [].concat(getInstance().headerGroups).reverse(); // The prepareRow function is absolutely necessary and MUST be called on
    // any rows the user wishes to be displayed.

    getInstance().prepareRow = React.useCallback(function (row) {
      row.getRowProps = makePropGetter(getHooks().getRowProps, {
        instance: getInstance(),
        row: row
      }); // Build the visible cells for each row

      row.allCells = allColumns.map(function (column) {
        var value = row.values[column.id];
        var cell = {
          column: column,
          row: row,
          value: value
        }; // Give each cell a getCellProps base

        cell.getCellProps = makePropGetter(getHooks().getCellProps, {
          instance: getInstance(),
          cell: cell
        }); // Give each cell a renderer function (supports multiple renderers)

        cell.render = makeRenderer(getInstance(), column, {
          row: row,
          cell: cell,
          value: value
        });
        return cell;
      });
      row.cells = visibleColumns.map(function (column) {
        return row.allCells.find(function (cell) {
          return cell.column.id === column.id;
        });
      }); // need to apply any row specific hooks (useExpanded requires this)

      loopHooks(getHooks().prepareRow, row, {
        instance: getInstance()
      });
    }, [getHooks, getInstance, allColumns, visibleColumns]);
    getInstance().getTableProps = makePropGetter(getHooks().getTableProps, {
      instance: getInstance()
    });
    getInstance().getTableBodyProps = makePropGetter(getHooks().getTableBodyProps, {
      instance: getInstance()
    });
    loopHooks(getHooks().useFinalInstance, getInstance());
    return getInstance();
  };

  function calculateHeaderWidths(headers, left) {
    if (left === void 0) {
      left = 0;
    }

    var sumTotalMinWidth = 0;
    var sumTotalWidth = 0;
    var sumTotalMaxWidth = 0;
    var sumTotalFlexWidth = 0;
    headers.forEach(function (header) {
      var subHeaders = header.headers;
      header.totalLeft = left;

      if (subHeaders && subHeaders.length) {
        var _calculateHeaderWidth2 = calculateHeaderWidths(subHeaders, left),
            totalMinWidth = _calculateHeaderWidth2[0],
            totalWidth = _calculateHeaderWidth2[1],
            totalMaxWidth = _calculateHeaderWidth2[2],
            totalFlexWidth = _calculateHeaderWidth2[3];

        header.totalMinWidth = totalMinWidth;
        header.totalWidth = totalWidth;
        header.totalMaxWidth = totalMaxWidth;
        header.totalFlexWidth = totalFlexWidth;
      } else {
        header.totalMinWidth = header.minWidth;
        header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);
        header.totalMaxWidth = header.maxWidth;
        header.totalFlexWidth = header.canResize ? header.totalWidth : 0;
      }

      if (header.isVisible) {
        left += header.totalWidth;
        sumTotalMinWidth += header.totalMinWidth;
        sumTotalWidth += header.totalWidth;
        sumTotalMaxWidth += header.totalMaxWidth;
        sumTotalFlexWidth += header.totalFlexWidth;
      }
    });
    return [sumTotalMinWidth, sumTotalWidth, sumTotalMaxWidth, sumTotalFlexWidth];
  }

  function accessRowsForColumn(_ref) {
    var data = _ref.data,
        rows = _ref.rows,
        flatRows = _ref.flatRows,
        rowsById = _ref.rowsById,
        column = _ref.column,
        getRowId = _ref.getRowId,
        getSubRows = _ref.getSubRows,
        accessValueHooks = _ref.accessValueHooks,
        getInstance = _ref.getInstance;

    // Access the row's data column-by-column
    // We do it this way so we can incrementally add materialized
    // columns after the first pass and avoid excessive looping
    var accessRow = function accessRow(originalRow, rowIndex, depth, parent, parentRows) {
      if (depth === void 0) {
        depth = 0;
      }

      // Keep the original reference around
      var original = originalRow;
      var id = getRowId(originalRow, rowIndex, parent);
      var row = rowsById[id]; // If the row hasn't been created, let's make it

      if (!row) {
        row = {
          id: id,
          original: original,
          index: rowIndex,
          depth: depth,
          cells: [{}] // This is a dummy cell

        }; // Override common array functions (and the dummy cell's getCellProps function)
        // to show an error if it is accessed without calling prepareRow

        row.cells.map = unpreparedAccessWarning;
        row.cells.filter = unpreparedAccessWarning;
        row.cells.forEach = unpreparedAccessWarning;
        row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values

        row.values = {}; // Push this row into the parentRows array

        parentRows.push(row); // Keep track of every row in a flat array

        flatRows.push(row); // Also keep track of every row by its ID

        rowsById[id] = row; // Get the original subrows

        row.originalSubRows = getSubRows(originalRow, rowIndex); // Then recursively access them

        if (row.originalSubRows) {
          var subRows = [];
          row.originalSubRows.forEach(function (d, i) {
            return accessRow(d, i, depth + 1, row, subRows);
          }); // Keep the new subRows array on the row

          row.subRows = subRows;
        }
      } else if (row.subRows) {
        // If the row exists, then it's already been accessed
        // Keep recursing, but don't worry about passing the
        // accumlator array (those rows already exist)
        row.originalSubRows.forEach(function (d, i) {
          return accessRow(d, i, depth + 1, row);
        });
      } // If the column has an accessor, use it to get a value


      if (column.accessor) {
        row.values[column.id] = column.accessor(originalRow, rowIndex, row, parentRows, data);
      } // Allow plugins to manipulate the column value


      row.values[column.id] = reduceHooks(accessValueHooks, row.values[column.id], {
        row: row,
        column: column,
        instance: getInstance()
      }, true);
    };

    data.forEach(function (originalRow, rowIndex) {
      return accessRow(originalRow, rowIndex, 0, undefined, rows);
    });
  }

  actions.resetExpanded = 'resetExpanded';
  actions.toggleRowExpanded = 'toggleRowExpanded';
  actions.toggleAllRowsExpanded = 'toggleAllRowsExpanded';
  var useExpanded = function useExpanded(hooks) {
    hooks.getToggleAllRowsExpandedProps = [defaultGetToggleAllRowsExpandedProps];
    hooks.getToggleRowExpandedProps = [defaultGetToggleRowExpandedProps];
    hooks.stateReducers.push(reducer$1);
    hooks.useInstance.push(useInstance$1);
    hooks.prepareRow.push(prepareRow);
  };
  useExpanded.pluginName = 'useExpanded';

  var defaultGetToggleAllRowsExpandedProps = function defaultGetToggleAllRowsExpandedProps(props, _ref) {
    var instance = _ref.instance;
    return [props, {
      onClick: function onClick(e) {
        instance.toggleAllRowsExpanded();
      },
      style: {
        cursor: 'pointer'
      },
      title: 'Toggle All Rows Expanded'
    }];
  };

  var defaultGetToggleRowExpandedProps = function defaultGetToggleRowExpandedProps(props, _ref2) {
    var row = _ref2.row;
    return [props, {
      onClick: function onClick() {
        row.toggleRowExpanded();
      },
      style: {
        cursor: 'pointer'
      },
      title: 'Toggle Row Expanded'
    }];
  }; // Reducer


  function reducer$1(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        expanded: {}
      }, state);
    }

    if (action.type === actions.resetExpanded) {
      return _extends({}, state, {
        expanded: instance.initialState.expanded || {}
      });
    }

    if (action.type === actions.toggleAllRowsExpanded) {
      var value = action.value;
      var rowsById = instance.rowsById;
      var isAllRowsExpanded = Object.keys(rowsById).length === Object.keys(state.expanded).length;
      var expandAll = typeof value !== 'undefined' ? value : !isAllRowsExpanded;

      if (expandAll) {
        var expanded = {};
        Object.keys(rowsById).forEach(function (rowId) {
          expanded[rowId] = true;
        });
        return _extends({}, state, {
          expanded: expanded
        });
      }

      return _extends({}, state, {
        expanded: {}
      });
    }

    if (action.type === actions.toggleRowExpanded) {
      var id = action.id,
          setExpanded = action.value;
      var exists = state.expanded[id];
      var shouldExist = typeof setExpanded !== 'undefined' ? setExpanded : !exists;

      if (!exists && shouldExist) {
        var _extends2;

        return _extends({}, state, {
          expanded: _extends({}, state.expanded, (_extends2 = {}, _extends2[id] = true, _extends2))
        });
      } else if (exists && !shouldExist) {
        var _state$expanded = state.expanded,
            _ = _state$expanded[id],
            rest = _objectWithoutPropertiesLoose(_state$expanded, [id].map(_toPropertyKey));

        return _extends({}, state, {
          expanded: rest
        });
      } else {
        return state;
      }
    }
  }

  function useInstance$1(instance) {
    var data = instance.data,
        rows = instance.rows,
        rowsById = instance.rowsById,
        _instance$manualExpan = instance.manualExpandedKey,
        manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
        _instance$paginateExp = instance.paginateExpandedRows,
        paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
        _instance$expandSubRo = instance.expandSubRows,
        expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
        _instance$autoResetEx = instance.autoResetExpanded,
        autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx,
        getHooks = instance.getHooks,
        plugins = instance.plugins,
        expanded = instance.state.expanded,
        dispatch = instance.dispatch;
    ensurePluginOrder(plugins, ['useSortBy', 'useGroupBy', 'usePivotColumns', 'useGlobalFilter'], 'useExpanded');
    var getAutoResetExpanded = useGetLatest(autoResetExpanded);
    var isAllRowsExpanded = Boolean(Object.keys(rowsById).length && Object.keys(expanded).length);

    if (isAllRowsExpanded) {
      if (Object.keys(rowsById).some(function (id) {
        return !expanded[id];
      })) {
        isAllRowsExpanded = false;
      }
    } // Bypass any effects from firing when this changes


    useMountedLayoutEffect(function () {
      if (getAutoResetExpanded()) {
        dispatch({
          type: actions.resetExpanded
        });
      }
    }, [dispatch, data]);
    var toggleRowExpanded = React.useCallback(function (id, value) {
      dispatch({
        type: actions.toggleRowExpanded,
        id: id,
        value: value
      });
    }, [dispatch]);
    var toggleAllRowsExpanded = React.useCallback(function (value) {
      return dispatch({
        type: actions.toggleAllRowsExpanded,
        value: value
      });
    }, [dispatch]);
    var expandedRows = React.useMemo(function () {
      if (paginateExpandedRows) {
        return expandRows(rows, {
          manualExpandedKey: manualExpandedKey,
          expanded: expanded,
          expandSubRows: expandSubRows
        });
      }

      return rows;
    }, [paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);
    var expandedDepth = React.useMemo(function () {
      return findExpandedDepth(expanded);
    }, [expanded]);
    var getInstance = useGetLatest(instance);
    var getToggleAllRowsExpandedProps = makePropGetter(getHooks().getToggleAllRowsExpandedProps, {
      instance: getInstance()
    });
    Object.assign(instance, {
      preExpandedRows: rows,
      expandedRows: expandedRows,
      rows: expandedRows,
      expandedDepth: expandedDepth,
      isAllRowsExpanded: isAllRowsExpanded,
      toggleRowExpanded: toggleRowExpanded,
      toggleAllRowsExpanded: toggleAllRowsExpanded,
      getToggleAllRowsExpandedProps: getToggleAllRowsExpandedProps
    });
  }

  function prepareRow(row, _ref3) {
    var getHooks = _ref3.instance.getHooks,
        instance = _ref3.instance;

    row.toggleRowExpanded = function (set) {
      return instance.toggleRowExpanded(row.id, set);
    };

    row.getToggleRowExpandedProps = makePropGetter(getHooks().getToggleRowExpandedProps, {
      instance: instance,
      row: row
    });
  }

  function findExpandedDepth(expanded) {
    var maxDepth = 0;
    Object.keys(expanded).forEach(function (id) {
      var splitId = id.split('.');
      maxDepth = Math.max(maxDepth, splitId.length);
    });
    return maxDepth;
  }

  var text = function text(rows, ids, filterValue) {
    rows = rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());
      });
    });
    return rows;
  };

  text.autoRemove = function (val) {
    return !val;
  };

  var exactText = function exactText(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;
      });
    });
  };

  exactText.autoRemove = function (val) {
    return !val;
  };

  var exactTextCase = function exactTextCase(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;
      });
    });
  };

  exactTextCase.autoRemove = function (val) {
    return !val;
  };

  var includes = function includes(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue.includes(filterValue);
      });
    });
  };

  includes.autoRemove = function (val) {
    return !val || !val.length;
  };

  var includesAll = function includesAll(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue && rowValue.length && filterValue.every(function (val) {
          return rowValue.includes(val);
        });
      });
    });
  };

  includesAll.autoRemove = function (val) {
    return !val || !val.length;
  };

  var includesSome = function includesSome(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue && rowValue.length && filterValue.some(function (val) {
          return rowValue.includes(val);
        });
      });
    });
  };

  includesSome.autoRemove = function (val) {
    return !val || !val.length;
  };

  var includesValue = function includesValue(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return filterValue.includes(rowValue);
      });
    });
  };

  includesValue.autoRemove = function (val) {
    return !val || !val.length;
  };

  var exact = function exact(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue === filterValue;
      });
    });
  };

  exact.autoRemove = function (val) {
    return typeof val === 'undefined';
  };

  var equals = function equals(rows, ids, filterValue) {
    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq

        return rowValue == filterValue;
      });
    });
  };

  equals.autoRemove = function (val) {
    return val == null;
  };

  var between = function between(rows, ids, filterValue) {
    var _ref = filterValue || [],
        min = _ref[0],
        max = _ref[1];

    min = typeof min === 'number' ? min : -Infinity;
    max = typeof max === 'number' ? max : Infinity;

    if (min > max) {
      var temp = min;
      min = max;
      max = temp;
    }

    return rows.filter(function (row) {
      return ids.some(function (id) {
        var rowValue = row.values[id];
        return rowValue >= min && rowValue <= max;
      });
    });
  };

  between.autoRemove = function (val) {
    return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';
  };

  var filterTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    text: text,
    exactText: exactText,
    exactTextCase: exactTextCase,
    includes: includes,
    includesAll: includesAll,
    includesSome: includesSome,
    includesValue: includesValue,
    exact: exact,
    equals: equals,
    between: between
  });

  actions.resetFilters = 'resetFilters';
  actions.setFilter = 'setFilter';
  actions.setAllFilters = 'setAllFilters';
  var useFilters = function useFilters(hooks) {
    hooks.stateReducers.push(reducer$2);
    hooks.useInstance.push(useInstance$2);
  };
  useFilters.pluginName = 'useFilters';

  function reducer$2(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        filters: []
      }, state);
    }

    if (action.type === actions.resetFilters) {
      return _extends({}, state, {
        filters: instance.initialState.filters || []
      });
    }

    if (action.type === actions.setFilter) {
      var columnId = action.columnId,
          filterValue = action.filterValue;
      var allColumns = instance.allColumns,
          userFilterTypes = instance.filterTypes;
      var column = allColumns.find(function (d) {
        return d.id === columnId;
      });

      if (!column) {
        throw new Error("React-Table: Could not find a column with id: " + columnId);
      }

      var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);
      var previousfilter = state.filters.find(function (d) {
        return d.id === columnId;
      });
      var newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //

      if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {
        return _extends({}, state, {
          filters: state.filters.filter(function (d) {
            return d.id !== columnId;
          })
        });
      }

      if (previousfilter) {
        return _extends({}, state, {
          filters: state.filters.map(function (d) {
            if (d.id === columnId) {
              return {
                id: columnId,
                value: newFilter
              };
            }

            return d;
          })
        });
      }

      return _extends({}, state, {
        filters: [].concat(state.filters, [{
          id: columnId,
          value: newFilter
        }])
      });
    }

    if (action.type === actions.setAllFilters) {
      var filters = action.filters;
      var _allColumns = instance.allColumns,
          _userFilterTypes = instance.filterTypes;
      return _extends({}, state, {
        // Filter out undefined values
        filters: functionalUpdate(filters, state.filters).filter(function (filter) {
          var column = _allColumns.find(function (d) {
            return d.id === filter.id;
          });

          var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);

          if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {
            return false;
          }

          return true;
        })
      });
    }
  }

  function useInstance$2(instance) {
    var data = instance.data,
        rows = instance.rows,
        flatRows = instance.flatRows,
        rowsById = instance.rowsById,
        allColumns = instance.allColumns,
        userFilterTypes = instance.filterTypes,
        manualFilters = instance.manualFilters,
        _instance$defaultCanF = instance.defaultCanFilter,
        defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,
        disableFilters = instance.disableFilters,
        filters = instance.state.filters,
        dispatch = instance.dispatch,
        _instance$autoResetFi = instance.autoResetFilters,
        autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;
    var setFilter = React.useCallback(function (columnId, filterValue) {
      dispatch({
        type: actions.setFilter,
        columnId: columnId,
        filterValue: filterValue
      });
    }, [dispatch]);
    var setAllFilters = React.useCallback(function (filters) {
      dispatch({
        type: actions.setAllFilters,
        filters: filters
      });
    }, [dispatch]);
    allColumns.forEach(function (column) {
      var id = column.id,
          accessor = column.accessor,
          columnDefaultCanFilter = column.defaultCanFilter,
          columnDisableFilters = column.disableFilters; // Determine if a column is filterable

      column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value

      column.setFilter = function (val) {
        return setFilter(column.id, val);
      }; // Provide the current filter value to the column for
      // convenience


      var found = filters.find(function (d) {
        return d.id === id;
      });
      column.filterValue = found && found.value;
    });

    var _React$useMemo = React.useMemo(function () {
      if (manualFilters || !filters.length) {
        return [rows, flatRows, rowsById];
      }

      var filteredFlatRows = [];
      var filteredRowsById = {}; // Filters top level and nested rows

      var filterRows = function filterRows(rows, depth) {
        if (depth === void 0) {
          depth = 0;
        }

        var filteredRows = rows;
        filteredRows = filters.reduce(function (filteredSoFar, _ref) {
          var columnId = _ref.id,
              filterValue = _ref.value;
          // Find the filters column
          var column = allColumns.find(function (d) {
            return d.id === columnId;
          });

          if (!column) {
            return filteredSoFar;
          }

          if (depth === 0) {
            column.preFilteredRows = filteredSoFar;
          }

          var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);

          if (!filterMethod) {
            console.warn("Could not find a valid 'column.filter' for column with the ID: " + column.id + ".");
            return filteredSoFar;
          } // Pass the rows, id, filterValue and column to the filterMethod
          // to get the filtered rows back


          column.filteredRows = filterMethod(filteredSoFar, [columnId], filterValue);
          return column.filteredRows;
        }, rows); // Apply the filter to any subRows
        // We technically could do this recursively in the above loop,
        // but that would severely hinder the API for the user, since they
        // would be required to do that recursion in some scenarios

        filteredRows.forEach(function (row) {
          filteredFlatRows.push(row);
          filteredRowsById[row.id] = row;

          if (!row.subRows) {
            return;
          }

          row.subRows = row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows;
        });
        return filteredRows;
      };

      return [filterRows(rows), filteredFlatRows, filteredRowsById];
    }, [manualFilters, filters, rows, flatRows, rowsById, allColumns, userFilterTypes]),
        filteredRows = _React$useMemo[0],
        filteredFlatRows = _React$useMemo[1],
        filteredRowsById = _React$useMemo[2];

    React.useMemo(function () {
      // Now that each filtered column has it's partially filtered rows,
      // lets assign the final filtered rows to all of the other columns
      var nonFilteredColumns = allColumns.filter(function (column) {
        return !filters.find(function (d) {
          return d.id === column.id;
        });
      }); // This essentially enables faceted filter options to be built easily
      // using every column's preFilteredRows value

      nonFilteredColumns.forEach(function (column) {
        column.preFilteredRows = filteredRows;
        column.filteredRows = filteredRows;
      });
    }, [filteredRows, filters, allColumns]);
    var getAutoResetFilters = useGetLatest(autoResetFilters);
    useMountedLayoutEffect(function () {
      if (getAutoResetFilters()) {
        dispatch({
          type: actions.resetFilters
        });
      }
    }, [dispatch, manualFilters ? null : data]);
    Object.assign(instance, {
      preFilteredRows: rows,
      preFilteredFlatRows: flatRows,
      preFilteredRowsById: rowsById,
      filteredRows: filteredRows,
      filteredFlatRows: filteredFlatRows,
      filteredRowsById: filteredRowsById,
      rows: filteredRows,
      flatRows: filteredFlatRows,
      rowsById: filteredRowsById,
      setFilter: setFilter,
      setAllFilters: setAllFilters
    });
  }

  actions.resetGlobalFilter = 'resetGlobalFilter';
  actions.setGlobalFilter = 'setGlobalFilter';
  var useGlobalFilter = function useGlobalFilter(hooks) {
    hooks.stateReducers.push(reducer$3);
    hooks.useInstance.push(useInstance$3);
  };
  useGlobalFilter.pluginName = 'useGlobalFilter';

  function reducer$3(state, action, previousState, instance) {
    if (action.type === actions.resetGlobalFilter) {
      return _extends({}, state, {
        globalFilter: instance.initialState.globalFilter || undefined
      });
    }

    if (action.type === actions.setGlobalFilter) {
      var filterValue = action.filterValue;
      var userFilterTypes = instance.userFilterTypes;
      var filterMethod = getFilterMethod(instance.globalFilter, userFilterTypes || {}, filterTypes);
      var newFilter = functionalUpdate(filterValue, state.globalFilter); //

      if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter)) {
        var globalFilter = state.globalFilter,
            stateWithoutGlobalFilter = _objectWithoutPropertiesLoose(state, ["globalFilter"]);

        return stateWithoutGlobalFilter;
      }

      return _extends({}, state, {
        globalFilter: newFilter
      });
    }
  }

  function useInstance$3(instance) {
    var data = instance.data,
        rows = instance.rows,
        flatRows = instance.flatRows,
        rowsById = instance.rowsById,
        allColumns = instance.allColumns,
        userFilterTypes = instance.filterTypes,
        globalFilter = instance.globalFilter,
        manualGlobalFilter = instance.manualGlobalFilter,
        globalFilterValue = instance.state.globalFilter,
        dispatch = instance.dispatch,
        _instance$autoResetGl = instance.autoResetGlobalFilter,
        autoResetGlobalFilter = _instance$autoResetGl === void 0 ? true : _instance$autoResetGl,
        disableGlobalFilter = instance.disableGlobalFilter;
    var setGlobalFilter = React.useCallback(function (filterValue) {
      dispatch({
        type: actions.setGlobalFilter,
        filterValue: filterValue
      });
    }, [dispatch]); // TODO: Create a filter cache for incremental high speed multi-filtering
    // This gets pretty complicated pretty fast, since you have to maintain a
    // cache for each row group (top-level rows, and each row's recursive subrows)
    // This would make multi-filtering a lot faster though. Too far?

    var _React$useMemo = React.useMemo(function () {
      if (manualGlobalFilter || typeof globalFilterValue === 'undefined') {
        return [rows, flatRows, rowsById];
      }

      var filteredFlatRows = [];
      var filteredRowsById = {};
      var filterMethod = getFilterMethod(globalFilter, userFilterTypes || {}, filterTypes);

      if (!filterMethod) {
        console.warn("Could not find a valid 'globalFilter' option.");
        return rows;
      }

      allColumns.forEach(function (column) {
        var columnDisableGlobalFilter = column.disableGlobalFilter;
        column.canFilter = getFirstDefined(columnDisableGlobalFilter === true ? false : undefined, disableGlobalFilter === true ? false : undefined, true);
      });
      var filterableColumns = allColumns.filter(function (c) {
        return c.canFilter === true;
      }); // Filters top level and nested rows

      var filterRows = function filterRows(filteredRows) {
        filteredRows = filterMethod(filteredRows, filterableColumns.map(function (d) {
          return d.id;
        }), globalFilterValue);
        filteredRows.forEach(function (row) {
          filteredFlatRows.push(row);
          filteredRowsById[row.id] = row;
          row.subRows = row.subRows && row.subRows.length ? filterRows(row.subRows) : row.subRows;
        });
        return filteredRows;
      };

      return [filterRows(rows), filteredFlatRows, filteredRowsById];
    }, [manualGlobalFilter, globalFilterValue, globalFilter, userFilterTypes, allColumns, rows, flatRows, rowsById, disableGlobalFilter]),
        globalFilteredRows = _React$useMemo[0],
        globalFilteredFlatRows = _React$useMemo[1],
        globalFilteredRowsById = _React$useMemo[2];

    var getAutoResetGlobalFilter = useGetLatest(autoResetGlobalFilter);
    useMountedLayoutEffect(function () {
      if (getAutoResetGlobalFilter()) {
        dispatch({
          type: actions.resetGlobalFilter
        });
      }
    }, [dispatch, manualGlobalFilter ? null : data]);
    Object.assign(instance, {
      preGlobalFilteredRows: rows,
      preGlobalFilteredFlatRows: flatRows,
      preGlobalFilteredRowsById: rowsById,
      globalFilteredRows: globalFilteredRows,
      globalFilteredFlatRows: globalFilteredFlatRows,
      globalFilteredRowsById: globalFilteredRowsById,
      rows: globalFilteredRows,
      flatRows: globalFilteredFlatRows,
      rowsById: globalFilteredRowsById,
      setGlobalFilter: setGlobalFilter,
      disableGlobalFilter: disableGlobalFilter
    });
  }

  function sum(values, aggregatedValues) {
    // It's faster to just add the aggregations together instead of
    // process leaf nodes individually
    return aggregatedValues.reduce(function (sum, next) {
      return sum + (typeof next === 'number' ? next : 0);
    }, 0);
  }
  function min(values) {
    var min = values[0] || 0;
    values.forEach(function (value) {
      if (typeof value === 'number') {
        min = Math.min(min, value);
      }
    });
    return min;
  }
  function max(values) {
    var max = values[0] || 0;
    values.forEach(function (value) {
      if (typeof value === 'number') {
        max = Math.max(max, value);
      }
    });
    return max;
  }
  function minMax(values) {
    var min = values[0] || 0;
    var max = values[0] || 0;
    values.forEach(function (value) {
      if (typeof value === 'number') {
        min = Math.min(min, value);
        max = Math.max(max, value);
      }
    });
    return min + ".." + max;
  }
  function average(values) {
    return sum(null, values) / values.length;
  }
  function median(values) {
    if (!values.length) {
      return null;
    }

    var mid = Math.floor(values.length / 2);
    var nums = [].concat(values).sort(function (a, b) {
      return a - b;
    });
    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
  }
  function unique(values) {
    return Array.from(new Set(values).values());
  }
  function uniqueCount(values) {
    return new Set(values).size;
  }
  function count(values) {
    return values.length;
  }

  var aggregations = /*#__PURE__*/Object.freeze({
    __proto__: null,
    sum: sum,
    min: min,
    max: max,
    minMax: minMax,
    average: average,
    median: median,
    unique: unique,
    uniqueCount: uniqueCount,
    count: count
  });

  var emptyArray = [];
  var emptyObject = {}; // Actions

  actions.resetGroupBy = 'resetGroupBy';
  actions.setGroupBy = 'setGroupBy';
  actions.toggleGroupBy = 'toggleGroupBy';
  var useGroupBy = function useGroupBy(hooks) {
    hooks.getGroupByToggleProps = [defaultGetGroupByToggleProps];
    hooks.stateReducers.push(reducer$4);
    hooks.visibleColumnsDeps.push(function (deps, _ref) {
      var instance = _ref.instance;
      return [].concat(deps, [instance.state.groupBy]);
    });
    hooks.visibleColumns.push(visibleColumns);
    hooks.useInstance.push(useInstance$4);
    hooks.prepareRow.push(prepareRow$1);
  };
  useGroupBy.pluginName = 'useGroupBy';

  var defaultGetGroupByToggleProps = function defaultGetGroupByToggleProps(props, _ref2) {
    var header = _ref2.header;
    return [props, {
      onClick: header.canGroupBy ? function (e) {
        e.persist();
        header.toggleGroupBy();
      } : undefined,
      style: {
        cursor: header.canGroupBy ? 'pointer' : undefined
      },
      title: 'Toggle GroupBy'
    }];
  }; // Reducer


  function reducer$4(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        groupBy: []
      }, state);
    }

    if (action.type === actions.resetGroupBy) {
      return _extends({}, state, {
        groupBy: instance.initialState.groupBy || []
      });
    }

    if (action.type === actions.setGroupBy) {
      var value = action.value;
      return _extends({}, state, {
        groupBy: value
      });
    }

    if (action.type === actions.toggleGroupBy) {
      var columnId = action.columnId,
          setGroupBy = action.value;
      var resolvedGroupBy = typeof setGroupBy !== 'undefined' ? setGroupBy : !state.groupBy.includes(columnId);

      if (resolvedGroupBy) {
        return _extends({}, state, {
          groupBy: [].concat(state.groupBy, [columnId])
        });
      }

      return _extends({}, state, {
        groupBy: state.groupBy.filter(function (d) {
          return d !== columnId;
        })
      });
    }
  }

  function visibleColumns(columns, _ref3) {
    var groupBy = _ref3.instance.state.groupBy;
    // Sort grouped columns to the start of the column list
    // before the headers are built
    var groupByColumns = groupBy.map(function (g) {
      return columns.find(function (col) {
        return col.id === g;
      });
    }).filter(Boolean);
    var nonGroupByColumns = columns.filter(function (col) {
      return !groupBy.includes(col.id);
    });
    columns = [].concat(groupByColumns, nonGroupByColumns);
    columns.forEach(function (column) {
      column.isGrouped = groupBy.includes(column.id);
      column.groupedIndex = groupBy.indexOf(column.id);
    });
    return columns;
  }

  var defaultUserAggregations = {};

  function useInstance$4(instance) {
    var data = instance.data,
        rows = instance.rows,
        flatRows = instance.flatRows,
        rowsById = instance.rowsById,
        allColumns = instance.allColumns,
        flatHeaders = instance.flatHeaders,
        _instance$groupByFn = instance.groupByFn,
        groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,
        manualGroupBy = instance.manualGroupBy,
        _instance$aggregation = instance.aggregations,
        userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation,
        plugins = instance.plugins,
        groupBy = instance.state.groupBy,
        dispatch = instance.dispatch,
        _instance$autoResetGr = instance.autoResetGroupBy,
        autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr,
        disableGroupBy = instance.disableGroupBy,
        defaultCanGroupBy = instance.defaultCanGroupBy,
        getHooks = instance.getHooks;
    ensurePluginOrder(plugins, ['useColumnOrder', 'useFilters'], 'useGroupBy');
    var getInstance = useGetLatest(instance);
    allColumns.forEach(function (column) {
      var accessor = column.accessor,
          defaultColumnGroupBy = column.defaultGroupBy,
          columnDisableGroupBy = column.disableGroupBy;
      column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);

      if (column.canGroupBy) {
        column.toggleGroupBy = function () {
          return instance.toggleGroupBy(column.id);
        };
      }

      column.Aggregated = column.Aggregated || column.Cell;
    });
    var toggleGroupBy = React.useCallback(function (columnId, value) {
      dispatch({
        type: actions.toggleGroupBy,
        columnId: columnId,
        value: value
      });
    }, [dispatch]);
    var setGroupBy = React.useCallback(function (value) {
      dispatch({
        type: actions.setGroupBy,
        value: value
      });
    }, [dispatch]);
    flatHeaders.forEach(function (header) {
      header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {
        instance: getInstance(),
        header: header
      });
    });

    var _React$useMemo = React.useMemo(function () {
      if (manualGroupBy || !groupBy.length) {
        return [rows, flatRows, rowsById, emptyArray, emptyObject, flatRows, rowsById];
      } // Ensure that the list of filtered columns exist


      var existingGroupBy = groupBy.filter(function (g) {
        return allColumns.find(function (col) {
          return col.id === g;
        });
      }); // Find the columns that can or are aggregating
      // Uses each column to aggregate rows into a single value

      var aggregateRowsToValues = function aggregateRowsToValues(leafRows, groupedRows, depth) {
        var values = {};
        allColumns.forEach(function (column) {
          // Don't aggregate columns that are in the groupBy
          if (existingGroupBy.includes(column.id)) {
            values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;
            return;
          } // Aggregate the values


          var aggregateFn = typeof column.aggregate === 'function' ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];

          if (aggregateFn) {
            // Get the columnValues to aggregate
            var groupedValues = groupedRows.map(function (row) {
              return row.values[column.id];
            }); // Get the columnValues to aggregate

            var leafValues = leafRows.map(function (row) {
              var columnValue = row.values[column.id];

              if (!depth && column.aggregateValue) {
                var aggregateValueFn = typeof column.aggregateValue === 'function' ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];

                if (!aggregateValueFn) {
                  console.info({
                    column: column
                  });
                  throw new Error("React Table: Invalid column.aggregateValue option for column listed above");
                }

                columnValue = aggregateValueFn(columnValue, row, column);
              }

              return columnValue;
            });
            values[column.id] = aggregateFn(leafValues, groupedValues);
          } else if (column.aggregate) {
            console.info({
              column: column
            });
            throw new Error("React Table: Invalid column.aggregate option for column listed above");
          } else {
            values[column.id] = null;
          }
        });
        return values;
      };

      var groupedFlatRows = [];
      var groupedRowsById = {};
      var onlyGroupedFlatRows = [];
      var onlyGroupedRowsById = {};
      var nonGroupedFlatRows = [];
      var nonGroupedRowsById = {}; // Recursively group the data

      var groupUpRecursively = function groupUpRecursively(rows, depth, parentId) {
        if (depth === void 0) {
          depth = 0;
        }

        // This is the last level, just return the rows
        if (depth === existingGroupBy.length) {
          return rows.map(function (row) {
            return _extends({}, row, {
              depth: depth
            });
          });
        }

        var columnId = existingGroupBy[depth]; // Group the rows together for this level

        var rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group

        var aggregatedGroupedRows = Object.entries(rowGroupsMap).map(function (_ref4, index) {
          var groupByVal = _ref4[0],
              groupedRows = _ref4[1];
          var id = columnId + ":" + groupByVal;
          id = parentId ? parentId + ">" + id : id; // First, Recurse to group sub rows before aggregation

          var subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group

          var leafRows = depth ? flattenBy(groupedRows, 'leafRows') : groupedRows;
          var values = aggregateRowsToValues(leafRows, groupedRows, depth);
          var row = {
            id: id,
            isGrouped: true,
            groupByID: columnId,
            groupByVal: groupByVal,
            values: values,
            subRows: subRows,
            leafRows: leafRows,
            depth: depth,
            index: index
          };
          subRows.forEach(function (subRow) {
            groupedFlatRows.push(subRow);
            groupedRowsById[subRow.id] = subRow;

            if (subRow.isGrouped) {
              onlyGroupedFlatRows.push(subRow);
              onlyGroupedRowsById[subRow.id] = subRow;
            } else {
              nonGroupedFlatRows.push(subRow);
              nonGroupedRowsById[subRow.id] = subRow;
            }
          });
          return row;
        });
        return aggregatedGroupedRows;
      };

      var groupedRows = groupUpRecursively(rows);
      groupedRows.forEach(function (subRow) {
        groupedFlatRows.push(subRow);
        groupedRowsById[subRow.id] = subRow;

        if (subRow.isGrouped) {
          onlyGroupedFlatRows.push(subRow);
          onlyGroupedRowsById[subRow.id] = subRow;
        } else {
          nonGroupedFlatRows.push(subRow);
          nonGroupedRowsById[subRow.id] = subRow;
        }
      }); // Assign the new data

      return [groupedRows, groupedFlatRows, groupedRowsById, onlyGroupedFlatRows, onlyGroupedRowsById, nonGroupedFlatRows, nonGroupedRowsById];
    }, [manualGroupBy, groupBy, rows, flatRows, rowsById, allColumns, userAggregations, groupByFn]),
        groupedRows = _React$useMemo[0],
        groupedFlatRows = _React$useMemo[1],
        groupedRowsById = _React$useMemo[2],
        onlyGroupedFlatRows = _React$useMemo[3],
        onlyGroupedRowsById = _React$useMemo[4],
        nonGroupedFlatRows = _React$useMemo[5],
        nonGroupedRowsById = _React$useMemo[6];

    var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);
    useMountedLayoutEffect(function () {
      if (getAutoResetGroupBy()) {
        dispatch({
          type: actions.resetGroupBy
        });
      }
    }, [dispatch, manualGroupBy ? null : data]);
    Object.assign(instance, {
      preGroupedRows: rows,
      preGroupedFlatRow: flatRows,
      preGroupedRowsById: rowsById,
      groupedRows: groupedRows,
      groupedFlatRows: groupedFlatRows,
      groupedRowsById: groupedRowsById,
      onlyGroupedFlatRows: onlyGroupedFlatRows,
      onlyGroupedRowsById: onlyGroupedRowsById,
      nonGroupedFlatRows: nonGroupedFlatRows,
      nonGroupedRowsById: nonGroupedRowsById,
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById,
      toggleGroupBy: toggleGroupBy,
      setGroupBy: setGroupBy
    });
  }

  function prepareRow$1(row) {
    row.allCells.forEach(function (cell) {
      var _row$subRows;

      // Grouped cells are in the groupBy and the pivot cell for the row
      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped

      cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows

      cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length);
    });
  }

  function defaultGroupByFn(rows, columnId) {
    return rows.reduce(function (prev, row, i) {
      // TODO: Might want to implement a key serializer here so
      // irregular column values can still be grouped if needed?
      var resKey = "" + row.values[columnId];
      prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];
      prev[resKey].push(row);
      return prev;
    }, {});
  }

  var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.
  // It handles numbers, mixed alphanumeric combinations, and even
  // null, undefined, and Infinity

  var alphanumeric = function alphanumeric(rowA, rowB, columnId) {
    var _getRowValuesByColumn = getRowValuesByColumnID(rowA, rowB, columnId),
        a = _getRowValuesByColumn[0],
        b = _getRowValuesByColumn[1]; // Force to strings (or "" for unsupported types)


    a = toString(a);
    b = toString(b); // Split on number groups, but keep the delimiter
    // Then remove falsey split values

    a = a.split(reSplitAlphaNumeric).filter(Boolean);
    b = b.split(reSplitAlphaNumeric).filter(Boolean); // While

    while (a.length && b.length) {
      var aa = a.shift();
      var bb = b.shift();
      var an = parseInt(aa, 10);
      var bn = parseInt(bb, 10);
      var combo = [an, bn].sort(); // Both are string

      if (isNaN(combo[0])) {
        if (aa > bb) {
          return 1;
        }

        if (bb > aa) {
          return -1;
        }

        continue;
      } // One is a string, one is a number


      if (isNaN(combo[1])) {
        return isNaN(an) ? -1 : 1;
      } // Both are numbers


      if (an > bn) {
        return 1;
      }

      if (bn > an) {
        return -1;
      }
    }

    return a.length - b.length;
  };
  function datetime(rowA, rowB, columnId) {
    var _getRowValuesByColumn2 = getRowValuesByColumnID(rowA, rowB, columnId),
        a = _getRowValuesByColumn2[0],
        b = _getRowValuesByColumn2[1];

    a = a.getTime();
    b = b.getTime();
    return compareBasic(a, b);
  }
  function basic(rowA, rowB, columnId) {
    var _getRowValuesByColumn3 = getRowValuesByColumnID(rowA, rowB, columnId),
        a = _getRowValuesByColumn3[0],
        b = _getRowValuesByColumn3[1];

    return compareBasic(a, b);
  }
  function string(rowA, rowB, columnId) {
    var _getRowValuesByColumn4 = getRowValuesByColumnID(rowA, rowB, columnId),
        a = _getRowValuesByColumn4[0],
        b = _getRowValuesByColumn4[1];

    a = a.split('').filter(Boolean);
    b = b.split('').filter(Boolean);

    while (a.length && b.length) {
      var aa = a.shift();
      var bb = b.shift();
      var alower = aa.toLowerCase();
      var blower = bb.toLowerCase(); // Case insensitive comparison until characters match

      if (alower > blower) {
        return 1;
      }

      if (blower > alower) {
        return -1;
      } // If lowercase characters are identical


      if (aa > bb) {
        return 1;
      }

      if (bb > aa) {
        return -1;
      }

      continue;
    }

    return a.length - b.length;
  }
  function number(rowA, rowB, columnId) {
    var _getRowValuesByColumn5 = getRowValuesByColumnID(rowA, rowB, columnId),
        a = _getRowValuesByColumn5[0],
        b = _getRowValuesByColumn5[1];

    var replaceNonNumeric = /[^0-9.]/gi;
    a = Number(String(a).replace(replaceNonNumeric, ''));
    b = Number(String(b).replace(replaceNonNumeric, ''));
    return compareBasic(a, b);
  } // Utils

  function compareBasic(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
  }

  function getRowValuesByColumnID(row1, row2, columnId) {
    return [row1.values[columnId], row2.values[columnId]];
  }

  function toString(a) {
    if (typeof a === 'number') {
      if (isNaN(a) || a === Infinity || a === -Infinity) {
        return '';
      }

      return String(a);
    }

    if (typeof a === 'string') {
      return a;
    }

    return '';
  }

  var sortTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    alphanumeric: alphanumeric,
    datetime: datetime,
    basic: basic,
    string: string,
    number: number
  });

  actions.resetSortBy = 'resetSortBy';
  actions.setSortBy = 'setSortBy';
  actions.toggleSortBy = 'toggleSortBy';
  actions.clearSortBy = 'clearSortBy';
  defaultColumn.sortType = 'alphanumeric';
  defaultColumn.sortDescFirst = false;
  var useSortBy = function useSortBy(hooks) {
    hooks.getSortByToggleProps = [defaultGetSortByToggleProps];
    hooks.stateReducers.push(reducer$5);
    hooks.useInstance.push(useInstance$5);
  };
  useSortBy.pluginName = 'useSortBy';

  var defaultGetSortByToggleProps = function defaultGetSortByToggleProps(props, _ref) {
    var instance = _ref.instance,
        column = _ref.column;
    var _instance$isMultiSort = instance.isMultiSortEvent,
        isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {
      return e.shiftKey;
    } : _instance$isMultiSort;
    return [props, {
      onClick: column.canSort ? function (e) {
        e.persist();
        column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));
      } : undefined,
      style: {
        cursor: column.canSort ? 'pointer' : undefined
      },
      title: column.canSort ? 'Toggle SortBy' : undefined
    }];
  }; // Reducer


  function reducer$5(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        sortBy: []
      }, state);
    }

    if (action.type === actions.resetSortBy) {
      return _extends({}, state, {
        sortBy: instance.initialState.sortBy || []
      });
    }

    if (action.type === actions.clearSortBy) {
      var sortBy = state.sortBy;
      var newSortBy = sortBy.filter(function (d) {
        return d.id !== action.columnId;
      });
      return _extends({}, state, {
        sortBy: newSortBy
      });
    }

    if (action.type === actions.setSortBy) {
      var _sortBy = action.sortBy;
      return _extends({}, state, {
        sortBy: _sortBy
      });
    }

    if (action.type === actions.toggleSortBy) {
      var columnId = action.columnId,
          desc = action.desc,
          multi = action.multi;
      var allColumns = instance.allColumns,
          disableMultiSort = instance.disableMultiSort,
          disableSortRemove = instance.disableSortRemove,
          disableMultiRemove = instance.disableMultiRemove,
          _instance$maxMultiSor = instance.maxMultiSortColCount,
          maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor;
      var _sortBy2 = state.sortBy; // Find the column for this columnId

      var column = allColumns.find(function (d) {
        return d.id === columnId;
      });
      var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column

      var existingSortBy = _sortBy2.find(function (d) {
        return d.id === columnId;
      });

      var existingIndex = _sortBy2.findIndex(function (d) {
        return d.id === columnId;
      });

      var hasDescDefined = typeof desc !== 'undefined' && desc !== null;
      var _newSortBy = []; // What should we do with this sort action?

      var sortAction;

      if (!disableMultiSort && multi) {
        if (existingSortBy) {
          sortAction = 'toggle';
        } else {
          sortAction = 'add';
        }
      } else {
        // Normal mode
        if (existingIndex !== _sortBy2.length - 1 || _sortBy2.length !== 1) {
          sortAction = 'replace';
        } else if (existingSortBy) {
          sortAction = 'toggle';
        } else {
          sortAction = 'replace';
        }
      } // Handle toggle states that will remove the sortBy


      if (sortAction === 'toggle' && // Must be toggling
      !disableSortRemove && // If disableSortRemove, disable in general
      !hasDescDefined && ( // Must not be setting desc
      multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove
      existingSortBy && // Finally, detect if it should indeed be removed
      existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {
        sortAction = 'remove';
      }

      if (sortAction === 'replace') {
        _newSortBy = [{
          id: columnId,
          desc: hasDescDefined ? desc : sortDescFirst
        }];
      } else if (sortAction === 'add') {
        _newSortBy = [].concat(_sortBy2, [{
          id: columnId,
          desc: hasDescDefined ? desc : sortDescFirst
        }]); // Take latest n columns

        _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);
      } else if (sortAction === 'toggle') {
        // This flips (or sets) the
        _newSortBy = _sortBy2.map(function (d) {
          if (d.id === columnId) {
            return _extends({}, d, {
              desc: hasDescDefined ? desc : !existingSortBy.desc
            });
          }

          return d;
        });
      } else if (sortAction === 'remove') {
        _newSortBy = _sortBy2.filter(function (d) {
          return d.id !== columnId;
        });
      }

      return _extends({}, state, {
        sortBy: _newSortBy
      });
    }
  }

  function useInstance$5(instance) {
    var data = instance.data,
        rows = instance.rows,
        flatRows = instance.flatRows,
        allColumns = instance.allColumns,
        _instance$orderByFn = instance.orderByFn,
        orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,
        userSortTypes = instance.sortTypes,
        manualSortBy = instance.manualSortBy,
        defaultCanSort = instance.defaultCanSort,
        disableSortBy = instance.disableSortBy,
        flatHeaders = instance.flatHeaders,
        sortBy = instance.state.sortBy,
        dispatch = instance.dispatch,
        plugins = instance.plugins,
        getHooks = instance.getHooks,
        _instance$autoResetSo = instance.autoResetSortBy,
        autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;
    ensurePluginOrder(plugins, ['useFilters', 'useGlobalFilter', 'useGroupBy', 'usePivotColumns'], 'useSortBy');
    var setSortBy = React.useCallback(function (sortBy) {
      dispatch({
        type: actions.setSortBy,
        sortBy: sortBy
      });
    }, [dispatch]); // Updates sorting based on a columnId, desc flag and multi flag

    var toggleSortBy = React.useCallback(function (columnId, desc, multi) {
      dispatch({
        type: actions.toggleSortBy,
        columnId: columnId,
        desc: desc,
        multi: multi
      });
    }, [dispatch]); // use reference to avoid memory leak in #1608

    var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers

    flatHeaders.forEach(function (column) {
      var accessor = column.accessor,
          defaultColumnCanSort = column.canSort,
          columnDisableSortBy = column.disableSortBy,
          id = column.id;
      var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);
      column.canSort = canSort;

      if (column.canSort) {
        column.toggleSortBy = function (desc, multi) {
          return toggleSortBy(column.id, desc, multi);
        };

        column.clearSortBy = function () {
          dispatch({
            type: actions.clearSortBy,
            columnId: column.id
          });
        };
      }

      column.getSortByToggleProps = makePropGetter(getHooks().getSortByToggleProps, {
        instance: getInstance(),
        column: column
      });
      var columnSort = sortBy.find(function (d) {
        return d.id === id;
      });
      column.isSorted = !!columnSort;
      column.sortedIndex = sortBy.findIndex(function (d) {
        return d.id === id;
      });
      column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;
    });

    var _React$useMemo = React.useMemo(function () {
      if (manualSortBy || !sortBy.length) {
        return [rows, flatRows];
      }

      var sortedFlatRows = []; // Filter out sortBys that correspond to non existing columns

      var availableSortBy = sortBy.filter(function (sort) {
        return allColumns.find(function (col) {
          return col.id === sort.id;
        });
      });

      var sortData = function sortData(rows) {
        // Use the orderByFn to compose multiple sortBy's together.
        // This will also perform a stable sorting using the row index
        // if needed.
        var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {
          // Support custom sorting methods for each column
          var column = allColumns.find(function (d) {
            return d.id === sort.id;
          });

          if (!column) {
            throw new Error("React-Table: Could not find a column with id: " + sort.id + " while sorting");
          }

          var sortType = column.sortType; // Look up sortBy functions in this order:
          // column function
          // column string lookup on user sortType
          // column string lookup on built-in sortType
          // default function
          // default string lookup on user sortType
          // default string lookup on built-in sortType

          var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];

          if (!sortMethod) {
            throw new Error("React-Table: Could not find a valid sortType of '" + sortType + "' for column '" + sort.id + "'.");
          } // Return the correct sortFn.
          // This function should always return in ascending order


          return function (a, b) {
            return sortMethod(a, b, sort.id, sort.desc);
          };
        }), // Map the directions
        availableSortBy.map(function (sort) {
          // Detect and use the sortInverted option
          var column = allColumns.find(function (d) {
            return d.id === sort.id;
          });

          if (column && column.sortInverted) {
            return sort.desc;
          }

          return !sort.desc;
        })); // If there are sub-rows, sort them

        sortedData.forEach(function (row) {
          sortedFlatRows.push(row);

          if (!row.subRows || row.subRows.length === 0) {
            return;
          }

          row.subRows = sortData(row.subRows);
        });
        return sortedData;
      };

      return [sortData(rows), sortedFlatRows];
    }, [manualSortBy, sortBy, rows, flatRows, allColumns, orderByFn, userSortTypes]),
        sortedRows = _React$useMemo[0],
        sortedFlatRows = _React$useMemo[1];

    var getAutoResetSortBy = useGetLatest(autoResetSortBy);
    useMountedLayoutEffect(function () {
      if (getAutoResetSortBy()) {
        dispatch({
          type: actions.resetSortBy
        });
      }
    }, [manualSortBy ? null : data]);
    Object.assign(instance, {
      preSortedRows: rows,
      preSortedFlatRows: flatRows,
      sortedRows: sortedRows,
      sortedFlatRows: sortedFlatRows,
      rows: sortedRows,
      flatRows: sortedFlatRows,
      setSortBy: setSortBy,
      toggleSortBy: toggleSortBy
    });
  }

  function defaultOrderByFn(arr, funcs, dirs) {
    return [].concat(arr).sort(function (rowA, rowB) {
      for (var i = 0; i < funcs.length; i += 1) {
        var sortFn = funcs[i];
        var desc = dirs[i] === false || dirs[i] === 'desc';
        var sortInt = sortFn(rowA, rowB);

        if (sortInt !== 0) {
          return desc ? -sortInt : sortInt;
        }
      }

      return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;
    });
  }

  var pluginName = 'usePagination'; // Actions

  actions.resetPage = 'resetPage';
  actions.gotoPage = 'gotoPage';
  actions.setPageSize = 'setPageSize';
  var usePagination = function usePagination(hooks) {
    hooks.stateReducers.push(reducer$6);
    hooks.useInstance.push(useInstance$6);
  };
  usePagination.pluginName = pluginName;

  function reducer$6(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        pageSize: 10,
        pageIndex: 0
      }, state);
    }

    if (action.type === actions.resetPage) {
      return _extends({}, state, {
        pageIndex: instance.initialState.pageIndex || 0
      });
    }

    if (action.type === actions.gotoPage) {
      var pageCount = instance.pageCount,
          page = instance.page;
      var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);
      var canNavigate = false;

      if (newPageIndex > state.pageIndex) {
        // next page
        canNavigate = pageCount === -1 ? page.length >= state.pageSize : newPageIndex < pageCount;
      } else if (newPageIndex < state.pageIndex) {
        // prev page
        canNavigate = newPageIndex > -1;
      }

      if (!canNavigate) {
        return state;
      }

      return _extends({}, state, {
        pageIndex: newPageIndex
      });
    }

    if (action.type === actions.setPageSize) {
      var pageSize = action.pageSize;
      var topRowIndex = state.pageSize * state.pageIndex;
      var pageIndex = Math.floor(topRowIndex / pageSize);
      return _extends({}, state, {
        pageIndex: pageIndex,
        pageSize: pageSize
      });
    }
  }

  function useInstance$6(instance) {
    var rows = instance.rows,
        _instance$autoResetPa = instance.autoResetPage,
        autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa,
        _instance$manualExpan = instance.manualExpandedKey,
        manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
        plugins = instance.plugins,
        userPageCount = instance.pageCount,
        _instance$paginateExp = instance.paginateExpandedRows,
        paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
        _instance$expandSubRo = instance.expandSubRows,
        expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
        _instance$state = instance.state,
        pageSize = _instance$state.pageSize,
        pageIndex = _instance$state.pageIndex,
        expanded = _instance$state.expanded,
        globalFilter = _instance$state.globalFilter,
        filters = _instance$state.filters,
        groupBy = _instance$state.groupBy,
        sortBy = _instance$state.sortBy,
        dispatch = instance.dispatch,
        data = instance.data,
        manualPagination = instance.manualPagination;
    ensurePluginOrder(plugins, ['useGlobalFilter', 'useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination');
    var getAutoResetPage = useGetLatest(autoResetPage);
    useMountedLayoutEffect(function () {
      if (getAutoResetPage()) {
        dispatch({
          type: actions.resetPage
        });
      }
    }, [dispatch, manualPagination ? null : data, globalFilter, filters, groupBy, sortBy]);
    var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);
    var pageOptions = React.useMemo(function () {
      return pageCount > 0 ? [].concat(new Array(pageCount)).fill(null).map(function (d, i) {
        return i;
      }) : [];
    }, [pageCount]);
    var page = React.useMemo(function () {
      var page;

      if (manualPagination) {
        page = rows;
      } else {
        var pageStart = pageSize * pageIndex;
        var pageEnd = pageStart + pageSize;
        page = rows.slice(pageStart, pageEnd);
      }

      if (paginateExpandedRows) {
        return page;
      }

      return expandRows(page, {
        manualExpandedKey: manualExpandedKey,
        expanded: expanded,
        expandSubRows: expandSubRows
      });
    }, [expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);
    var canPreviousPage = pageIndex > 0;
    var canNextPage = pageCount === -1 ? page.length >= pageSize : pageIndex < pageCount - 1;
    var gotoPage = React.useCallback(function (pageIndex) {
      dispatch({
        type: actions.gotoPage,
        pageIndex: pageIndex
      });
    }, [dispatch]);
    var previousPage = React.useCallback(function () {
      return gotoPage(function (old) {
        return old - 1;
      });
    }, [gotoPage]);
    var nextPage = React.useCallback(function () {
      return gotoPage(function (old) {
        return old + 1;
      });
    }, [gotoPage]);
    var setPageSize = React.useCallback(function (pageSize) {
      dispatch({
        type: actions.setPageSize,
        pageSize: pageSize
      });
    }, [dispatch]);
    Object.assign(instance, {
      pageOptions: pageOptions,
      pageCount: pageCount,
      page: page,
      canPreviousPage: canPreviousPage,
      canNextPage: canNextPage,
      gotoPage: gotoPage,
      previousPage: previousPage,
      nextPage: nextPage,
      setPageSize: setPageSize
    });
  }

  actions.resetPivot = 'resetPivot';
  actions.togglePivot = 'togglePivot';
  var _UNSTABLE_usePivotColumns = function _UNSTABLE_usePivotColumns(hooks) {
    hooks.getPivotToggleProps = [defaultGetPivotToggleProps];
    hooks.stateReducers.push(reducer$7);
    hooks.useInstanceAfterData.push(useInstanceAfterData);
    hooks.allColumns.push(allColumns);
    hooks.accessValue.push(accessValue);
    hooks.materializedColumns.push(materializedColumns);
    hooks.materializedColumnsDeps.push(materializedColumnsDeps);
    hooks.visibleColumns.push(visibleColumns$1);
    hooks.visibleColumnsDeps.push(visibleColumnsDeps);
    hooks.useInstance.push(useInstance$7);
    hooks.prepareRow.push(prepareRow$2);
  };
  _UNSTABLE_usePivotColumns.pluginName = 'usePivotColumns';
  var defaultPivotColumns = [];

  var defaultGetPivotToggleProps = function defaultGetPivotToggleProps(props, _ref) {
    var header = _ref.header;
    return [props, {
      onClick: header.canPivot ? function (e) {
        e.persist();
        header.togglePivot();
      } : undefined,
      style: {
        cursor: header.canPivot ? 'pointer' : undefined
      },
      title: 'Toggle Pivot'
    }];
  }; // Reducer


  function reducer$7(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        pivotColumns: defaultPivotColumns
      }, state);
    }

    if (action.type === actions.resetPivot) {
      return _extends({}, state, {
        pivotColumns: instance.initialState.pivotColumns || defaultPivotColumns
      });
    }

    if (action.type === actions.togglePivot) {
      var columnId = action.columnId,
          setPivot = action.value;
      var resolvedPivot = typeof setPivot !== 'undefined' ? setPivot : !state.pivotColumns.includes(columnId);

      if (resolvedPivot) {
        return _extends({}, state, {
          pivotColumns: [].concat(state.pivotColumns, [columnId])
        });
      }

      return _extends({}, state, {
        pivotColumns: state.pivotColumns.filter(function (d) {
          return d !== columnId;
        })
      });
    }
  }

  function useInstanceAfterData(instance) {
    instance.allColumns.forEach(function (column) {
      column.isPivotSource = instance.state.pivotColumns.includes(column.id);
    });
  }

  function allColumns(columns, _ref2) {
    var instance = _ref2.instance;
    columns.forEach(function (column) {
      column.isPivotSource = instance.state.pivotColumns.includes(column.id);
      column.uniqueValues = new Set();
    });
    return columns;
  }

  function accessValue(value, _ref3) {
    var column = _ref3.column;

    if (column.uniqueValues && typeof value !== 'undefined') {
      column.uniqueValues.add(value);
    }

    return value;
  }

  function materializedColumns(materialized, _ref4) {
    var instance = _ref4.instance;
    var allColumns = instance.allColumns,
        state = instance.state;

    if (!state.pivotColumns.length || !state.groupBy || !state.groupBy.length) {
      return materialized;
    }

    var pivotColumns = state.pivotColumns.map(function (id) {
      return allColumns.find(function (d) {
        return d.id === id;
      });
    }).filter(Boolean);
    var sourceColumns = allColumns.filter(function (d) {
      return !d.isPivotSource && !state.groupBy.includes(d.id) && !state.pivotColumns.includes(d.id);
    });

    var buildPivotColumns = function buildPivotColumns(depth, parent, pivotFilters) {
      if (depth === void 0) {
        depth = 0;
      }

      if (pivotFilters === void 0) {
        pivotFilters = [];
      }

      var pivotColumn = pivotColumns[depth];

      if (!pivotColumn) {
        return sourceColumns.map(function (sourceColumn) {
          // TODO: We could offer support here for renesting pivoted
          // columns inside copies of their header groups. For now,
          // that seems like it would be (1) overkill on nesting, considering
          // you already get nesting for every pivot level and (2)
          // really hard. :)
          return _extends({}, sourceColumn, {
            canPivot: false,
            isPivoted: true,
            parent: parent,
            depth: depth,
            id: "" + (parent ? parent.id + "." + sourceColumn.id : sourceColumn.id),
            accessor: function accessor(originalRow, i, row) {
              if (pivotFilters.every(function (filter) {
                return filter(row);
              })) {
                return row.values[sourceColumn.id];
              }
            }
          });
        });
      }

      var uniqueValues = Array.from(pivotColumn.uniqueValues).sort();
      return uniqueValues.map(function (uniqueValue) {
        var columnGroup = _extends({}, pivotColumn, {
          Header: pivotColumn.PivotHeader || typeof pivotColumn.header === 'string' ? pivotColumn.Header + ": " + uniqueValue : uniqueValue,
          isPivotGroup: true,
          parent: parent,
          depth: depth,
          id: parent ? parent.id + "." + pivotColumn.id + "." + uniqueValue : pivotColumn.id + "." + uniqueValue,
          pivotValue: uniqueValue
        });

        columnGroup.columns = buildPivotColumns(depth + 1, columnGroup, [].concat(pivotFilters, [function (row) {
          return row.values[pivotColumn.id] === uniqueValue;
        }]));
        return columnGroup;
      });
    };

    var newMaterialized = flattenColumns(buildPivotColumns());
    return [].concat(materialized, newMaterialized);
  }

  function materializedColumnsDeps(deps, _ref5) {
    var _ref5$instance$state = _ref5.instance.state,
        pivotColumns = _ref5$instance$state.pivotColumns,
        groupBy = _ref5$instance$state.groupBy;
    return [].concat(deps, [pivotColumns, groupBy]);
  }

  function visibleColumns$1(visibleColumns, _ref6) {
    var state = _ref6.instance.state;
    visibleColumns = visibleColumns.filter(function (d) {
      return !d.isPivotSource;
    });

    if (state.pivotColumns.length && state.groupBy && state.groupBy.length) {
      visibleColumns = visibleColumns.filter(function (column) {
        return column.isGrouped || column.isPivoted;
      });
    }

    return visibleColumns;
  }

  function visibleColumnsDeps(deps, _ref7) {
    var instance = _ref7.instance;
    return [].concat(deps, [instance.state.pivotColumns, instance.state.groupBy]);
  }

  function useInstance$7(instance) {
    var columns = instance.columns,
        allColumns = instance.allColumns,
        flatHeaders = instance.flatHeaders,
        getHooks = instance.getHooks,
        plugins = instance.plugins,
        dispatch = instance.dispatch,
        _instance$autoResetPi = instance.autoResetPivot,
        autoResetPivot = _instance$autoResetPi === void 0 ? true : _instance$autoResetPi,
        manaulPivot = instance.manaulPivot,
        disablePivot = instance.disablePivot,
        defaultCanPivot = instance.defaultCanPivot;
    ensurePluginOrder(plugins, ['useGroupBy'], 'usePivotColumns');
    var getInstance = useGetLatest(instance);
    allColumns.forEach(function (column) {
      var accessor = column.accessor,
          defaultColumnPivot = column.defaultPivot,
          columnDisablePivot = column.disablePivot;
      column.canPivot = accessor ? getFirstDefined(column.canPivot, columnDisablePivot === true ? false : undefined, disablePivot === true ? false : undefined, true) : getFirstDefined(column.canPivot, defaultColumnPivot, defaultCanPivot, false);

      if (column.canPivot) {
        column.togglePivot = function () {
          return instance.togglePivot(column.id);
        };
      }

      column.Aggregated = column.Aggregated || column.Cell;
    });

    var togglePivot = function togglePivot(columnId, value) {
      dispatch({
        type: actions.togglePivot,
        columnId: columnId,
        value: value
      });
    };

    flatHeaders.forEach(function (header) {
      header.getPivotToggleProps = makePropGetter(getHooks().getPivotToggleProps, {
        instance: getInstance(),
        header: header
      });
    });
    var getAutoResetPivot = useGetLatest(autoResetPivot);
    useMountedLayoutEffect(function () {
      if (getAutoResetPivot()) {
        dispatch({
          type: actions.resetPivot
        });
      }
    }, [dispatch, manaulPivot ? null : columns]);
    Object.assign(instance, {
      togglePivot: togglePivot
    });
  }

  function prepareRow$2(row) {
    row.allCells.forEach(function (cell) {
      // Grouped cells are in the pivotColumns and the pivot cell for the row
      cell.isPivoted = cell.column.isPivoted;
    });
  }

  var pluginName$1 = 'useRowSelect'; // Actions

  actions.resetSelectedRows = 'resetSelectedRows';
  actions.toggleAllRowsSelected = 'toggleAllRowsSelected';
  actions.toggleRowSelected = 'toggleRowSelected';
  actions.toggleAllPageRowsSelected = 'toggleAllPageRowsSelected';
  var useRowSelect = function useRowSelect(hooks) {
    hooks.getToggleRowSelectedProps = [defaultGetToggleRowSelectedProps];
    hooks.getToggleAllRowsSelectedProps = [defaultGetToggleAllRowsSelectedProps];
    hooks.getToggleAllPageRowsSelectedProps = [defaultGetToggleAllPageRowsSelectedProps];
    hooks.stateReducers.push(reducer$8);
    hooks.useInstance.push(useInstance$8);
    hooks.prepareRow.push(prepareRow$3);
  };
  useRowSelect.pluginName = pluginName$1;

  var defaultGetToggleRowSelectedProps = function defaultGetToggleRowSelectedProps(props, _ref) {
    var instance = _ref.instance,
        row = _ref.row;
    var _instance$manualRowSe = instance.manualRowSelectedKey,
        manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe;
    var checked = false;

    if (row.original && row.original[manualRowSelectedKey]) {
      checked = true;
    } else {
      checked = row.isSelected;
    }

    return [props, {
      onChange: function onChange(e) {
        row.toggleRowSelected(e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: checked,
      title: 'Toggle Row Selected',
      indeterminate: row.isSomeSelected
    }];
  };

  var defaultGetToggleAllRowsSelectedProps = function defaultGetToggleAllRowsSelectedProps(props, _ref2) {
    var instance = _ref2.instance;
    return [props, {
      onChange: function onChange(e) {
        instance.toggleAllRowsSelected(e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: instance.isAllRowsSelected,
      title: 'Toggle All Rows Selected',
      indeterminate: Boolean(!instance.isAllRowsSelected && Object.keys(instance.state.selectedRowIds).length)
    }];
  };

  var defaultGetToggleAllPageRowsSelectedProps = function defaultGetToggleAllPageRowsSelectedProps(props, _ref3) {
    var instance = _ref3.instance;
    return [props, {
      onChange: function onChange(e) {
        instance.toggleAllPageRowsSelected(e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: instance.isAllPageRowsSelected,
      title: 'Toggle All Current Page Rows Selected',
      indeterminate: Boolean(!instance.isAllPageRowsSelected && instance.page.some(function (_ref4) {
        var id = _ref4.id;
        return instance.state.selectedRowIds[id];
      }))
    }];
  }; // eslint-disable-next-line max-params


  function reducer$8(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        selectedRowIds: {}
      }, state);
    }

    if (action.type === actions.resetSelectedRows) {
      return _extends({}, state, {
        selectedRowIds: instance.initialState.selectedRowIds || {}
      });
    }

    if (action.type === actions.toggleAllRowsSelected) {
      var setSelected = action.value;
      var isAllRowsSelected = instance.isAllRowsSelected,
          rowsById = instance.rowsById,
          _instance$nonGroupedR = instance.nonGroupedRowsById,
          nonGroupedRowsById = _instance$nonGroupedR === void 0 ? rowsById : _instance$nonGroupedR;
      var selectAll = typeof setSelected !== 'undefined' ? setSelected : !isAllRowsSelected; // Only remove/add the rows that are visible on the screen
      //  Leave all the other rows that are selected alone.

      var selectedRowIds = Object.assign({}, state.selectedRowIds);

      if (selectAll) {
        Object.keys(nonGroupedRowsById).forEach(function (rowId) {
          selectedRowIds[rowId] = true;
        });
      } else {
        Object.keys(nonGroupedRowsById).forEach(function (rowId) {
          delete selectedRowIds[rowId];
        });
      }

      return _extends({}, state, {
        selectedRowIds: selectedRowIds
      });
    }

    if (action.type === actions.toggleRowSelected) {
      var id = action.id,
          _setSelected = action.value;
      var _rowsById = instance.rowsById,
          _instance$selectSubRo = instance.selectSubRows,
          selectSubRows = _instance$selectSubRo === void 0 ? true : _instance$selectSubRo,
          getSubRows = instance.getSubRows;
      var isSelected = state.selectedRowIds[id];
      var shouldExist = typeof _setSelected !== 'undefined' ? _setSelected : !isSelected;

      if (isSelected === shouldExist) {
        return state;
      }

      var newSelectedRowIds = _extends({}, state.selectedRowIds);

      var handleRowById = function handleRowById(id) {
        var row = _rowsById[id];

        if (row) {
          if (!row.isGrouped) {
            if (shouldExist) {
              newSelectedRowIds[id] = true;
            } else {
              delete newSelectedRowIds[id];
            }
          }

          if (selectSubRows && getSubRows(row)) {
            return getSubRows(row).forEach(function (row) {
              return handleRowById(row.id);
            });
          }
        }
      };

      handleRowById(id);
      return _extends({}, state, {
        selectedRowIds: newSelectedRowIds
      });
    }

    if (action.type === actions.toggleAllPageRowsSelected) {
      var _setSelected2 = action.value;

      var page = instance.page,
          _rowsById2 = instance.rowsById,
          _instance$selectSubRo2 = instance.selectSubRows,
          _selectSubRows = _instance$selectSubRo2 === void 0 ? true : _instance$selectSubRo2,
          isAllPageRowsSelected = instance.isAllPageRowsSelected,
          _getSubRows = instance.getSubRows;

      var _selectAll = typeof _setSelected2 !== 'undefined' ? _setSelected2 : !isAllPageRowsSelected;

      var _newSelectedRowIds = _extends({}, state.selectedRowIds);

      var _handleRowById = function _handleRowById(id) {
        var row = _rowsById2[id];

        if (!row.isGrouped) {
          if (_selectAll) {
            _newSelectedRowIds[id] = true;
          } else {
            delete _newSelectedRowIds[id];
          }
        }

        if (_selectSubRows && _getSubRows(row)) {
          return _getSubRows(row).forEach(function (row) {
            return _handleRowById(row.id);
          });
        }
      };

      page.forEach(function (row) {
        return _handleRowById(row.id);
      });
      return _extends({}, state, {
        selectedRowIds: _newSelectedRowIds
      });
    }

    return state;
  }

  function useInstance$8(instance) {
    var data = instance.data,
        rows = instance.rows,
        getHooks = instance.getHooks,
        plugins = instance.plugins,
        rowsById = instance.rowsById,
        _instance$nonGroupedR2 = instance.nonGroupedRowsById,
        nonGroupedRowsById = _instance$nonGroupedR2 === void 0 ? rowsById : _instance$nonGroupedR2,
        _instance$autoResetSe = instance.autoResetSelectedRows,
        autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe,
        selectedRowIds = instance.state.selectedRowIds,
        _instance$selectSubRo3 = instance.selectSubRows,
        selectSubRows = _instance$selectSubRo3 === void 0 ? true : _instance$selectSubRo3,
        dispatch = instance.dispatch,
        page = instance.page,
        getSubRows = instance.getSubRows;
    ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded', 'usePagination'], 'useRowSelect');
    var selectedFlatRows = React.useMemo(function () {
      var selectedFlatRows = [];
      rows.forEach(function (row) {
        var isSelected = selectSubRows ? getRowIsSelected(row, selectedRowIds, getSubRows) : !!selectedRowIds[row.id];
        row.isSelected = !!isSelected;
        row.isSomeSelected = isSelected === null;

        if (isSelected) {
          selectedFlatRows.push(row);
        }
      });
      return selectedFlatRows;
    }, [rows, selectSubRows, selectedRowIds, getSubRows]);
    var isAllRowsSelected = Boolean(Object.keys(nonGroupedRowsById).length && Object.keys(selectedRowIds).length);
    var isAllPageRowsSelected = isAllRowsSelected;

    if (isAllRowsSelected) {
      if (Object.keys(nonGroupedRowsById).some(function (id) {
        return !selectedRowIds[id];
      })) {
        isAllRowsSelected = false;
      }
    }

    if (!isAllRowsSelected) {
      if (page && page.length && page.some(function (_ref5) {
        var id = _ref5.id;
        return !selectedRowIds[id];
      })) {
        isAllPageRowsSelected = false;
      }
    }

    var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);
    useMountedLayoutEffect(function () {
      if (getAutoResetSelectedRows()) {
        dispatch({
          type: actions.resetSelectedRows
        });
      }
    }, [dispatch, data]);
    var toggleAllRowsSelected = React.useCallback(function (value) {
      return dispatch({
        type: actions.toggleAllRowsSelected,
        value: value
      });
    }, [dispatch]);
    var toggleAllPageRowsSelected = React.useCallback(function (value) {
      return dispatch({
        type: actions.toggleAllPageRowsSelected,
        value: value
      });
    }, [dispatch]);
    var toggleRowSelected = React.useCallback(function (id, value) {
      return dispatch({
        type: actions.toggleRowSelected,
        id: id,
        value: value
      });
    }, [dispatch]);
    var getInstance = useGetLatest(instance);
    var getToggleAllRowsSelectedProps = makePropGetter(getHooks().getToggleAllRowsSelectedProps, {
      instance: getInstance()
    });
    var getToggleAllPageRowsSelectedProps = makePropGetter(getHooks().getToggleAllPageRowsSelectedProps, {
      instance: getInstance()
    });
    Object.assign(instance, {
      selectedFlatRows: selectedFlatRows,
      isAllRowsSelected: isAllRowsSelected,
      isAllPageRowsSelected: isAllPageRowsSelected,
      toggleRowSelected: toggleRowSelected,
      toggleAllRowsSelected: toggleAllRowsSelected,
      getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,
      getToggleAllPageRowsSelectedProps: getToggleAllPageRowsSelectedProps,
      toggleAllPageRowsSelected: toggleAllPageRowsSelected
    });
  }

  function prepareRow$3(row, _ref6) {
    var instance = _ref6.instance;

    row.toggleRowSelected = function (set) {
      return instance.toggleRowSelected(row.id, set);
    };

    row.getToggleRowSelectedProps = makePropGetter(instance.getHooks().getToggleRowSelectedProps, {
      instance: instance,
      row: row
    });
  }

  function getRowIsSelected(row, selectedRowIds, getSubRows) {
    if (selectedRowIds[row.id]) {
      return true;
    }

    var subRows = getSubRows(row);

    if (subRows && subRows.length) {
      var allChildrenSelected = true;
      var someSelected = false;
      subRows.forEach(function (subRow) {
        // Bail out early if we know both of these
        if (someSelected && !allChildrenSelected) {
          return;
        }

        if (getRowIsSelected(subRow, selectedRowIds, getSubRows)) {
          someSelected = true;
        } else {
          allChildrenSelected = false;
        }
      });
      return allChildrenSelected ? true : someSelected ? null : false;
    }

    return false;
  }

  var defaultInitialRowStateAccessor = function defaultInitialRowStateAccessor(row) {
    return {};
  };

  var defaultInitialCellStateAccessor = function defaultInitialCellStateAccessor(cell) {
    return {};
  }; // Actions


  actions.setRowState = 'setRowState';
  actions.setCellState = 'setCellState';
  actions.resetRowState = 'resetRowState';
  var useRowState = function useRowState(hooks) {
    hooks.stateReducers.push(reducer$9);
    hooks.useInstance.push(useInstance$9);
    hooks.prepareRow.push(prepareRow$4);
  };
  useRowState.pluginName = 'useRowState';

  function reducer$9(state, action, previousState, instance) {
    var _instance$initialRowS = instance.initialRowStateAccessor,
        initialRowStateAccessor = _instance$initialRowS === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS,
        _instance$initialCell = instance.initialCellStateAccessor,
        initialCellStateAccessor = _instance$initialCell === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell,
        rowsById = instance.rowsById;

    if (action.type === actions.init) {
      return _extends({
        rowState: {}
      }, state);
    }

    if (action.type === actions.resetRowState) {
      return _extends({}, state, {
        rowState: instance.initialState.rowState || {}
      });
    }

    if (action.type === actions.setRowState) {
      var _extends2;

      var rowId = action.rowId,
          value = action.value;
      var oldRowState = typeof state.rowState[rowId] !== 'undefined' ? state.rowState[rowId] : initialRowStateAccessor(rowsById[rowId]);
      return _extends({}, state, {
        rowState: _extends({}, state.rowState, (_extends2 = {}, _extends2[rowId] = functionalUpdate(value, oldRowState), _extends2))
      });
    }

    if (action.type === actions.setCellState) {
      var _oldRowState$cellStat, _rowsById$_rowId, _rowsById$_rowId$cell, _extends3, _extends4;

      var _rowId = action.rowId,
          columnId = action.columnId,
          _value = action.value;

      var _oldRowState = typeof state.rowState[_rowId] !== 'undefined' ? state.rowState[_rowId] : initialRowStateAccessor(rowsById[_rowId]);

      var oldCellState = typeof (_oldRowState == null ? void 0 : (_oldRowState$cellStat = _oldRowState.cellState) == null ? void 0 : _oldRowState$cellStat[columnId]) !== 'undefined' ? _oldRowState.cellState[columnId] : initialCellStateAccessor((_rowsById$_rowId = rowsById[_rowId]) == null ? void 0 : (_rowsById$_rowId$cell = _rowsById$_rowId.cells) == null ? void 0 : _rowsById$_rowId$cell.find(function (cell) {
        return cell.column.id === columnId;
      }));
      return _extends({}, state, {
        rowState: _extends({}, state.rowState, (_extends4 = {}, _extends4[_rowId] = _extends({}, _oldRowState, {
          cellState: _extends({}, _oldRowState.cellState || {}, (_extends3 = {}, _extends3[columnId] = functionalUpdate(_value, oldCellState), _extends3))
        }), _extends4))
      });
    }
  }

  function useInstance$9(instance) {
    var _instance$autoResetRo = instance.autoResetRowState,
        autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo,
        data = instance.data,
        dispatch = instance.dispatch;
    var setRowState = React.useCallback(function (rowId, value) {
      return dispatch({
        type: actions.setRowState,
        rowId: rowId,
        value: value
      });
    }, [dispatch]);
    var setCellState = React.useCallback(function (rowId, columnId, value) {
      return dispatch({
        type: actions.setCellState,
        rowId: rowId,
        columnId: columnId,
        value: value
      });
    }, [dispatch]);
    var getAutoResetRowState = useGetLatest(autoResetRowState);
    useMountedLayoutEffect(function () {
      if (getAutoResetRowState()) {
        dispatch({
          type: actions.resetRowState
        });
      }
    }, [data]);
    Object.assign(instance, {
      setRowState: setRowState,
      setCellState: setCellState
    });
  }

  function prepareRow$4(row, _ref) {
    var instance = _ref.instance;
    var _instance$initialRowS2 = instance.initialRowStateAccessor,
        initialRowStateAccessor = _instance$initialRowS2 === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS2,
        _instance$initialCell2 = instance.initialCellStateAccessor,
        initialCellStateAccessor = _instance$initialCell2 === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell2,
        rowState = instance.state.rowState;

    if (row) {
      row.state = typeof rowState[row.id] !== 'undefined' ? rowState[row.id] : initialRowStateAccessor(row);

      row.setState = function (updater) {
        return instance.setRowState(row.id, updater);
      };

      row.cells.forEach(function (cell) {
        if (!row.state.cellState) {
          row.state.cellState = {};
        }

        cell.state = typeof row.state.cellState[cell.column.id] !== 'undefined' ? row.state.cellState[cell.column.id] : initialCellStateAccessor(cell);

        cell.setState = function (updater) {
          return instance.setCellState(row.id, cell.column.id, updater);
        };
      });
    }
  }

  actions.resetColumnOrder = 'resetColumnOrder';
  actions.setColumnOrder = 'setColumnOrder';
  var useColumnOrder = function useColumnOrder(hooks) {
    hooks.stateReducers.push(reducer$a);
    hooks.visibleColumnsDeps.push(function (deps, _ref) {
      var instance = _ref.instance;
      return [].concat(deps, [instance.state.columnOrder]);
    });
    hooks.visibleColumns.push(visibleColumns$2);
    hooks.useInstance.push(useInstance$a);
  };
  useColumnOrder.pluginName = 'useColumnOrder';

  function reducer$a(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        columnOrder: []
      }, state);
    }

    if (action.type === actions.resetColumnOrder) {
      return _extends({}, state, {
        columnOrder: instance.initialState.columnOrder || []
      });
    }

    if (action.type === actions.setColumnOrder) {
      return _extends({}, state, {
        columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)
      });
    }
  }

  function visibleColumns$2(columns, _ref2) {
    var columnOrder = _ref2.instance.state.columnOrder;

    // If there is no order, return the normal columns
    if (!columnOrder || !columnOrder.length) {
      return columns;
    }

    var columnOrderCopy = [].concat(columnOrder); // If there is an order, make a copy of the columns

    var columnsCopy = [].concat(columns); // And make a new ordered array of the columns

    var columnsInOrder = []; // Loop over the columns and place them in order into the new array

    var _loop = function _loop() {
      var targetColumnId = columnOrderCopy.shift();
      var foundIndex = columnsCopy.findIndex(function (d) {
        return d.id === targetColumnId;
      });

      if (foundIndex > -1) {
        columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);
      }
    };

    while (columnsCopy.length && columnOrderCopy.length) {
      _loop();
    } // If there are any columns left, add them to the end


    return [].concat(columnsInOrder, columnsCopy);
  }

  function useInstance$a(instance) {
    var dispatch = instance.dispatch;
    instance.setColumnOrder = React.useCallback(function (columnOrder) {
      return dispatch({
        type: actions.setColumnOrder,
        columnOrder: columnOrder
      });
    }, [dispatch]);
  }

  defaultColumn.canResize = true; // Actions

  actions.columnStartResizing = 'columnStartResizing';
  actions.columnResizing = 'columnResizing';
  actions.columnDoneResizing = 'columnDoneResizing';
  actions.resetResize = 'resetResize';
  var useResizeColumns = function useResizeColumns(hooks) {
    hooks.getResizerProps = [defaultGetResizerProps];
    hooks.getHeaderProps.push({
      style: {
        position: 'relative'
      }
    });
    hooks.stateReducers.push(reducer$b);
    hooks.useInstance.push(useInstance$b);
    hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);
  };

  var defaultGetResizerProps = function defaultGetResizerProps(props, _ref) {
    var instance = _ref.instance,
        header = _ref.header;
    var dispatch = instance.dispatch;

    var onResizeStart = function onResizeStart(e, header) {
      var isTouchEvent = false;

      if (e.type === 'touchstart') {
        // lets not respond to multiple touches (e.g. 2 or 3 fingers)
        if (e.touches && e.touches.length > 1) {
          return;
        }

        isTouchEvent = true;
      }

      var headersToResize = getLeafHeaders(header);
      var headerIdWidths = headersToResize.map(function (d) {
        return [d.id, d.totalWidth];
      });
      var clientX = isTouchEvent ? Math.round(e.touches[0].clientX) : e.clientX;
      var raf;
      var mostRecentClientX;

      var dispatchEnd = function dispatchEnd() {
        window.cancelAnimationFrame(raf);
        raf = null;
        dispatch({
          type: actions.columnDoneResizing
        });
      };

      var dispatchMove = function dispatchMove() {
        window.cancelAnimationFrame(raf);
        raf = null;
        dispatch({
          type: actions.columnResizing,
          clientX: mostRecentClientX
        });
      };

      var scheduleDispatchMoveOnNextAnimationFrame = function scheduleDispatchMoveOnNextAnimationFrame(clientXPos) {
        mostRecentClientX = clientXPos;

        if (!raf) {
          raf = window.requestAnimationFrame(dispatchMove);
        }
      };

      var handlersAndEvents = {
        mouse: {
          moveEvent: 'mousemove',
          moveHandler: function moveHandler(e) {
            return scheduleDispatchMoveOnNextAnimationFrame(e.clientX);
          },
          upEvent: 'mouseup',
          upHandler: function upHandler(e) {
            document.removeEventListener('mousemove', handlersAndEvents.mouse.moveHandler);
            document.removeEventListener('mouseup', handlersAndEvents.mouse.upHandler);
            dispatchEnd();
          }
        },
        touch: {
          moveEvent: 'touchmove',
          moveHandler: function moveHandler(e) {
            if (e.cancelable) {
              e.preventDefault();
              e.stopPropagation();
            }

            scheduleDispatchMoveOnNextAnimationFrame(e.touches[0].clientX);
            return false;
          },
          upEvent: 'touchend',
          upHandler: function upHandler(e) {
            document.removeEventListener(handlersAndEvents.touch.moveEvent, handlersAndEvents.touch.moveHandler);
            document.removeEventListener(handlersAndEvents.touch.upEvent, handlersAndEvents.touch.moveHandler);
            dispatchEnd();
          }
        }
      };
      var events = isTouchEvent ? handlersAndEvents.touch : handlersAndEvents.mouse;
      var passiveIfSupported = passiveEventSupported() ? {
        passive: false
      } : false;
      document.addEventListener(events.moveEvent, events.moveHandler, passiveIfSupported);
      document.addEventListener(events.upEvent, events.upHandler, passiveIfSupported);
      dispatch({
        type: actions.columnStartResizing,
        columnId: header.id,
        columnWidth: header.totalWidth,
        headerIdWidths: headerIdWidths,
        clientX: clientX
      });
    };

    return [props, {
      onMouseDown: function onMouseDown(e) {
        return e.persist() || onResizeStart(e, header);
      },
      onTouchStart: function onTouchStart(e) {
        return e.persist() || onResizeStart(e, header);
      },
      style: {
        cursor: 'col-resize'
      },
      draggable: false,
      role: 'separator'
    }];
  };

  useResizeColumns.pluginName = 'useResizeColumns';

  function reducer$b(state, action) {
    if (action.type === actions.init) {
      return _extends({
        columnResizing: {
          columnWidths: {}
        }
      }, state);
    }

    if (action.type === actions.resetResize) {
      return _extends({}, state, {
        columnResizing: {
          columnWidths: {}
        }
      });
    }

    if (action.type === actions.columnStartResizing) {
      var clientX = action.clientX,
          columnId = action.columnId,
          columnWidth = action.columnWidth,
          headerIdWidths = action.headerIdWidths;
      return _extends({}, state, {
        columnResizing: _extends({}, state.columnResizing, {
          startX: clientX,
          headerIdWidths: headerIdWidths,
          columnWidth: columnWidth,
          isResizingColumn: columnId
        })
      });
    }

    if (action.type === actions.columnResizing) {
      var _clientX = action.clientX;

      var _state$columnResizing = state.columnResizing,
          startX = _state$columnResizing.startX,
          _columnWidth = _state$columnResizing.columnWidth,
          _state$columnResizing2 = _state$columnResizing.headerIdWidths,
          _headerIdWidths = _state$columnResizing2 === void 0 ? [] : _state$columnResizing2;

      var deltaX = _clientX - startX;
      var percentageDeltaX = deltaX / _columnWidth;
      var newColumnWidths = {};

      _headerIdWidths.forEach(function (_ref2) {
        var headerId = _ref2[0],
            headerWidth = _ref2[1];
        newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);
      });

      return _extends({}, state, {
        columnResizing: _extends({}, state.columnResizing, {
          columnWidths: _extends({}, state.columnResizing.columnWidths, {}, newColumnWidths)
        })
      });
    }

    if (action.type === actions.columnDoneResizing) {
      return _extends({}, state, {
        columnResizing: _extends({}, state.columnResizing, {
          startX: null,
          isResizingColumn: null
        })
      });
    }
  }

  var useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {
    var flatHeaders = instance.flatHeaders,
        disableResizing = instance.disableResizing,
        getHooks = instance.getHooks,
        columnResizing = instance.state.columnResizing;
    var getInstance = useGetLatest(instance);
    flatHeaders.forEach(function (header) {
      var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);
      header.canResize = canResize;
      header.width = columnResizing.columnWidths[header.id] || header.originalWidth || header.width;
      header.isResizing = columnResizing.isResizingColumn === header.id;

      if (canResize) {
        header.getResizerProps = makePropGetter(getHooks().getResizerProps, {
          instance: getInstance(),
          header: header
        });
      }
    });
  };

  function useInstance$b(instance) {
    var plugins = instance.plugins,
        dispatch = instance.dispatch,
        _instance$autoResetRe = instance.autoResetResize,
        autoResetResize = _instance$autoResetRe === void 0 ? true : _instance$autoResetRe,
        columns = instance.columns;
    ensurePluginOrder(plugins, ['useAbsoluteLayout'], 'useResizeColumns');
    var getAutoResetResize = useGetLatest(autoResetResize);
    useMountedLayoutEffect(function () {
      if (getAutoResetResize()) {
        dispatch({
          type: actions.resetResize
        });
      }
    }, [columns]);
    var resetResizing = React.useCallback(function () {
      return dispatch({
        type: actions.resetResize
      });
    }, [dispatch]);
    Object.assign(instance, {
      resetResizing: resetResizing
    });
  }

  function getLeafHeaders(header) {
    var leafHeaders = [];

    var recurseHeader = function recurseHeader(header) {
      if (header.columns && header.columns.length) {
        header.columns.map(recurseHeader);
      }

      leafHeaders.push(header);
    };

    recurseHeader(header);
    return leafHeaders;
  }

  var cellStyles = {
    position: 'absolute',
    top: 0
  };
  var useAbsoluteLayout = function useAbsoluteLayout(hooks) {
    hooks.getTableBodyProps.push(getRowStyles);
    hooks.getRowProps.push(getRowStyles);
    hooks.getHeaderGroupProps.push(getRowStyles);
    hooks.getFooterGroupProps.push(getRowStyles);
    hooks.getHeaderProps.push(function (props, _ref) {
      var column = _ref.column;
      return [props, {
        style: _extends({}, cellStyles, {
          left: column.totalLeft + "px",
          width: column.totalWidth + "px"
        })
      }];
    });
    hooks.getCellProps.push(function (props, _ref2) {
      var cell = _ref2.cell;
      return [props, {
        style: _extends({}, cellStyles, {
          left: cell.column.totalLeft + "px",
          width: cell.column.totalWidth + "px"
        })
      }];
    });
    hooks.getFooterProps.push(function (props, _ref3) {
      var column = _ref3.column;
      return [props, {
        style: _extends({}, cellStyles, {
          left: column.totalLeft + "px",
          width: column.totalWidth + "px"
        })
      }];
    });
  };
  useAbsoluteLayout.pluginName = 'useAbsoluteLayout';

  var getRowStyles = function getRowStyles(props, _ref4) {
    var instance = _ref4.instance;
    return [props, {
      style: {
        position: 'relative',
        width: instance.totalColumnsWidth + "px"
      }
    }];
  };

  var cellStyles$1 = {
    display: 'inline-block',
    boxSizing: 'border-box'
  };

  var getRowStyles$1 = function getRowStyles(props, _ref) {
    var instance = _ref.instance;
    return [props, {
      style: {
        display: 'flex',
        width: instance.totalColumnsWidth + "px"
      }
    }];
  };

  var useBlockLayout = function useBlockLayout(hooks) {
    hooks.getRowProps.push(getRowStyles$1);
    hooks.getHeaderGroupProps.push(getRowStyles$1);
    hooks.getFooterGroupProps.push(getRowStyles$1);
    hooks.getHeaderProps.push(function (props, _ref2) {
      var column = _ref2.column;
      return [props, {
        style: _extends({}, cellStyles$1, {
          width: column.totalWidth + "px"
        })
      }];
    });
    hooks.getCellProps.push(function (props, _ref3) {
      var cell = _ref3.cell;
      return [props, {
        style: _extends({}, cellStyles$1, {
          width: cell.column.totalWidth + "px"
        })
      }];
    });
    hooks.getFooterProps.push(function (props, _ref4) {
      var column = _ref4.column;
      return [props, {
        style: _extends({}, cellStyles$1, {
          width: column.totalWidth + "px"
        })
      }];
    });
  };
  useBlockLayout.pluginName = 'useBlockLayout';

  function useFlexLayout(hooks) {
    hooks.getTableProps.push(getTableProps);
    hooks.getRowProps.push(getRowStyles$2);
    hooks.getHeaderGroupProps.push(getRowStyles$2);
    hooks.getFooterGroupProps.push(getRowStyles$2);
    hooks.getHeaderProps.push(getHeaderProps);
    hooks.getCellProps.push(getCellProps);
    hooks.getFooterProps.push(getFooterProps);
  }
  useFlexLayout.pluginName = 'useFlexLayout';

  var getTableProps = function getTableProps(props, _ref) {
    var instance = _ref.instance;
    return [props, {
      style: {
        minWidth: instance.totalColumnsMinWidth + "px"
      }
    }];
  };

  var getRowStyles$2 = function getRowStyles(props, _ref2) {
    var instance = _ref2.instance;
    return [props, {
      style: {
        display: 'flex',
        flex: '1 0 auto',
        minWidth: instance.totalColumnsMinWidth + "px"
      }
    }];
  };

  var getHeaderProps = function getHeaderProps(props, _ref3) {
    var column = _ref3.column;
    return [props, {
      style: {
        boxSizing: 'border-box',
        flex: column.totalFlexWidth ? column.totalFlexWidth + " 0 auto" : undefined,
        minWidth: column.totalMinWidth + "px",
        width: column.totalWidth + "px"
      }
    }];
  };

  var getCellProps = function getCellProps(props, _ref4) {
    var cell = _ref4.cell;
    return [props, {
      style: {
        boxSizing: 'border-box',
        flex: cell.column.totalFlexWidth + " 0 auto",
        minWidth: cell.column.totalMinWidth + "px",
        width: cell.column.totalWidth + "px"
      }
    }];
  };

  var getFooterProps = function getFooterProps(props, _ref5) {
    var column = _ref5.column;
    return [props, {
      style: {
        boxSizing: 'border-box',
        flex: column.totalFlexWidth ? column.totalFlexWidth + " 0 auto" : undefined,
        minWidth: column.totalMinWidth + "px",
        width: column.totalWidth + "px"
      }
    }];
  };

  actions.columnStartResizing = 'columnStartResizing';
  actions.columnResizing = 'columnResizing';
  actions.columnDoneResizing = 'columnDoneResizing';
  actions.resetResize = 'resetResize';
  function useGridLayout(hooks) {
    hooks.stateReducers.push(reducer$c);
    hooks.getTableProps.push(getTableProps$1);
    hooks.getHeaderProps.push(getHeaderProps$1);
    hooks.getRowProps.push(getRowProps);
  }
  useGridLayout.pluginName = 'useGridLayout';

  var getTableProps$1 = function getTableProps(props, _ref) {
    var instance = _ref.instance;
    var gridTemplateColumns = instance.visibleColumns.map(function (column) {
      var _instance$state$colum;

      if (instance.state.gridLayout.columnWidths[column.id]) return instance.state.gridLayout.columnWidths[column.id] + "px"; // When resizing, lock the width of all unset columns
      // instead of using user-provided width or defaultColumn width,
      // which could potentially be 'auto' or 'fr' units that don't scale linearly

      if ((_instance$state$colum = instance.state.columnResizing) == null ? void 0 : _instance$state$colum.isResizingColumn) return instance.state.gridLayout.startWidths[column.id] + "px";
      if (typeof column.width === 'number') return column.width + "px";
      return column.width;
    });
    return [props, {
      style: {
        display: "grid",
        gridTemplateColumns: gridTemplateColumns.join(" ")
      }
    }];
  };

  var getHeaderProps$1 = function getHeaderProps(props, _ref2) {
    var column = _ref2.column;
    return [props, {
      id: "header-cell-" + column.id,
      style: {
        position: "sticky",
        //enables a scroll wrapper to be placed around the table and have sticky headers
        gridColumn: "span " + column.totalVisibleHeaderCount
      }
    }];
  };

  var getRowProps = function getRowProps(props, _ref3) {
    var row = _ref3.row;

    if (row.isExpanded) {
      return [props, {
        style: {
          gridColumn: "1 / " + (row.cells.length + 1)
        }
      }];
    }

    return [props, {}];
  };

  function reducer$c(state, action, previousState, instance) {
    if (action.type === actions.init) {
      return _extends({
        gridLayout: {
          columnWidths: {}
        }
      }, state);
    }

    if (action.type === actions.resetResize) {
      return _extends({}, state, {
        gridLayout: {
          columnWidths: {}
        }
      });
    }

    if (action.type === actions.columnStartResizing) {
      var columnId = action.columnId,
          headerIdWidths = action.headerIdWidths;
      var columnWidth = getElementWidth(columnId);

      if (columnWidth !== undefined) {
        var startWidths = instance.visibleColumns.reduce(function (acc, column) {
          var _extends2;

          return _extends({}, acc, (_extends2 = {}, _extends2[column.id] = getElementWidth(column.id), _extends2));
        }, {});
        var minWidths = instance.visibleColumns.reduce(function (acc, column) {
          var _extends3;

          return _extends({}, acc, (_extends3 = {}, _extends3[column.id] = column.minWidth, _extends3));
        }, {});
        var maxWidths = instance.visibleColumns.reduce(function (acc, column) {
          var _extends4;

          return _extends({}, acc, (_extends4 = {}, _extends4[column.id] = column.maxWidth, _extends4));
        }, {});
        var headerIdGridWidths = headerIdWidths.map(function (_ref4) {
          var headerId = _ref4[0];
          return [headerId, getElementWidth(headerId)];
        });
        return _extends({}, state, {
          gridLayout: _extends({}, state.gridLayout, {
            startWidths: startWidths,
            minWidths: minWidths,
            maxWidths: maxWidths,
            headerIdGridWidths: headerIdGridWidths,
            columnWidth: columnWidth
          })
        });
      } else {
        return state;
      }
    }

    if (action.type === actions.columnResizing) {
      var clientX = action.clientX;
      var startX = state.columnResizing.startX;

      var _state$gridLayout = state.gridLayout,
          _columnWidth = _state$gridLayout.columnWidth,
          _minWidths = _state$gridLayout.minWidths,
          _maxWidths = _state$gridLayout.maxWidths,
          _state$gridLayout$hea = _state$gridLayout.headerIdGridWidths,
          _headerIdGridWidths = _state$gridLayout$hea === void 0 ? [] : _state$gridLayout$hea;

      var deltaX = clientX - startX;
      var percentageDeltaX = deltaX / _columnWidth;
      var newColumnWidths = {};

      _headerIdGridWidths.forEach(function (_ref5) {
        var headerId = _ref5[0],
            headerWidth = _ref5[1];
        newColumnWidths[headerId] = Math.min(Math.max(_minWidths[headerId], headerWidth + headerWidth * percentageDeltaX), _maxWidths[headerId]);
      });

      return _extends({}, state, {
        gridLayout: _extends({}, state.gridLayout, {
          columnWidths: _extends({}, state.gridLayout.columnWidths, {}, newColumnWidths)
        })
      });
    }

    if (action.type === actions.columnDoneResizing) {
      return _extends({}, state, {
        gridLayout: _extends({}, state.gridLayout, {
          startWidths: {},
          minWidths: {},
          maxWidths: {}
        })
      });
    }
  }

  function getElementWidth(columnId) {
    var _document$getElementB;

    var width = (_document$getElementB = document.getElementById("header-cell-" + columnId)) == null ? void 0 : _document$getElementB.offsetWidth;

    if (width !== undefined) {
      return width;
    }
  }

  exports._UNSTABLE_usePivotColumns = _UNSTABLE_usePivotColumns;
  exports.actions = actions;
  exports.defaultColumn = defaultColumn;
  exports.defaultGroupByFn = defaultGroupByFn;
  exports.defaultOrderByFn = defaultOrderByFn;
  exports.defaultRenderer = defaultRenderer;
  exports.emptyRenderer = emptyRenderer;
  exports.ensurePluginOrder = ensurePluginOrder;
  exports.flexRender = flexRender;
  exports.functionalUpdate = functionalUpdate;
  exports.loopHooks = loopHooks;
  exports.makePropGetter = makePropGetter;
  exports.makeRenderer = makeRenderer;
  exports.reduceHooks = reduceHooks;
  exports.safeUseLayoutEffect = safeUseLayoutEffect;
  exports.useAbsoluteLayout = useAbsoluteLayout;
  exports.useAsyncDebounce = useAsyncDebounce;
  exports.useBlockLayout = useBlockLayout;
  exports.useColumnOrder = useColumnOrder;
  exports.useExpanded = useExpanded;
  exports.useFilters = useFilters;
  exports.useFlexLayout = useFlexLayout;
  exports.useGetLatest = useGetLatest;
  exports.useGlobalFilter = useGlobalFilter;
  exports.useGridLayout = useGridLayout;
  exports.useGroupBy = useGroupBy;
  exports.useMountedLayoutEffect = useMountedLayoutEffect;
  exports.usePagination = usePagination;
  exports.useResizeColumns = useResizeColumns;
  exports.useRowSelect = useRowSelect;
  exports.useRowState = useRowState;
  exports.useSortBy = useSortBy;
  exports.useTable = useTable;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-table.development.js.map


/***/ }),

/***/ "./node_modules/react-table/index.js":
/*!*******************************************!*\
  !*** ./node_modules/react-table/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

if (false) {} else {
  module.exports = __webpack_require__(/*! ./dist/react-table.development.js */ "./node_modules/react-table/dist/react-table.development.js")
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmVhY3QtdGFibGVfaW5kZXhfanMubWFpbi1idW5kbGUtNjBlNmM0MGNkMzc5NjA0NjEzZmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMsNENBQU87QUFDakcsRUFBRSxDQUN3RTtBQUMxRSxDQUFDLG9DQUFvQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXOztBQUVwQztBQUNBLCtDQUErQyxtQkFBbUIsSUFBSSxhQUFhO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3QkFBd0I7QUFDeEI7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtB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QTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhIQUE4SDtBQUM5SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0I7QUFDbEQsU0FBUyxJQUFJO0FBQ2I7QUFDQTs7QUFFQSw0QkFBNEIsc0JBQXNCO0FBQ2xELFNBQVMsSUFBSTtBQUNiO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQjtBQUNsRCxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLG1DQUFtQyxtQ0FBbUM7QUFDdEUsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEOzs7Ozs7Ozs7OztBQ3ZqSkEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDJJQUE2RDtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5L3JvdXRpbmVseS9yb3V0aW5lbHkvcm91dGluZWx5Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYmxlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncmVhY3QnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3JlYWN0J10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdFRhYmxlID0ge30sIGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBSZWFjdCA9IFJlYWN0ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSZWFjdCwgJ2RlZmF1bHQnKSA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcblxuICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcblxuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICB2YXIgcmVuZGVyRXJyID0gJ1JlbmRlcmVyIEVycm9yIOKYne+4jyc7XG4gIHZhciBhY3Rpb25zID0ge1xuICAgIGluaXQ6ICdpbml0J1xuICB9O1xuICB2YXIgZGVmYXVsdFJlbmRlcmVyID0gZnVuY3Rpb24gZGVmYXVsdFJlbmRlcmVyKF9yZWYpIHtcbiAgICB2YXIgX3JlZiR2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgIHZhbHVlID0gX3JlZiR2YWx1ZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdmFyIGVtcHR5UmVuZGVyZXIgPSBmdW5jdGlvbiBlbXB0eVJlbmRlcmVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIlxceEEwXCIpO1xuICB9O1xuICB2YXIgZGVmYXVsdENvbHVtbiA9IHtcbiAgICBDZWxsOiBkZWZhdWx0UmVuZGVyZXIsXG4gICAgd2lkdGg6IDE1MCxcbiAgICBtaW5XaWR0aDogMCxcbiAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgfTtcblxuICBmdW5jdGlvbiBtZXJnZVByb3BzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wTGlzdCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHByb3BMaXN0W19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHByb3BzLCBuZXh0KSB7XG4gICAgICB2YXIgc3R5bGUgPSBuZXh0LnN0eWxlLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IG5leHQuY2xhc3NOYW1lLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShuZXh0LCBbXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgICAgIHByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7fSwgcmVzdCk7XG5cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBwcm9wcy5zdHlsZSA9IHByb3BzLnN0eWxlID8gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlIHx8IHt9LCB7fSwgc3R5bGUgfHwge30pIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lID8gcHJvcHMuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lIDogY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuY2xhc3NOYW1lID09PSAnJykge1xuICAgICAgICBkZWxldGUgcHJvcHMuY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfSwge30pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUHJvcEdldHRlcihwcmV2UHJvcHMsIHVzZXJQcm9wcywgbWV0YSkge1xuICAgIC8vIEhhbmRsZSBhIGxhbWJkYSwgcGFzcyBpdCB0aGUgcHJldmlvdXMgcHJvcHNcbiAgICBpZiAodHlwZW9mIHVzZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhbmRsZVByb3BHZXR0ZXIoe30sIHVzZXJQcm9wcyhwcmV2UHJvcHMsIG1ldGEpKTtcbiAgICB9IC8vIEhhbmRsZSBhbiBhcnJheSwgbWVyZ2UgZWFjaCBpdGVtIGFzIHNlcGFyYXRlIHByb3BzXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHVzZXJQcm9wcykpIHtcbiAgICAgIHJldHVybiBtZXJnZVByb3BzLmFwcGx5KHZvaWQgMCwgW3ByZXZQcm9wc10uY29uY2F0KHVzZXJQcm9wcykpO1xuICAgIH0gLy8gSGFuZGxlIGFuIG9iamVjdCBieSBkZWZhdWx0LCBtZXJnZSB0aGUgdHdvIG9iamVjdHNcblxuXG4gICAgcmV0dXJuIG1lcmdlUHJvcHMocHJldlByb3BzLCB1c2VyUHJvcHMpO1xuICB9XG5cbiAgdmFyIG1ha2VQcm9wR2V0dGVyID0gZnVuY3Rpb24gbWFrZVByb3BHZXR0ZXIoaG9va3MsIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh1c2VyUHJvcHMpIHtcbiAgICAgIGlmICh1c2VyUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICB1c2VyUHJvcHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChob29rcywgW3VzZXJQcm9wc10pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlUHJvcEdldHRlcihwcmV2LCBuZXh0LCBfZXh0ZW5kcyh7fSwgbWV0YSwge1xuICAgICAgICAgIHVzZXJQcm9wczogdXNlclByb3BzXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIHt9KTtcbiAgICB9O1xuICB9O1xuICB2YXIgcmVkdWNlSG9va3MgPSBmdW5jdGlvbiByZWR1Y2VIb29rcyhob29rcywgaW5pdGlhbCwgbWV0YSwgYWxsb3dVbmRlZmluZWQpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvb2tzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHQocHJldiwgbWV0YSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2YgbmV4dFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhuZXh0KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IFRhYmxlOiBBIHJlZHVjZXIgaG9vayDimJ3vuI8ganVzdCByZXR1cm5lZCB1bmRlZmluZWQhIFRoaXMgaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9LCBpbml0aWFsKTtcbiAgfTtcbiAgdmFyIGxvb3BIb29rcyA9IGZ1bmN0aW9uIGxvb3BIb29rcyhob29rcywgY29udGV4dCwgbWV0YSkge1xuICAgIGlmIChtZXRhID09PSB2b2lkIDApIHtcbiAgICAgIG1ldGEgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IGhvb2soY29udGV4dCwgbWV0YSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGhvb2ssIG5leHRWYWx1ZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBUYWJsZTogQSBsb29wLXR5cGUgaG9vayDimJ3vuI8ganVzdCByZXR1cm5lZCBhIHZhbHVlISBUaGlzIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIGJlZm9yZXMsIHBsdWdpbk5hbWUsIGFmdGVycykge1xuICAgIGlmICggYWZ0ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZpbmluZyBwbHVnaW5zIGluIHRoZSBcXFwiYWZ0ZXJcXFwiIHNlY3Rpb24gb2YgZW5zdXJlUGx1Z2luT3JkZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAoc2VlIHBsdWdpbiBcIiArIHBsdWdpbk5hbWUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbkluZGV4ID0gcGx1Z2lucy5maW5kSW5kZXgoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgcmV0dXJuIHBsdWdpbi5wbHVnaW5OYW1lID09PSBwbHVnaW5OYW1lO1xuICAgIH0pO1xuXG4gICAgaWYgKHBsdWdpbkluZGV4ID09PSAtMSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGx1Z2luIFxcXCJcIiArIHBsdWdpbk5hbWUgKyBcIlxcXCIgd2FzIG5vdCBmb3VuZCBpbiB0aGUgcGx1Z2luIGxpc3QhXFxuVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBuZWVkIHRvIG5lZWQgdG8gbmFtZSB5b3VyIHBsdWdpbiBob29rIGJ5IHNldHRpbmcgdGhlICdwbHVnaW5OYW1lJyBwcm9wZXJ0eSBvZiB0aGUgaG9vayBmdW5jdGlvbiwgZWc6XFxuXFxuICBcIiArIHBsdWdpbk5hbWUgKyBcIi5wbHVnaW5OYW1lID0gJ1wiICsgcGx1Z2luTmFtZSArIFwiJ1xcblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVzLmZvckVhY2goZnVuY3Rpb24gKGJlZm9yZSkge1xuICAgICAgdmFyIGJlZm9yZUluZGV4ID0gcGx1Z2lucy5maW5kSW5kZXgoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLnBsdWdpbk5hbWUgPT09IGJlZm9yZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYmVmb3JlSW5kZXggPiAtMSAmJiBiZWZvcmVJbmRleCA+IHBsdWdpbkluZGV4KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBUYWJsZTogVGhlIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbiBob29rIG11c3QgYmUgcGxhY2VkIGFmdGVyIHRoZSBcIiArIGJlZm9yZSArIFwiIHBsdWdpbiBob29rIVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSAnZnVuY3Rpb24nID8gdXBkYXRlcihvbGQpIDogdXBkYXRlcjtcbiAgfVxuICBmdW5jdGlvbiB1c2VHZXRMYXRlc3Qob2JqKSB7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHJlZi5jdXJyZW50ID0gb2JqO1xuICAgIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xuICB9IC8vIFNTUiBoYXMgaXNzdWVzIHdpdGggdXNlTGF5b3V0RWZmZWN0IHN0aWxsLCBzbyB1c2UgdXNlRWZmZWN0IGR1cmluZyBTU1JcblxuICB2YXIgc2FmZVVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG4gIGZ1bmN0aW9uIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZm4sIGRlcHMpIHtcbiAgICB2YXIgbW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgc2FmZVVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG5cbiAgICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0sIGRlcHMpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUFzeW5jRGVib3VuY2UoZGVmYXVsdEZuLCBkZWZhdWx0V2FpdCkge1xuICAgIGlmIChkZWZhdWx0V2FpdCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0V2FpdCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRlYm91bmNlUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgICB2YXIgZ2V0RGVmYXVsdEZuID0gdXNlR2V0TGF0ZXN0KGRlZmF1bHRGbik7XG4gICAgdmFyIGdldERlZmF1bHRXYWl0ID0gdXNlR2V0TGF0ZXN0KGRlZmF1bHRXYWl0KTtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfbGVuMixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBfa2V5MixcbiAgICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZvciAoX2xlbjIgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IF9hcmdzMltfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkZWJvdW5jZVJlZi5jdXJyZW50LnByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgICBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gZGVib3VuY2VSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0Rm4oKS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MC5yZXNvbHZlLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVqZWN0KF9jb250ZXh0LnQyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDEyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgOSwgMTIsIDE1XV0pO1xuICAgICAgICAgICAgICAgIH0pKSwgZ2V0RGVmYXVsdFdhaXQoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKSwgW2dldERlZmF1bHRGbiwgZ2V0RGVmYXVsdFdhaXRdKTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlUmVuZGVyZXIoaW5zdGFuY2UsIGNvbHVtbiwgbWV0YSkge1xuICAgIGlmIChtZXRhID09PSB2b2lkIDApIHtcbiAgICAgIG1ldGEgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIHVzZXJQcm9wcykge1xuICAgICAgaWYgKHVzZXJQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHVzZXJQcm9wcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgQ29tcCA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IGNvbHVtblt0eXBlXSA6IHR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGNvbHVtbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZW5kZXJFcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxleFJlbmRlcihDb21wLCBfZXh0ZW5kcyh7fSwgaW5zdGFuY2UsIHtcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0sIG1ldGEsIHt9LCB1c2VyUHJvcHMpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZsZXhSZW5kZXIoQ29tcCwgcHJvcHMpIHtcbiAgICByZXR1cm4gaXNSZWFjdENvbXBvbmVudChDb21wKSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB8fCB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nIHx8IGlzRXhvdGljQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZSAmJiBwcm90by5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbiAgICB9KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbXBvbmVudC4kJHR5cGVvZiA9PT0gJ3N5bWJvbCcgJiYgWydyZWFjdC5tZW1vJywgJ3JlYWN0LmZvcndhcmRfcmVmJ10uaW5jbHVkZXMoY29tcG9uZW50LiQkdHlwZW9mLmRlc2NyaXB0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtDb2x1bW5TdHJ1Y3R1cmUoY29sdW1ucywgcGFyZW50LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIGNvbHVtbiA9IF9leHRlbmRzKHt9LCBjb2x1bW4sIHtcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGRlcHRoOiBkZXB0aFxuICAgICAgfSk7XG4gICAgICBhc3NpZ25Db2x1bW5BY2Nlc3Nvcihjb2x1bW4pO1xuXG4gICAgICBpZiAoY29sdW1uLmNvbHVtbnMpIHtcbiAgICAgICAgY29sdW1uLmNvbHVtbnMgPSBsaW5rQ29sdW1uU3RydWN0dXJlKGNvbHVtbi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkNvbHVtbnMoY29sdW1ucykge1xuICAgIHJldHVybiBmbGF0dGVuQnkoY29sdW1ucywgJ2NvbHVtbnMnKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ25Db2x1bW5BY2Nlc3Nvcihjb2x1bW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBmb3Igc3RyaW5nIGFjY2Vzc29yXG4gICAgdmFyIGlkID0gY29sdW1uLmlkLFxuICAgICAgICBhY2Nlc3NvciA9IGNvbHVtbi5hY2Nlc3NvcixcbiAgICAgICAgSGVhZGVyID0gY29sdW1uLkhlYWRlcjtcblxuICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZCA9IGlkIHx8IGFjY2Vzc29yO1xuICAgICAgdmFyIGFjY2Vzc29yUGF0aCA9IGFjY2Vzc29yLnNwbGl0KCcuJyk7XG5cbiAgICAgIGFjY2Vzc29yID0gZnVuY3Rpb24gYWNjZXNzb3Iocm93KSB7XG4gICAgICAgIHJldHVybiBnZXRCeShyb3csIGFjY2Vzc29yUGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaWQgJiYgdHlwZW9mIEhlYWRlciA9PT0gJ3N0cmluZycgJiYgSGVhZGVyKSB7XG4gICAgICBpZCA9IEhlYWRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlkICYmIGNvbHVtbi5jb2x1bW5zKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGNvbHVtbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY29sdW1uIElEIChvciB1bmlxdWUgXCJIZWFkZXJcIiB2YWx1ZSkgaXMgcmVxdWlyZWQhJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpZCkge1xuICAgICAgY29uc29sZS5lcnJvcihjb2x1bW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbHVtbiBJRCAob3Igc3RyaW5nIGFjY2Vzc29yKSBpcyByZXF1aXJlZCEnKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGNvbHVtbiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgYWNjZXNzb3I6IGFjY2Vzc29yXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvcmF0ZUNvbHVtbihjb2x1bW4sIHVzZXJEZWZhdWx0Q29sdW1uKSB7XG4gICAgaWYgKCF1c2VyRGVmYXVsdENvbHVtbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIF9leHRlbmRzKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIGZhbGxiYWNrIGhlYWRlciwganVzdCBpbiBjYXNlXG4gICAgICBIZWFkZXI6IGVtcHR5UmVuZGVyZXIsXG4gICAgICBGb290ZXI6IGVtcHR5UmVuZGVyZXJcbiAgICB9LCBkZWZhdWx0Q29sdW1uLCB7fSwgdXNlckRlZmF1bHRDb2x1bW4sIHt9LCBjb2x1bW4pKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbHVtbiwge1xuICAgICAgb3JpZ2luYWxXaWR0aDogY29sdW1uLndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbjtcbiAgfSAvLyBCdWlsZCB0aGUgaGVhZGVyIGdyb3VwcyBmcm9tIHRoZSBib3R0b20gdXBcblxuICBmdW5jdGlvbiBtYWtlSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGRlZmF1bHRDb2x1bW4sIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzID09PSB2b2lkIDApIHtcbiAgICAgIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlckdyb3VwcyA9IFtdO1xuICAgIHZhciBzY2FuQ29sdW1ucyA9IGFsbENvbHVtbnM7XG4gICAgdmFyIHVpZCA9IDA7XG5cbiAgICB2YXIgZ2V0VUlEID0gZnVuY3Rpb24gZ2V0VUlEKCkge1xuICAgICAgcmV0dXJuIHVpZCsrO1xuICAgIH07XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIFRoZSBoZWFkZXIgZ3JvdXAgd2UgYXJlIGNyZWF0aW5nXG4gICAgICB2YXIgaGVhZGVyR3JvdXAgPSB7XG4gICAgICAgIGhlYWRlcnM6IFtdXG4gICAgICB9OyAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG5cbiAgICAgIHZhciBwYXJlbnRDb2x1bW5zID0gW107XG4gICAgICB2YXIgaGFzUGFyZW50cyA9IHNjYW5Db2x1bW5zLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucGFyZW50O1xuICAgICAgfSk7IC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcblxuICAgICAgc2NhbkNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIC8vIFdoYXQgaXMgdGhlIGxhdGVzdCAobGFzdCkgcGFyZW50IGNvbHVtbj9cbiAgICAgICAgdmFyIGxhdGVzdFBhcmVudENvbHVtbiA9IFtdLmNvbmNhdChwYXJlbnRDb2x1bW5zKS5yZXZlcnNlKClbMF07XG4gICAgICAgIHZhciBuZXdQYXJlbnQ7XG5cbiAgICAgICAgaWYgKGhhc1BhcmVudHMpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGhhcyBhIHBhcmVudCwgYWRkIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmIChjb2x1bW4ucGFyZW50KSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBfZXh0ZW5kcyh7fSwgY29sdW1uLnBhcmVudCwge1xuICAgICAgICAgICAgICBvcmlnaW5hbElkOiBjb2x1bW4ucGFyZW50LmlkLFxuICAgICAgICAgICAgICBpZDogY29sdW1uLnBhcmVudC5pZCArIFwiX1wiICsgZ2V0VUlEKCksXG4gICAgICAgICAgICAgIGhlYWRlcnM6IFtjb2x1bW5dXG4gICAgICAgICAgICB9LCBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyhjb2x1bW4pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgb3RoZXIgY29sdW1ucyBoYXZlIHBhcmVudHMsIHdlJ2xsIG5lZWQgdG8gYWRkIGEgcGxhY2UgaG9sZGVyIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSWQgPSBjb2x1bW4uaWQgKyBcIl9wbGFjZWhvbGRlclwiO1xuICAgICAgICAgICAgbmV3UGFyZW50ID0gZGVjb3JhdGVDb2x1bW4oX2V4dGVuZHMoe1xuICAgICAgICAgICAgICBvcmlnaW5hbElkOiBvcmlnaW5hbElkLFxuICAgICAgICAgICAgICBpZDogY29sdW1uLmlkICsgXCJfcGxhY2Vob2xkZXJfXCIgKyBnZXRVSUQoKSxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXJPZjogY29sdW1uLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBbY29sdW1uXVxuICAgICAgICAgICAgfSwgYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoY29sdW1uKSksIGRlZmF1bHRDb2x1bW4pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHJlc3VsdGluZyBwYXJlbnQgY29sdW1ucyBhcmUgdGhlIHNhbWUsIGp1c3QgYWRkXG4gICAgICAgICAgLy8gdGhlIGNvbHVtbiBhbmQgaW5jcmVtZW50IHRoZSBoZWFkZXIgc3BhblxuXG5cbiAgICAgICAgICBpZiAobGF0ZXN0UGFyZW50Q29sdW1uICYmIGxhdGVzdFBhcmVudENvbHVtbi5vcmlnaW5hbElkID09PSBuZXdQYXJlbnQub3JpZ2luYWxJZCkge1xuICAgICAgICAgICAgbGF0ZXN0UGFyZW50Q29sdW1uLmhlYWRlcnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRDb2x1bW5zLnB1c2gobmV3UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goY29sdW1uKTtcbiAgICAgIH0pO1xuICAgICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApOyAvLyBTdGFydCBzY2FubmluZyB0aGUgcGFyZW50IGNvbHVtbnNcblxuICAgICAgc2NhbkNvbHVtbnMgPSBwYXJlbnRDb2x1bW5zO1xuICAgIH07XG5cbiAgICB3aGlsZSAoc2NhbkNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuICB9XG4gIHZhciBwYXRoT2JqQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldEJ5KG9iaiwgcGF0aCwgZGVmKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHZhciBjYWNoZUtleSA9IHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nID8gcGF0aCA6IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuXG4gICAgdmFyIHBhdGhPYmogPSBwYXRoT2JqQ2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aE9iaiA9IG1ha2VQYXRoQXJyYXkocGF0aCk7XG4gICAgICBwYXRoT2JqQ2FjaGUuc2V0KGNhY2hlS2V5LCBwYXRoT2JqKTtcbiAgICAgIHJldHVybiBwYXRoT2JqO1xuICAgIH0oKTtcblxuICAgIHZhciB2YWw7XG5cbiAgICB0cnkge1xuICAgICAgdmFsID0gcGF0aE9iai5yZWR1Y2UoZnVuY3Rpb24gKGN1cnNvciwgcGF0aFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcltwYXRoUGFydF07XG4gICAgICB9LCBvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnID8gdmFsIDogZGVmO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZpcnN0RGVmaW5lZCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmbGF0dGVuQnkoYXJyLCBrZXkpIHtcbiAgICB2YXIgZmxhdCA9IFtdO1xuXG4gICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiByZWN1cnNlKGFycikge1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKCFkW2tleV0pIHtcbiAgICAgICAgICBmbGF0LnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzZShkW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVjdXJzZShhcnIpO1xuICAgIHJldHVybiBmbGF0O1xuICB9XG4gIGZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93cywgX3JlZikge1xuICAgIHZhciBtYW51YWxFeHBhbmRlZEtleSA9IF9yZWYubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIGV4cGFuZGVkID0gX3JlZi5leHBhbmRlZCxcbiAgICAgICAgX3JlZiRleHBhbmRTdWJSb3dzID0gX3JlZi5leHBhbmRTdWJSb3dzLFxuICAgICAgICBleHBhbmRTdWJSb3dzID0gX3JlZiRleHBhbmRTdWJSb3dzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRleHBhbmRTdWJSb3dzO1xuICAgIHZhciBleHBhbmRlZFJvd3MgPSBbXTtcblxuICAgIHZhciBoYW5kbGVSb3cgPSBmdW5jdGlvbiBoYW5kbGVSb3cocm93LCBhZGRUb0V4cGFuZGVkUm93cykge1xuICAgICAgaWYgKGFkZFRvRXhwYW5kZWRSb3dzID09PSB2b2lkIDApIHtcbiAgICAgICAgYWRkVG9FeHBhbmRlZFJvd3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByb3cuaXNFeHBhbmRlZCA9IHJvdy5vcmlnaW5hbCAmJiByb3cub3JpZ2luYWxbbWFudWFsRXhwYW5kZWRLZXldIHx8IGV4cGFuZGVkW3Jvdy5pZF07XG4gICAgICByb3cuY2FuRXhwYW5kID0gcm93LnN1YlJvd3MgJiYgISFyb3cuc3ViUm93cy5sZW5ndGg7XG5cbiAgICAgIGlmIChhZGRUb0V4cGFuZGVkUm93cykge1xuICAgICAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAocm93LnN1YlJvd3MgJiYgcm93LnN1YlJvd3MubGVuZ3RoICYmIHJvdy5pc0V4cGFuZGVkKSB7XG4gICAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVSb3cocm93LCBleHBhbmRTdWJSb3dzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaGFuZGxlUm93KHJvdyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkUm93cztcbiAgfVxuICBmdW5jdGlvbiBnZXRGaWx0ZXJNZXRob2QoZmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMsIGZpbHRlclR5cGVzKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZmlsdGVyKSB8fCB1c2VyRmlsdGVyVHlwZXNbZmlsdGVyXSB8fCBmaWx0ZXJUeXBlc1tmaWx0ZXJdIHx8IGZpbHRlclR5cGVzLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihhdXRvUmVtb3ZlLCB2YWx1ZSwgY29sdW1uKSB7XG4gICAgcmV0dXJuIGF1dG9SZW1vdmUgPyBhdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgfVxuICBmdW5jdGlvbiB1bnByZXBhcmVkQWNjZXNzV2FybmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LVRhYmxlOiBZb3UgaGF2ZSBub3QgY2FsbGVkIHByZXBhcmVSb3cocm93KSBvbmUgb3IgbW9yZSByb3dzIHlvdSBhcmUgYXR0ZW1wdGluZyB0byByZW5kZXIuJyk7XG4gIH1cbiAgdmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuICBmdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gICAgLy8gbWVtb2l6ZSBzdXBwb3J0IHRvIGF2b2lkIGFkZGluZyBtdWx0aXBsZSB0ZXN0IGV2ZW50c1xuICAgIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIH0gLy9cblxuICB2YXIgcmVPcGVuQnJhY2tldCA9IC9cXFsvZztcbiAgdmFyIHJlQ2xvc2VCcmFja2V0ID0gL1xcXS9nO1xuXG4gIGZ1bmN0aW9uIG1ha2VQYXRoQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5EZWVwKG9iaikgLy8gcmVtb3ZlIGFsbCBwZXJpb2RzIGluIHBhcnRzXG4gICAgLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhkKS5yZXBsYWNlKCcuJywgJ18nKTtcbiAgICB9KSAvLyBqb2luIHBhcnRzIHVzaW5nIHBlcmlvZFxuICAgIC5qb2luKCcuJykgLy8gcmVwbGFjZSBicmFja2V0cyB3aXRoIHBlcmlvZHNcbiAgICAucmVwbGFjZShyZU9wZW5CcmFja2V0LCAnLicpLnJlcGxhY2UocmVDbG9zZUJyYWNrZXQsICcnKSAvLyBzcGxpdCBpdCBiYWNrIG91dCBvbiBwZXJpb2RzXG4gICAgLnNwbGl0KCcuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnIsIG5ld0Fycikge1xuICAgIGlmIChuZXdBcnIgPT09IHZvaWQgMCkge1xuICAgICAgbmV3QXJyID0gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIG5ld0Fyci5wdXNoKGFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGZsYXR0ZW5EZWVwKGFycltpXSwgbmV3QXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRHZXRUYWJsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRhYmxlUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcm9sZTogJ3RhYmxlJ1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRhYmxlQm9keVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRhYmxlQm9keVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHJvbGU6ICdyb3dncm91cCdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRIZWFkZXJQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImhlYWRlcl9cIiArIGNvbHVtbi5pZCxcbiAgICAgIGNvbFNwYW46IGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudCxcbiAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Rm9vdGVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Rm9vdGVyUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImZvb3Rlcl9cIiArIGNvbHVtbi5pZCxcbiAgICAgIGNvbFNwYW46IGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudFxuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVyR3JvdXBQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5kZXggPSBfcmVmMy5pbmRleDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImhlYWRlckdyb3VwX1wiICsgaW5kZXgsXG4gICAgICByb2xlOiAncm93J1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Rm9vdGVyR3JvdXBQcm9wcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgaW5kZXggPSBfcmVmNC5pbmRleDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImZvb3Rlckdyb3VwX1wiICsgaW5kZXhcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSb3dQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSb3dQcm9wcyhwcm9wcywgX3JlZjUpIHtcbiAgICB2YXIgcm93ID0gX3JlZjUucm93O1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IFwicm93X1wiICsgcm93LmlkLFxuICAgICAgcm9sZTogJ3JvdydcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRDZWxsUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Q2VsbFByb3BzKHByb3BzLCBfcmVmNikge1xuICAgIHZhciBjZWxsID0gX3JlZjYuY2VsbDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImNlbGxfXCIgKyBjZWxsLnJvdy5pZCArIFwiX1wiICsgY2VsbC5jb2x1bW4uaWQsXG4gICAgICByb2xlOiAnY2VsbCdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZURlZmF1bHRQbHVnaW5Ib29rcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlT3B0aW9uczogW10sXG4gICAgICBzdGF0ZVJlZHVjZXJzOiBbXSxcbiAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZTogW10sXG4gICAgICBjb2x1bW5zOiBbXSxcbiAgICAgIGNvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGFsbENvbHVtbnM6IFtdLFxuICAgICAgYWxsQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgYWNjZXNzVmFsdWU6IFtdLFxuICAgICAgbWF0ZXJpYWxpemVkQ29sdW1uczogW10sXG4gICAgICBtYXRlcmlhbGl6ZWRDb2x1bW5zRGVwczogW10sXG4gICAgICB1c2VJbnN0YW5jZUFmdGVyRGF0YTogW10sXG4gICAgICB2aXNpYmxlQ29sdW1uczogW10sXG4gICAgICB2aXNpYmxlQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgaGVhZGVyR3JvdXBzOiBbXSxcbiAgICAgIGhlYWRlckdyb3Vwc0RlcHM6IFtdLFxuICAgICAgdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zOiBbXSxcbiAgICAgIHVzZUluc3RhbmNlOiBbXSxcbiAgICAgIHByZXBhcmVSb3c6IFtdLFxuICAgICAgZ2V0VGFibGVQcm9wczogW2RlZmF1bHRHZXRUYWJsZVByb3BzXSxcbiAgICAgIGdldFRhYmxlQm9keVByb3BzOiBbZGVmYXVsdEdldFRhYmxlQm9keVByb3BzXSxcbiAgICAgIGdldEhlYWRlckdyb3VwUHJvcHM6IFtkZWZhdWx0R2V0SGVhZGVyR3JvdXBQcm9wc10sXG4gICAgICBnZXRGb290ZXJHcm91cFByb3BzOiBbZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHNdLFxuICAgICAgZ2V0SGVhZGVyUHJvcHM6IFtkZWZhdWx0R2V0SGVhZGVyUHJvcHNdLFxuICAgICAgZ2V0Rm9vdGVyUHJvcHM6IFtkZWZhdWx0R2V0Rm9vdGVyUHJvcHNdLFxuICAgICAgZ2V0Um93UHJvcHM6IFtkZWZhdWx0R2V0Um93UHJvcHNdLFxuICAgICAgZ2V0Q2VsbFByb3BzOiBbZGVmYXVsdEdldENlbGxQcm9wc10sXG4gICAgICB1c2VGaW5hbEluc3RhbmNlOiBbXVxuICAgIH07XG4gIH1cblxuICBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1ucyA9ICdyZXNldEhpZGRlbkNvbHVtbnMnO1xuICBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4gPSAndG9nZ2xlSGlkZUNvbHVtbic7XG4gIGFjdGlvbnMuc2V0SGlkZGVuQ29sdW1ucyA9ICdzZXRIaWRkZW5Db2x1bW5zJztcbiAgYWN0aW9ucy50b2dnbGVIaWRlQWxsQ29sdW1ucyA9ICd0b2dnbGVIaWRlQWxsQ29sdW1ucyc7XG4gIHZhciB1c2VDb2x1bW5WaXNpYmlsaXR5ID0gZnVuY3Rpb24gdXNlQ29sdW1uVmlzaWJpbGl0eShob29rcykge1xuICAgIGhvb2tzLmdldFRvZ2dsZUhpZGRlblByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucy5wdXNoKHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyk7XG4gICAgaG9va3MuaGVhZGVyR3JvdXBzRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1uc10pO1xuICAgIH0pO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UpO1xuICB9O1xuICB1c2VDb2x1bW5WaXNpYmlsaXR5LnBsdWdpbk5hbWUgPSAndXNlQ29sdW1uVmlzaWJpbGl0eSc7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjIuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVIaWRkZW4oIWUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogY29sdW1uLmlzVmlzaWJsZSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIENvbHVtbiBWaXNpYmxlJ1xuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUhpZGVBbGxDb2x1bW5zKCFlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6ICFpbnN0YW5jZS5hbGxDb2x1bW5zSGlkZGVuICYmICFpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEFsbCBDb2x1bW5zIEhpZGRlbicsXG4gICAgICBpbmRldGVybWluYXRlOiAhaW5zdGFuY2UuYWxsQ29sdW1uc0hpZGRlbiAmJiBpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aFxuICAgIH1dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRIaWRkZW5Db2x1bW5zKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5oaWRkZW5Db2x1bW5zIHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlSGlkZUNvbHVtbikge1xuICAgICAgdmFyIHNob3VsZCA9IHR5cGVvZiBhY3Rpb24udmFsdWUgIT09ICd1bmRlZmluZWQnID8gYWN0aW9uLnZhbHVlIDogIXN0YXRlLmhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoYWN0aW9uLmNvbHVtbklkKTtcbiAgICAgIHZhciBoaWRkZW5Db2x1bW5zID0gc2hvdWxkID8gW10uY29uY2F0KHN0YXRlLmhpZGRlbkNvbHVtbnMsIFthY3Rpb24uY29sdW1uSWRdKSA6IHN0YXRlLmhpZGRlbkNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkICE9PSBhY3Rpb24uY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogaGlkZGVuQ29sdW1uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEhpZGRlbkNvbHVtbnMpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogZnVuY3Rpb25hbFVwZGF0ZShhY3Rpb24udmFsdWUsIHN0YXRlLmhpZGRlbkNvbHVtbnMpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMpIHtcbiAgICAgIHZhciBzaG91bGRBbGwgPSB0eXBlb2YgYWN0aW9uLnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGFjdGlvbi52YWx1ZSA6ICFzdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aDtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogc2hvdWxkQWxsID8gaW5zdGFuY2UuYWxsQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSkgOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zKGluc3RhbmNlKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBpbnN0YW5jZS5oZWFkZXJzLFxuICAgICAgICBoaWRkZW5Db2x1bW5zID0gaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucztcbiAgICB2YXIgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIDtcblxuICAgIHZhciBoYW5kbGVDb2x1bW4gPSBmdW5jdGlvbiBoYW5kbGVDb2x1bW4oY29sdW1uLCBwYXJlbnRWaXNpYmxlKSB7XG4gICAgICBjb2x1bW4uaXNWaXNpYmxlID0gcGFyZW50VmlzaWJsZSAmJiAhaGlkZGVuQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgdmFyIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gMDtcblxuICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzICYmIGNvbHVtbi5oZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICBjb2x1bW4uaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJDb2x1bW4pIHtcbiAgICAgICAgICByZXR1cm4gdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgKz0gaGFuZGxlQ29sdW1uKHN1YkNvbHVtbiwgY29sdW1uLmlzVmlzaWJsZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSBjb2x1bW4uaXNWaXNpYmxlID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudCA9IHRvdGFsVmlzaWJsZUhlYWRlckNvdW50O1xuICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50O1xuICAgIH07XG5cbiAgICB2YXIgdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSAwO1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViSGVhZGVyKSB7XG4gICAgICByZXR1cm4gdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgKz0gaGFuZGxlQ29sdW1uKHN1YkhlYWRlciwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIHZhciBjb2x1bW5zID0gaW5zdGFuY2UuY29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIGhpZGRlbkNvbHVtbnMgPSBpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0SGkgPSBpbnN0YW5jZS5hdXRvUmVzZXRIaWRkZW5Db2x1bW5zLFxuICAgICAgICBhdXRvUmVzZXRIaWRkZW5Db2x1bW5zID0gX2luc3RhbmNlJGF1dG9SZXNldEhpID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEhpO1xuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZSk7XG4gICAgdmFyIGFsbENvbHVtbnNIaWRkZW4gPSBhbGxDb2x1bW5zLmxlbmd0aCA9PT0gaGlkZGVuQ29sdW1ucy5sZW5ndGg7XG4gICAgdmFyIHRvZ2dsZUhpZGVDb2x1bW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4sXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0SGlkZGVuQ29sdW1ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRIaWRkZW5Db2x1bW5zLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciB0b2dnbGVIaWRlQWxsQ29sdW1ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVIaWRlQWxsQ29sdW1ucyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcywge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KTtcbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIGNvbHVtbi50b2dnbGVIaWRkZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlSGlkZUNvbHVtbixcbiAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbHVtbi5nZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlSGlkZGVuUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRIaWRkZW5Db2x1bW5zKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRIaWRkZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRIaWRkZW5Db2x1bW5zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgY29sdW1uc10pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIGFsbENvbHVtbnNIaWRkZW46IGFsbENvbHVtbnNIaWRkZW4sXG4gICAgICB0b2dnbGVIaWRlQ29sdW1uOiB0b2dnbGVIaWRlQ29sdW1uLFxuICAgICAgc2V0SGlkZGVuQ29sdW1uczogc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgIHRvZ2dsZUhpZGVBbGxDb2x1bW5zOiB0b2dnbGVIaWRlQWxsQ29sdW1ucyxcbiAgICAgIGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHM6IGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0SW5pdGlhbFN0YXRlID0ge307XG4gIHZhciBkZWZhdWx0Q29sdW1uSW5zdGFuY2UgPSB7fTtcblxuICB2YXIgZGVmYXVsdFJlZHVjZXIgPSBmdW5jdGlvbiBkZWZhdWx0UmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBwcmV2U3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRTdWJSb3dzID0gZnVuY3Rpb24gZGVmYXVsdEdldFN1YlJvd3Mocm93LCBpbmRleCkge1xuICAgIHJldHVybiByb3cuc3ViUm93cyB8fCBbXTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFJvd0lkID0gZnVuY3Rpb24gZGVmYXVsdEdldFJvd0lkKHJvdywgaW5kZXgsIHBhcmVudCkge1xuICAgIHJldHVybiBcIlwiICsgKHBhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleCk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRVc2VDb250cm9sbGVkU3RhdGUgPSBmdW5jdGlvbiBkZWZhdWx0VXNlQ29udHJvbGxlZFN0YXRlKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseURlZmF1bHRzKHByb3BzKSB7XG4gICAgdmFyIF9wcm9wcyRpbml0aWFsU3RhdGUgPSBwcm9wcy5pbml0aWFsU3RhdGUsXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IF9wcm9wcyRpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsU3RhdGUgOiBfcHJvcHMkaW5pdGlhbFN0YXRlLFxuICAgICAgICBfcHJvcHMkZGVmYXVsdENvbHVtbiA9IHByb3BzLmRlZmF1bHRDb2x1bW4sXG4gICAgICAgIGRlZmF1bHRDb2x1bW4gPSBfcHJvcHMkZGVmYXVsdENvbHVtbiA9PT0gdm9pZCAwID8gZGVmYXVsdENvbHVtbkluc3RhbmNlIDogX3Byb3BzJGRlZmF1bHRDb2x1bW4sXG4gICAgICAgIF9wcm9wcyRnZXRTdWJSb3dzID0gcHJvcHMuZ2V0U3ViUm93cyxcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9wcm9wcyRnZXRTdWJSb3dzID09PSB2b2lkIDAgPyBkZWZhdWx0R2V0U3ViUm93cyA6IF9wcm9wcyRnZXRTdWJSb3dzLFxuICAgICAgICBfcHJvcHMkZ2V0Um93SWQgPSBwcm9wcy5nZXRSb3dJZCxcbiAgICAgICAgZ2V0Um93SWQgPSBfcHJvcHMkZ2V0Um93SWQgPT09IHZvaWQgMCA/IGRlZmF1bHRHZXRSb3dJZCA6IF9wcm9wcyRnZXRSb3dJZCxcbiAgICAgICAgX3Byb3BzJHN0YXRlUmVkdWNlciA9IHByb3BzLnN0YXRlUmVkdWNlcixcbiAgICAgICAgc3RhdGVSZWR1Y2VyID0gX3Byb3BzJHN0YXRlUmVkdWNlciA9PT0gdm9pZCAwID8gZGVmYXVsdFJlZHVjZXIgOiBfcHJvcHMkc3RhdGVSZWR1Y2VyLFxuICAgICAgICBfcHJvcHMkdXNlQ29udHJvbGxlZFMgPSBwcm9wcy51c2VDb250cm9sbGVkU3RhdGUsXG4gICAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZSA9IF9wcm9wcyR1c2VDb250cm9sbGVkUyA9PT0gdm9pZCAwID8gZGVmYXVsdFVzZUNvbnRyb2xsZWRTdGF0ZSA6IF9wcm9wcyR1c2VDb250cm9sbGVkUyxcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbml0aWFsU3RhdGVcIiwgXCJkZWZhdWx0Q29sdW1uXCIsIFwiZ2V0U3ViUm93c1wiLCBcImdldFJvd0lkXCIsIFwic3RhdGVSZWR1Y2VyXCIsIFwidXNlQ29udHJvbGxlZFN0YXRlXCJdKTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICBkZWZhdWx0Q29sdW1uOiBkZWZhdWx0Q29sdW1uLFxuICAgICAgZ2V0U3ViUm93czogZ2V0U3ViUm93cyxcbiAgICAgIGdldFJvd0lkOiBnZXRSb3dJZCxcbiAgICAgIHN0YXRlUmVkdWNlcjogc3RhdGVSZWR1Y2VyLFxuICAgICAgdXNlQ29udHJvbGxlZFN0YXRlOiB1c2VDb250cm9sbGVkU3RhdGVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB1c2VUYWJsZSA9IGZ1bmN0aW9uIHVzZVRhYmxlKHByb3BzKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gYXBwbHlEZWZhdWx0cyhwcm9wcyk7IC8vIEFkZCBjb3JlIHBsdWdpbnNcblxuICAgIHBsdWdpbnMgPSBbdXNlQ29sdW1uVmlzaWJpbGl0eV0uY29uY2F0KHBsdWdpbnMpOyAvLyBDcmVhdGUgdGhlIHRhYmxlIGluc3RhbmNlXG5cbiAgICB2YXIgaW5zdGFuY2VSZWYgPSBSZWFjdC51c2VSZWYoe30pOyAvLyBDcmVhdGUgYSBnZXR0ZXIgZm9yIHRoZSBpbnN0YW5jZSAoaGVscHMgYXZvaWQgYSBsb3Qgb2YgcG90ZW50aWFsIG1lbW9yeSBsZWFrcylcblxuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZVJlZi5jdXJyZW50KTsgLy8gQXNzaWduIHRoZSBwcm9wcywgcGx1Z2lucyBhbmQgaG9va3MgdG8gdGhlIGluc3RhbmNlXG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAgIGhvb2tzOiBtYWtlRGVmYXVsdFBsdWdpbkhvb2tzKClcbiAgICB9KSk7IC8vIEFsbG93IHBsdWdpbnMgdG8gcmVnaXN0ZXIgaG9va3MgYXMgZWFybHkgYXMgcG9zc2libGVcblxuICAgIHBsdWdpbnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgcGx1Z2luKGdldEluc3RhbmNlKCkuaG9va3MpO1xuICAgIH0pOyAvLyBDb25zdW1lIGFsbCBob29rcyBhbmQgbWFrZSBhIGdldHRlciBmb3IgdGhlbVxuXG4gICAgdmFyIGdldEhvb2tzID0gdXNlR2V0TGF0ZXN0KGdldEluc3RhbmNlKCkuaG9va3MpO1xuICAgIGdldEluc3RhbmNlKCkuZ2V0SG9va3MgPSBnZXRIb29rcztcbiAgICBkZWxldGUgZ2V0SW5zdGFuY2UoKS5ob29rczsgLy8gQWxsb3cgdXNlT3B0aW9ucyBob29rcyB0byBtb2RpZnkgdGhlIG9wdGlvbnMgY29taW5nIGludG8gdGhlIHRhYmxlXG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudXNlT3B0aW9ucywgYXBwbHlEZWZhdWx0cyhwcm9wcykpKTtcblxuICAgIHZhciBfZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBkYXRhID0gX2dldEluc3RhbmNlLmRhdGEsXG4gICAgICAgIHVzZXJDb2x1bW5zID0gX2dldEluc3RhbmNlLmNvbHVtbnMsXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IF9nZXRJbnN0YW5jZS5pbml0aWFsU3RhdGUsXG4gICAgICAgIGRlZmF1bHRDb2x1bW4gPSBfZ2V0SW5zdGFuY2UuZGVmYXVsdENvbHVtbixcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9nZXRJbnN0YW5jZS5nZXRTdWJSb3dzLFxuICAgICAgICBnZXRSb3dJZCA9IF9nZXRJbnN0YW5jZS5nZXRSb3dJZCxcbiAgICAgICAgc3RhdGVSZWR1Y2VyID0gX2dldEluc3RhbmNlLnN0YXRlUmVkdWNlcixcbiAgICAgICAgdXNlQ29udHJvbGxlZFN0YXRlID0gX2dldEluc3RhbmNlLnVzZUNvbnRyb2xsZWRTdGF0ZTsgLy8gU2V0dXAgdXNlciByZWR1Y2VyIHJlZlxuXG5cbiAgICB2YXIgZ2V0U3RhdGVSZWR1Y2VyID0gdXNlR2V0TGF0ZXN0KHN0YXRlUmVkdWNlcik7IC8vIEJ1aWxkIHRoZSByZWR1Y2VyXG5cbiAgICB2YXIgcmVkdWNlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAvLyBEZXRlY3QgaW52YWxpZCBhY3Rpb25zXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBBY3Rpb24g8J+RhicpO1xuICAgICAgfSAvLyBSZWR1Y2UgdGhlIHN0YXRlIGZyb20gYWxsIHBsdWdpbiByZWR1Y2Vyc1xuXG5cbiAgICAgIHJldHVybiBbXS5jb25jYXQoZ2V0SG9va3MoKS5zdGF0ZVJlZHVjZXJzLCBBcnJheS5pc0FycmF5KGdldFN0YXRlUmVkdWNlcigpKSA/IGdldFN0YXRlUmVkdWNlcigpIDogW2dldFN0YXRlUmVkdWNlcigpXSkucmVkdWNlKGZ1bmN0aW9uIChzLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKHMsIGFjdGlvbiwgc3RhdGUsIGdldEluc3RhbmNlKCkpIHx8IHM7XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfSwgW2dldEhvb2tzLCBnZXRTdGF0ZVJlZHVjZXIsIGdldEluc3RhbmNlXSk7IC8vIFN0YXJ0IHRoZSByZWR1Y2VyXG5cbiAgICB2YXIgX1JlYWN0JHVzZVJlZHVjZXIgPSBSZWFjdC51c2VSZWR1Y2VyKHJlZHVjZXIsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZHVjZXIoaW5pdGlhbFN0YXRlLCB7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuaW5pdFxuICAgICAgfSk7XG4gICAgfSksXG4gICAgICAgIHJlZHVjZXJTdGF0ZSA9IF9SZWFjdCR1c2VSZWR1Y2VyWzBdLFxuICAgICAgICBkaXNwYXRjaCA9IF9SZWFjdCR1c2VSZWR1Y2VyWzFdOyAvLyBBbGxvdyB0aGUgdXNlciB0byBjb250cm9sIHRoZSBmaW5hbCBzdGF0ZSB3aXRoIGhvb2tzXG5cblxuICAgIHZhciBzdGF0ZSA9IHJlZHVjZUhvb2tzKFtdLmNvbmNhdChnZXRIb29rcygpLnVzZUNvbnRyb2xsZWRTdGF0ZSwgW3VzZUNvbnRyb2xsZWRTdGF0ZV0pLCByZWR1Y2VyU3RhdGUsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICB9KTsgLy8gRGVjb3JhdGUgQWxsIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxpbmtDb2x1bW5TdHJ1Y3R1cmUocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5jb2x1bW5zLCB1c2VyQ29sdW1ucywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSkpO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0SW5zdGFuY2UsIHVzZXJDb2x1bW5zXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5jb2x1bW5zRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmNvbHVtbnMgPSBjb2x1bW5zOyAvLyBHZXQgdGhlIGZsYXQgbGlzdCBvZiBhbGwgY29sdW1ucyBhbmQgYWxsb3cgaG9va3MgdG8gZGVjb3JhdGVcbiAgICAvLyB0aG9zZSBjb2x1bW5zIChhbmQgdHJpZ2dlciB0aGlzIG1lbW9pemF0aW9uIHZpYSBkZXBzKVxuXG4gICAgdmFyIGFsbENvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLmFsbENvbHVtbnMsIGZsYXR0ZW5Db2x1bW5zKGNvbHVtbnMpLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9KS5tYXAoYXNzaWduQ29sdW1uQWNjZXNzb3IpO1xuICAgIH0sIFtjb2x1bW5zLCBnZXRIb29rcywgZ2V0SW5zdGFuY2VdLmNvbmNhdChyZWR1Y2VIb29rcyhnZXRIb29rcygpLmFsbENvbHVtbnNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpO1xuICAgIGdldEluc3RhbmNlKCkuYWxsQ29sdW1ucyA9IGFsbENvbHVtbnM7IC8vIEFjY2VzcyB0aGUgcm93IG1vZGVsIHVzaW5nIGluaXRpYWwgY29sdW1uc1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgdmFyIGZsYXRSb3dzID0gW107XG4gICAgICB2YXIgcm93c0J5SWQgPSB7fTtcbiAgICAgIHZhciBhbGxDb2x1bW5zUXVldWUgPSBbXS5jb25jYXQoYWxsQ29sdW1ucyk7XG5cbiAgICAgIHdoaWxlIChhbGxDb2x1bW5zUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zUXVldWUuc2hpZnQoKTtcbiAgICAgICAgYWNjZXNzUm93c0ZvckNvbHVtbih7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICAgIGZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgICAgICByb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgZ2V0Um93SWQ6IGdldFJvd0lkLFxuICAgICAgICAgIGdldFN1YlJvd3M6IGdldFN1YlJvd3MsXG4gICAgICAgICAgYWNjZXNzVmFsdWVIb29rczogZ2V0SG9va3MoKS5hY2Nlc3NWYWx1ZSxcbiAgICAgICAgICBnZXRJbnN0YW5jZTogZ2V0SW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICB9LCBbYWxsQ29sdW1ucywgZGF0YSwgZ2V0Um93SWQsIGdldFN1YlJvd3MsIGdldEhvb2tzLCBnZXRJbnN0YW5jZV0pLFxuICAgICAgICByb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIHJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bMl07XG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIHtcbiAgICAgIHJvd3M6IHJvd3MsXG4gICAgICBpbml0aWFsUm93czogW10uY29uY2F0KHJvd3MpLFxuICAgICAgZmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IHJvd3NCeUlkIC8vIG1hdGVyaWFsaXplZENvbHVtbnMsXG5cbiAgICB9KTtcbiAgICBsb29wSG9va3MoZ2V0SG9va3MoKS51c2VJbnN0YW5jZUFmdGVyRGF0YSwgZ2V0SW5zdGFuY2UoKSk7IC8vIEdldCB0aGUgZmxhdCBsaXN0IG9mIGFsbCBjb2x1bW5zIEFGVEVSIHRoZSByb3dzXG4gICAgLy8gaGF2ZSBiZWVuIGFjY2VzcywgYW5kIGFsbG93IGhvb2tzIHRvIGRlY29yYXRlXG4gICAgLy8gdGhvc2UgY29sdW1ucyAoYW5kIHRyaWdnZXIgdGhpcyBtZW1vaXphdGlvbiB2aWEgZGVwcylcblxuICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudmlzaWJsZUNvbHVtbnMsIGFsbENvbHVtbnMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGVDb2x1bW4oZCwgZGVmYXVsdENvbHVtbik7XG4gICAgICB9KTtcbiAgICB9LCBbZ2V0SG9va3MsIGFsbENvbHVtbnMsIGdldEluc3RhbmNlLCBkZWZhdWx0Q29sdW1uXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS52aXNpYmxlQ29sdW1uc0RlcHMsIFtdLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pKSk7IC8vIENvbWJpbmUgbmV3IHZpc2libGUgY29sdW1ucyB3aXRoIGFsbCBjb2x1bW5zXG5cbiAgICBhbGxDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sdW1ucyA9IFtdLmNvbmNhdCh2aXNpYmxlQ29sdW1ucyk7XG4gICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBpZiAoIWNvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW4uaWQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfSwgW2FsbENvbHVtbnMsIHZpc2libGVDb2x1bW5zXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5hbGxDb2x1bW5zID0gYWxsQ29sdW1ucztcblxuICAgIHtcbiAgICAgIHZhciBkdXBsaWNhdGVDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbiwgaSkge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KSAhPT0gaTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZHVwbGljYXRlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGFsbENvbHVtbnMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgY29sdW1ucyB3ZXJlIGZvdW5kIHdpdGggaWRzOiBcXFwiXCIgKyBkdXBsaWNhdGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkO1xuICAgICAgICB9KS5qb2luKCcsICcpICsgXCJcXFwiIGluIHRoZSBjb2x1bW5zIGFycmF5IGFib3ZlXCIpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSB0aGUgaGVhZGVyR3JvdXBzXG5cblxuICAgIHZhciBoZWFkZXJHcm91cHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLmhlYWRlckdyb3VwcywgbWFrZUhlYWRlckdyb3Vwcyh2aXNpYmxlQ29sdW1ucywgZGVmYXVsdENvbHVtbiksIGdldEluc3RhbmNlKCkpO1xuICAgIH0sIFtnZXRIb29rcywgdmlzaWJsZUNvbHVtbnMsIGRlZmF1bHRDb2x1bW4sIGdldEluc3RhbmNlXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5oZWFkZXJHcm91cHNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzOyAvLyBHZXQgdGhlIGZpcnN0IGxldmVsIG9mIGhlYWRlcnNcblxuICAgIHZhciBoZWFkZXJzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLmxlbmd0aCA/IGhlYWRlckdyb3Vwc1swXS5oZWFkZXJzIDogW107XG4gICAgfSwgW2hlYWRlckdyb3Vwc10pO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVycyA9IGhlYWRlcnM7IC8vIFByb3ZpZGUgYSBmbGF0IGhlYWRlciBsaXN0IGZvciB1dGlsaXRpZXNcblxuICAgIGdldEluc3RhbmNlKCkuZmxhdEhlYWRlcnMgPSBoZWFkZXJHcm91cHMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIGhlYWRlckdyb3VwKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGFsbCwgaGVhZGVyR3JvdXAuaGVhZGVycyk7XG4gICAgfSwgW10pO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucywgZ2V0SW5zdGFuY2UoKSk7IC8vIEZpbHRlciBjb2x1bW5zIGRvd24gdG8gdmlzaWJsZSBvbmVzXG5cbiAgICB2YXIgdmlzaWJsZUNvbHVtbnNEZXAgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmlzVmlzaWJsZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmlkO1xuICAgIH0pLnNvcnQoKS5qb2luKCdfJyk7XG4gICAgdmlzaWJsZUNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaXNWaXNpYmxlO1xuICAgICAgfSk7XG4gICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFt2aXNpYmxlQ29sdW1ucywgdmlzaWJsZUNvbHVtbnNEZXBdKTtcbiAgICBnZXRJbnN0YW5jZSgpLnZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnM7IC8vIEhlYWRlciBWaXNpYmlsaXR5IGlzIG5lZWRlZCBieSB0aGlzIHBvaW50XG5cbiAgICB2YXIgX2NhbGN1bGF0ZUhlYWRlcldpZHRoID0gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKGhlYWRlcnMpLFxuICAgICAgICB0b3RhbENvbHVtbnNNaW5XaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aFswXSxcbiAgICAgICAgdG90YWxDb2x1bW5zV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGhbMV0sXG4gICAgICAgIHRvdGFsQ29sdW1uc01heFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoWzJdO1xuXG4gICAgZ2V0SW5zdGFuY2UoKS50b3RhbENvbHVtbnNNaW5XaWR0aCA9IHRvdGFsQ29sdW1uc01pbldpZHRoO1xuICAgIGdldEluc3RhbmNlKCkudG90YWxDb2x1bW5zV2lkdGggPSB0b3RhbENvbHVtbnNXaWR0aDtcbiAgICBnZXRJbnN0YW5jZSgpLnRvdGFsQ29sdW1uc01heFdpZHRoID0gdG90YWxDb2x1bW5zTWF4V2lkdGg7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlSW5zdGFuY2UsIGdldEluc3RhbmNlKCkpIC8vIEVhY2ggbWF0ZXJpYWxpemVkIGhlYWRlciBuZWVkcyB0byBiZSBhc3NpZ25lZCBhIHJlbmRlciBmdW5jdGlvbiBhbmQgb3RoZXJcbiAgICAvLyBwcm9wIGdldHRlciBwcm9wZXJ0aWVzIGhlcmUuXG4gICAgO1xuICAgIFtdLmNvbmNhdChnZXRJbnN0YW5jZSgpLmZsYXRIZWFkZXJzLCBnZXRJbnN0YW5jZSgpLmFsbENvbHVtbnMpLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgLy8gR2l2ZSBjb2x1bW5zL2hlYWRlcnMgcmVuZGVyaW5nIHBvd2VyXG4gICAgICBjb2x1bW4ucmVuZGVyID0gbWFrZVJlbmRlcmVyKGdldEluc3RhbmNlKCksIGNvbHVtbik7IC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIGEgZGVmYXVsdCBnZXRIZWFkZXJQcm9wc1xuXG4gICAgICBjb2x1bW4uZ2V0SGVhZGVyUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEhlYWRlclByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7IC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIGEgZGVmYXVsdCBnZXRGb290ZXJQcm9wc1xuXG4gICAgICBjb2x1bW4uZ2V0Rm9vdGVyUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEZvb3RlclByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5oZWFkZXJHcm91cHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoZWFkZXJHcm91cHMuZmlsdGVyKGZ1bmN0aW9uIChoZWFkZXJHcm91cCwgaSkge1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBoZWFkZXJzIGFuZCBoZWFkZXJHcm91cHMgdGhhdCBkb24ndCBoYXZlIHZpc2libGUgY29sdW1uc1xuICAgICAgICBoZWFkZXJHcm91cC5oZWFkZXJzID0gaGVhZGVyR3JvdXAuaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gcmVjdXJzZShoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICBpZiAoY29sdW1uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzZShjb2x1bW4uaGVhZGVycyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmlzVmlzaWJsZTtcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzZShjb2x1bW4uaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbHVtbi5pc1Zpc2libGU7XG4gICAgICAgIH0pOyAvLyBHaXZlIGhlYWRlckdyb3VwcyBnZXRSb3dQcm9wc1xuXG4gICAgICAgIGlmIChoZWFkZXJHcm91cC5oZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlckdyb3VwLmdldEhlYWRlckdyb3VwUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEhlYWRlckdyb3VwUHJvcHMsIHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICAgICAgaGVhZGVyR3JvdXA6IGhlYWRlckdyb3VwLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoZWFkZXJHcm91cC5nZXRGb290ZXJHcm91cFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRGb290ZXJHcm91cFByb3BzLCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIGhlYWRlckdyb3VwOiBoZWFkZXJHcm91cCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LCBbaGVhZGVyR3JvdXBzLCBnZXRJbnN0YW5jZSwgZ2V0SG9va3NdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmZvb3Rlckdyb3VwcyA9IFtdLmNvbmNhdChnZXRJbnN0YW5jZSgpLmhlYWRlckdyb3VwcykucmV2ZXJzZSgpOyAvLyBUaGUgcHJlcGFyZVJvdyBmdW5jdGlvbiBpcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBhbmQgTVVTVCBiZSBjYWxsZWQgb25cbiAgICAvLyBhbnkgcm93cyB0aGUgdXNlciB3aXNoZXMgdG8gYmUgZGlzcGxheWVkLlxuXG4gICAgZ2V0SW5zdGFuY2UoKS5wcmVwYXJlUm93ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvdykge1xuICAgICAgcm93LmdldFJvd1Byb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRSb3dQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgcm93OiByb3dcbiAgICAgIH0pOyAvLyBCdWlsZCB0aGUgdmlzaWJsZSBjZWxscyBmb3IgZWFjaCByb3dcblxuICAgICAgcm93LmFsbENlbGxzID0gYWxsQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgdmFsdWUgPSByb3cudmFsdWVzW2NvbHVtbi5pZF07XG4gICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9OyAvLyBHaXZlIGVhY2ggY2VsbCBhIGdldENlbGxQcm9wcyBiYXNlXG5cbiAgICAgICAgY2VsbC5nZXRDZWxsUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldENlbGxQcm9wcywge1xuICAgICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICAgIGNlbGw6IGNlbGxcbiAgICAgICAgfSk7IC8vIEdpdmUgZWFjaCBjZWxsIGEgcmVuZGVyZXIgZnVuY3Rpb24gKHN1cHBvcnRzIG11bHRpcGxlIHJlbmRlcmVycylcblxuICAgICAgICBjZWxsLnJlbmRlciA9IG1ha2VSZW5kZXJlcihnZXRJbnN0YW5jZSgpLCBjb2x1bW4sIHtcbiAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICBjZWxsOiBjZWxsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9KTtcbiAgICAgIHJvdy5jZWxscyA9IHZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiByb3cuYWxsQ2VsbHMuZmluZChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgIHJldHVybiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBuZWVkIHRvIGFwcGx5IGFueSByb3cgc3BlY2lmaWMgaG9va3MgKHVzZUV4cGFuZGVkIHJlcXVpcmVzIHRoaXMpXG5cbiAgICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnByZXBhcmVSb3csIHJvdywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSk7XG4gICAgfSwgW2dldEhvb2tzLCBnZXRJbnN0YW5jZSwgYWxsQ29sdW1ucywgdmlzaWJsZUNvbHVtbnNdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmdldFRhYmxlUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRhYmxlUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5nZXRUYWJsZUJvZHlQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VGFibGVCb2R5UHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlRmluYWxJbnN0YW5jZSwgZ2V0SW5zdGFuY2UoKSk7XG4gICAgcmV0dXJuIGdldEluc3RhbmNlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKGhlYWRlcnMsIGxlZnQpIHtcbiAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc3VtVG90YWxNaW5XaWR0aCA9IDA7XG4gICAgdmFyIHN1bVRvdGFsV2lkdGggPSAwO1xuICAgIHZhciBzdW1Ub3RhbE1heFdpZHRoID0gMDtcbiAgICB2YXIgc3VtVG90YWxGbGV4V2lkdGggPSAwO1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICB2YXIgc3ViSGVhZGVycyA9IGhlYWRlci5oZWFkZXJzO1xuICAgICAgaGVhZGVyLnRvdGFsTGVmdCA9IGxlZnQ7XG5cbiAgICAgIGlmIChzdWJIZWFkZXJzICYmIHN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyID0gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKHN1YkhlYWRlcnMsIGxlZnQpLFxuICAgICAgICAgICAgdG90YWxNaW5XaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aDJbMF0sXG4gICAgICAgICAgICB0b3RhbFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlsxXSxcbiAgICAgICAgICAgIHRvdGFsTWF4V2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzJdLFxuICAgICAgICAgICAgdG90YWxGbGV4V2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzNdO1xuXG4gICAgICAgIGhlYWRlci50b3RhbE1pbldpZHRoID0gdG90YWxNaW5XaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsV2lkdGggPSB0b3RhbFdpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxNYXhXaWR0aCA9IHRvdGFsTWF4V2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbEZsZXhXaWR0aCA9IHRvdGFsRmxleFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWluV2lkdGggPSBoZWFkZXIubWluV2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbFdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoaGVhZGVyLm1pbldpZHRoLCBoZWFkZXIud2lkdGgpLCBoZWFkZXIubWF4V2lkdGgpO1xuICAgICAgICBoZWFkZXIudG90YWxNYXhXaWR0aCA9IGhlYWRlci5tYXhXaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsRmxleFdpZHRoID0gaGVhZGVyLmNhblJlc2l6ZSA/IGhlYWRlci50b3RhbFdpZHRoIDogMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRlci5pc1Zpc2libGUpIHtcbiAgICAgICAgbGVmdCArPSBoZWFkZXIudG90YWxXaWR0aDtcbiAgICAgICAgc3VtVG90YWxNaW5XaWR0aCArPSBoZWFkZXIudG90YWxNaW5XaWR0aDtcbiAgICAgICAgc3VtVG90YWxXaWR0aCArPSBoZWFkZXIudG90YWxXaWR0aDtcbiAgICAgICAgc3VtVG90YWxNYXhXaWR0aCArPSBoZWFkZXIudG90YWxNYXhXaWR0aDtcbiAgICAgICAgc3VtVG90YWxGbGV4V2lkdGggKz0gaGVhZGVyLnRvdGFsRmxleFdpZHRoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbc3VtVG90YWxNaW5XaWR0aCwgc3VtVG90YWxXaWR0aCwgc3VtVG90YWxNYXhXaWR0aCwgc3VtVG90YWxGbGV4V2lkdGhdO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjZXNzUm93c0ZvckNvbHVtbihfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHJvd3MgPSBfcmVmLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gX3JlZi5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBfcmVmLnJvd3NCeUlkLFxuICAgICAgICBjb2x1bW4gPSBfcmVmLmNvbHVtbixcbiAgICAgICAgZ2V0Um93SWQgPSBfcmVmLmdldFJvd0lkLFxuICAgICAgICBnZXRTdWJSb3dzID0gX3JlZi5nZXRTdWJSb3dzLFxuICAgICAgICBhY2Nlc3NWYWx1ZUhvb2tzID0gX3JlZi5hY2Nlc3NWYWx1ZUhvb2tzLFxuICAgICAgICBnZXRJbnN0YW5jZSA9IF9yZWYuZ2V0SW5zdGFuY2U7XG5cbiAgICAvLyBBY2Nlc3MgdGhlIHJvdydzIGRhdGEgY29sdW1uLWJ5LWNvbHVtblxuICAgIC8vIFdlIGRvIGl0IHRoaXMgd2F5IHNvIHdlIGNhbiBpbmNyZW1lbnRhbGx5IGFkZCBtYXRlcmlhbGl6ZWRcbiAgICAvLyBjb2x1bW5zIGFmdGVyIHRoZSBmaXJzdCBwYXNzIGFuZCBhdm9pZCBleGNlc3NpdmUgbG9vcGluZ1xuICAgIHZhciBhY2Nlc3NSb3cgPSBmdW5jdGlvbiBhY2Nlc3NSb3cob3JpZ2luYWxSb3csIHJvd0luZGV4LCBkZXB0aCwgcGFyZW50LCBwYXJlbnRSb3dzKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZSBhcm91bmRcbiAgICAgIHZhciBvcmlnaW5hbCA9IG9yaWdpbmFsUm93O1xuICAgICAgdmFyIGlkID0gZ2V0Um93SWQob3JpZ2luYWxSb3csIHJvd0luZGV4LCBwYXJlbnQpO1xuICAgICAgdmFyIHJvdyA9IHJvd3NCeUlkW2lkXTsgLy8gSWYgdGhlIHJvdyBoYXNuJ3QgYmVlbiBjcmVhdGVkLCBsZXQncyBtYWtlIGl0XG5cbiAgICAgIGlmICghcm93KSB7XG4gICAgICAgIHJvdyA9IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxuICAgICAgICAgIGluZGV4OiByb3dJbmRleCxcbiAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgY2VsbHM6IFt7fV0gLy8gVGhpcyBpcyBhIGR1bW15IGNlbGxcblxuICAgICAgICB9OyAvLyBPdmVycmlkZSBjb21tb24gYXJyYXkgZnVuY3Rpb25zIChhbmQgdGhlIGR1bW15IGNlbGwncyBnZXRDZWxsUHJvcHMgZnVuY3Rpb24pXG4gICAgICAgIC8vIHRvIHNob3cgYW4gZXJyb3IgaWYgaXQgaXMgYWNjZXNzZWQgd2l0aG91dCBjYWxsaW5nIHByZXBhcmVSb3dcblxuICAgICAgICByb3cuY2VsbHMubWFwID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxscy5maWx0ZXIgPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZztcbiAgICAgICAgcm93LmNlbGxzLmZvckVhY2ggPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZztcbiAgICAgICAgcm93LmNlbGxzWzBdLmdldENlbGxQcm9wcyA9IHVucHJlcGFyZWRBY2Nlc3NXYXJuaW5nOyAvLyBDcmVhdGUgdGhlIGNlbGxzIGFuZCB2YWx1ZXNcblxuICAgICAgICByb3cudmFsdWVzID0ge307IC8vIFB1c2ggdGhpcyByb3cgaW50byB0aGUgcGFyZW50Um93cyBhcnJheVxuXG4gICAgICAgIHBhcmVudFJvd3MucHVzaChyb3cpOyAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcblxuICAgICAgICBmbGF0Um93cy5wdXNoKHJvdyk7IC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXG5cbiAgICAgICAgcm93c0J5SWRbaWRdID0gcm93OyAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcblxuICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gZ2V0U3ViUm93cyhvcmlnaW5hbFJvdywgcm93SW5kZXgpOyAvLyBUaGVuIHJlY3Vyc2l2ZWx5IGFjY2VzcyB0aGVtXG5cbiAgICAgICAgaWYgKHJvdy5vcmlnaW5hbFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgc3ViUm93cyA9IFtdO1xuICAgICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1JvdyhkLCBpLCBkZXB0aCArIDEsIHJvdywgc3ViUm93cyk7XG4gICAgICAgICAgfSk7IC8vIEtlZXAgdGhlIG5ldyBzdWJSb3dzIGFycmF5IG9uIHRoZSByb3dcblxuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc3ViUm93cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAvLyBJZiB0aGUgcm93IGV4aXN0cywgdGhlbiBpdCdzIGFscmVhZHkgYmVlbiBhY2Nlc3NlZFxuICAgICAgICAvLyBLZWVwIHJlY3Vyc2luZywgYnV0IGRvbid0IHdvcnJ5IGFib3V0IHBhc3NpbmcgdGhlXG4gICAgICAgIC8vIGFjY3VtbGF0b3IgYXJyYXkgKHRob3NlIHJvd3MgYWxyZWFkeSBleGlzdClcbiAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY2Vzc1JvdyhkLCBpLCBkZXB0aCArIDEsIHJvdyk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGUgY29sdW1uIGhhcyBhbiBhY2Nlc3NvciwgdXNlIGl0IHRvIGdldCBhIHZhbHVlXG5cblxuICAgICAgaWYgKGNvbHVtbi5hY2Nlc3Nvcikge1xuICAgICAgICByb3cudmFsdWVzW2NvbHVtbi5pZF0gPSBjb2x1bW4uYWNjZXNzb3Iob3JpZ2luYWxSb3csIHJvd0luZGV4LCByb3csIHBhcmVudFJvd3MsIGRhdGEpO1xuICAgICAgfSAvLyBBbGxvdyBwbHVnaW5zIHRvIG1hbmlwdWxhdGUgdGhlIGNvbHVtbiB2YWx1ZVxuXG5cbiAgICAgIHJvdy52YWx1ZXNbY29sdW1uLmlkXSA9IHJlZHVjZUhvb2tzKGFjY2Vzc1ZhbHVlSG9va3MsIHJvdy52YWx1ZXNbY29sdW1uLmlkXSwge1xuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbFJvdywgcm93SW5kZXgpIHtcbiAgICAgIHJldHVybiBhY2Nlc3NSb3cob3JpZ2luYWxSb3csIHJvd0luZGV4LCAwLCB1bmRlZmluZWQsIHJvd3MpO1xuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEV4cGFuZGVkID0gJ3Jlc2V0RXhwYW5kZWQnO1xuICBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkID0gJ3RvZ2dsZVJvd0V4cGFuZGVkJztcbiAgYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSAndG9nZ2xlQWxsUm93c0V4cGFuZGVkJztcbiAgdmFyIHVzZUV4cGFuZGVkID0gZnVuY3Rpb24gdXNlRXhwYW5kZWQoaG9va3MpIHtcbiAgICBob29rcy5nZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDEpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkMSk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3cpO1xuICB9O1xuICB1c2VFeHBhbmRlZC5wbHVnaW5OYW1lID0gJ3VzZUV4cGFuZGVkJztcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgUm93cyBFeHBhbmRlZCdcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlUm93RXhwYW5kZWRQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgcm93ID0gX3JlZjIucm93O1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIHJvdy50b2dnbGVSb3dFeHBhbmRlZCgpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUm93IEV4cGFuZGVkJ1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDEoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZXhwYW5kZWQ6IHt9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0RXhwYW5kZWQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXhwYW5kZWQ6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5leHBhbmRlZCB8fCB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCkge1xuICAgICAgdmFyIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQ7XG4gICAgICB2YXIgaXNBbGxSb3dzRXhwYW5kZWQgPSBPYmplY3Qua2V5cyhyb3dzQnlJZCkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhzdGF0ZS5leHBhbmRlZCkubGVuZ3RoO1xuICAgICAgdmFyIGV4cGFuZEFsbCA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICFpc0FsbFJvd3NFeHBhbmRlZDtcblxuICAgICAgaWYgKGV4cGFuZEFsbCkge1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocm93c0J5SWQpLmZvckVhY2goZnVuY3Rpb24gKHJvd0lkKSB7XG4gICAgICAgICAgZXhwYW5kZWRbcm93SWRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXhwYW5kZWQ6IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlUm93RXhwYW5kZWQpIHtcbiAgICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgICAgICBzZXRFeHBhbmRlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBleGlzdHMgPSBzdGF0ZS5leHBhbmRlZFtpZF07XG4gICAgICB2YXIgc2hvdWxkRXhpc3QgPSB0eXBlb2Ygc2V0RXhwYW5kZWQgIT09ICd1bmRlZmluZWQnID8gc2V0RXhwYW5kZWQgOiAhZXhpc3RzO1xuXG4gICAgICBpZiAoIWV4aXN0cyAmJiBzaG91bGRFeGlzdCkge1xuICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogX2V4dGVuZHMoe30sIHN0YXRlLmV4cGFuZGVkLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltpZF0gPSB0cnVlLCBfZXh0ZW5kczIpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RzICYmICFzaG91bGRFeGlzdCkge1xuICAgICAgICB2YXIgX3N0YXRlJGV4cGFuZGVkID0gc3RhdGUuZXhwYW5kZWQsXG4gICAgICAgICAgICBfID0gX3N0YXRlJGV4cGFuZGVkW2lkXSxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfc3RhdGUkZXhwYW5kZWQsIFtpZF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGV4cGFuZGVkOiByZXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDEoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICBfaW5zdGFuY2UkbWFudWFsRXhwYW4gPSBpbnN0YW5jZS5tYW51YWxFeHBhbmRlZEtleSxcbiAgICAgICAgbWFudWFsRXhwYW5kZWRLZXkgPSBfaW5zdGFuY2UkbWFudWFsRXhwYW4gPT09IHZvaWQgMCA/ICdleHBhbmRlZCcgOiBfaW5zdGFuY2UkbWFudWFsRXhwYW4sXG4gICAgICAgIF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9IGluc3RhbmNlLnBhZ2luYXRlRXhwYW5kZWRSb3dzLFxuICAgICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93cyA9IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCxcbiAgICAgICAgX2luc3RhbmNlJGV4cGFuZFN1YlJvID0gaW5zdGFuY2UuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRleHBhbmRTdWJSbyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEV4ID0gaW5zdGFuY2UuYXV0b1Jlc2V0RXhwYW5kZWQsXG4gICAgICAgIGF1dG9SZXNldEV4cGFuZGVkID0gX2luc3RhbmNlJGF1dG9SZXNldEV4ID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEV4LFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZXhwYW5kZWQgPSBpbnN0YW5jZS5zdGF0ZS5leHBhbmRlZCxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaDtcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZVNvcnRCeScsICd1c2VHcm91cEJ5JywgJ3VzZVBpdm90Q29sdW1ucycsICd1c2VHbG9iYWxGaWx0ZXInXSwgJ3VzZUV4cGFuZGVkJyk7XG4gICAgdmFyIGdldEF1dG9SZXNldEV4cGFuZGVkID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEV4cGFuZGVkKTtcbiAgICB2YXIgaXNBbGxSb3dzRXhwYW5kZWQgPSBCb29sZWFuKE9iamVjdC5rZXlzKHJvd3NCeUlkKS5sZW5ndGggJiYgT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCk7XG5cbiAgICBpZiAoaXNBbGxSb3dzRXhwYW5kZWQpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyb3dzQnlJZCkuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICFleHBhbmRlZFtpZF07XG4gICAgICB9KSkge1xuICAgICAgICBpc0FsbFJvd3NFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gQnlwYXNzIGFueSBlZmZlY3RzIGZyb20gZmlyaW5nIHdoZW4gdGhpcyBjaGFuZ2VzXG5cblxuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEV4cGFuZGVkKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRFeHBhbmRlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGRhdGFdKTtcbiAgICB2YXIgdG9nZ2xlUm93RXhwYW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUm93RXhwYW5kZWQsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZXhwYW5kZWRSb3dzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFJvd3Mocm93cywge1xuICAgICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5OiBtYW51YWxFeHBhbmRlZEtleSxcbiAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgICAgZXhwYW5kU3ViUm93czogZXhwYW5kU3ViUm93c1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfSwgW3BhZ2luYXRlRXhwYW5kZWRSb3dzLCByb3dzLCBtYW51YWxFeHBhbmRlZEtleSwgZXhwYW5kZWQsIGV4cGFuZFN1YlJvd3NdKTtcbiAgICB2YXIgZXhwYW5kZWREZXB0aCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmRFeHBhbmRlZERlcHRoKGV4cGFuZGVkKTtcbiAgICB9LCBbZXhwYW5kZWRdKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlRXhwYW5kZWRSb3dzOiByb3dzLFxuICAgICAgZXhwYW5kZWRSb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgICBleHBhbmRlZERlcHRoOiBleHBhbmRlZERlcHRoLFxuICAgICAgaXNBbGxSb3dzRXhwYW5kZWQ6IGlzQWxsUm93c0V4cGFuZGVkLFxuICAgICAgdG9nZ2xlUm93RXhwYW5kZWQ6IHRvZ2dsZVJvd0V4cGFuZGVkLFxuICAgICAgdG9nZ2xlQWxsUm93c0V4cGFuZGVkOiB0b2dnbGVBbGxSb3dzRXhwYW5kZWQsXG4gICAgICBnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wczogZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVSb3cocm93LCBfcmVmMykge1xuICAgIHZhciBnZXRIb29rcyA9IF9yZWYzLmluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlO1xuXG4gICAgcm93LnRvZ2dsZVJvd0V4cGFuZGVkID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVJvd0V4cGFuZGVkKHJvdy5pZCwgc2V0KTtcbiAgICB9O1xuXG4gICAgcm93LmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHJvdzogcm93XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRXhwYW5kZWREZXB0aChleHBhbmRlZCkge1xuICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgT2JqZWN0LmtleXMoZXhwYW5kZWQpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgc3BsaXRJZCA9IGlkLnNwbGl0KCcuJyk7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBzcGxpdElkLmxlbmd0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heERlcHRoO1xuICB9XG5cbiAgdmFyIHRleHQgPSBmdW5jdGlvbiB0ZXh0KHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByb3dzID0gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhyb3dWYWx1ZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhTdHJpbmcoZmlsdGVyVmFsdWUpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG5cbiAgdGV4dC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBleGFjdFRleHQgPSBmdW5jdGlvbiBleGFjdFRleHQocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhyb3dWYWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gU3RyaW5nKGZpbHRlclZhbHVlKS50b0xvd2VyQ2FzZSgpIDogdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4YWN0VGV4dC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBleGFjdFRleHRDYXNlID0gZnVuY3Rpb24gZXhhY3RUZXh0Q2FzZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKHJvd1ZhbHVlKSA9PT0gU3RyaW5nKGZpbHRlclZhbHVlKSA6IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdFRleHRDYXNlLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWw7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaW5jbHVkZXMuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCAhdmFsLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgaW5jbHVkZXNBbGwgPSBmdW5jdGlvbiBpbmNsdWRlc0FsbChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAmJiByb3dWYWx1ZS5sZW5ndGggJiYgZmlsdGVyVmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiByb3dWYWx1ZS5pbmNsdWRlcyh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzQWxsLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzU29tZSA9IGZ1bmN0aW9uIGluY2x1ZGVzU29tZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAmJiByb3dWYWx1ZS5sZW5ndGggJiYgZmlsdGVyVmFsdWUuc29tZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd1ZhbHVlLmluY2x1ZGVzKHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaW5jbHVkZXNTb21lLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzVmFsdWUgPSBmdW5jdGlvbiBpbmNsdWRlc1ZhbHVlKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIGZpbHRlclZhbHVlLmluY2x1ZGVzKHJvd1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzVmFsdWUuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCAhdmFsLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgZXhhY3QgPSBmdW5jdGlvbiBleGFjdChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSA9PT0gZmlsdGVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbiAgfTtcblxuICB2YXIgZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG4gICAgICAgIHJldHVybiByb3dWYWx1ZSA9PSBmaWx0ZXJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGVxdWFscy5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4ocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHZhciBfcmVmID0gZmlsdGVyVmFsdWUgfHwgW10sXG4gICAgICAgIG1pbiA9IF9yZWZbMF0sXG4gICAgICAgIG1heCA9IF9yZWZbMV07XG5cbiAgICBtaW4gPSB0eXBlb2YgbWluID09PSAnbnVtYmVyJyA/IG1pbiA6IC1JbmZpbml0eTtcbiAgICBtYXggPSB0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyA/IG1heCA6IEluZmluaXR5O1xuXG4gICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICBtaW4gPSBtYXg7XG4gICAgICBtYXggPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgPj0gbWluICYmIHJvd1ZhbHVlIDw9IG1heDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGJldHdlZW4uYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCB0eXBlb2YgdmFsWzBdICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsWzFdICE9PSAnbnVtYmVyJztcbiAgfTtcblxuICB2YXIgZmlsdGVyVHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHRleHQ6IHRleHQsXG4gICAgZXhhY3RUZXh0OiBleGFjdFRleHQsXG4gICAgZXhhY3RUZXh0Q2FzZTogZXhhY3RUZXh0Q2FzZSxcbiAgICBpbmNsdWRlczogaW5jbHVkZXMsXG4gICAgaW5jbHVkZXNBbGw6IGluY2x1ZGVzQWxsLFxuICAgIGluY2x1ZGVzU29tZTogaW5jbHVkZXNTb21lLFxuICAgIGluY2x1ZGVzVmFsdWU6IGluY2x1ZGVzVmFsdWUsXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGJldHdlZW46IGJldHdlZW5cbiAgfSk7XG5cbiAgYWN0aW9ucy5yZXNldEZpbHRlcnMgPSAncmVzZXRGaWx0ZXJzJztcbiAgYWN0aW9ucy5zZXRGaWx0ZXIgPSAnc2V0RmlsdGVyJztcbiAgYWN0aW9ucy5zZXRBbGxGaWx0ZXJzID0gJ3NldEFsbEZpbHRlcnMnO1xuICB2YXIgdXNlRmlsdGVycyA9IGZ1bmN0aW9uIHVzZUZpbHRlcnMoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDIpO1xuICB9O1xuICB1c2VGaWx0ZXJzLnBsdWdpbk5hbWUgPSAndXNlRmlsdGVycyc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciQyKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGZpbHRlcnM6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0RmlsdGVycykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBmaWx0ZXJzOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZmlsdGVycyB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEZpbHRlcikge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGZpbHRlclZhbHVlID0gYWN0aW9uLmZpbHRlclZhbHVlO1xuICAgICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzO1xuICAgICAgdmFyIGNvbHVtbiA9IGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QtVGFibGU6IENvdWxkIG5vdCBmaW5kIGEgY29sdW1uIHdpdGggaWQ6IFwiICsgY29sdW1uSWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGNvbHVtbi5maWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuICAgICAgdmFyIHByZXZpb3VzZmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVyVmFsdWUsIHByZXZpb3VzZmlsdGVyICYmIHByZXZpb3VzZmlsdGVyLnZhbHVlKTsgLy9cblxuICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyTWV0aG9kLmF1dG9SZW1vdmUsIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpb3VzZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbklkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZmlsdGVyczogW10uY29uY2F0KHN0YXRlLmZpbHRlcnMsIFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgfV0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0QWxsRmlsdGVycykge1xuICAgICAgdmFyIGZpbHRlcnMgPSBhY3Rpb24uZmlsdGVycztcbiAgICAgIHZhciBfYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgICAgX3VzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgZmlsdGVyczogZnVuY3Rpb25hbFVwZGF0ZShmaWx0ZXJzLCBzdGF0ZS5maWx0ZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgIHZhciBjb2x1bW4gPSBfYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gZmlsdGVyLmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChjb2x1bW4uZmlsdGVyLCBfdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJNZXRob2QuYXV0b1JlbW92ZSwgZmlsdGVyLnZhbHVlLCBjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQyKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzLFxuICAgICAgICBtYW51YWxGaWx0ZXJzID0gaW5zdGFuY2UubWFudWFsRmlsdGVycyxcbiAgICAgICAgX2luc3RhbmNlJGRlZmF1bHRDYW5GID0gaW5zdGFuY2UuZGVmYXVsdENhbkZpbHRlcixcbiAgICAgICAgZGVmYXVsdENhbkZpbHRlciA9IF9pbnN0YW5jZSRkZWZhdWx0Q2FuRiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaW5zdGFuY2UkZGVmYXVsdENhbkYsXG4gICAgICAgIGRpc2FibGVGaWx0ZXJzID0gaW5zdGFuY2UuZGlzYWJsZUZpbHRlcnMsXG4gICAgICAgIGZpbHRlcnMgPSBpbnN0YW5jZS5zdGF0ZS5maWx0ZXJzLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0RmkgPSBpbnN0YW5jZS5hdXRvUmVzZXRGaWx0ZXJzLFxuICAgICAgICBhdXRvUmVzZXRGaWx0ZXJzID0gX2luc3RhbmNlJGF1dG9SZXNldEZpID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEZpO1xuICAgIHZhciBzZXRGaWx0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIGZpbHRlclZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0RmlsdGVyLFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIGZpbHRlclZhbHVlOiBmaWx0ZXJWYWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEFsbEZpbHRlcnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZmlsdGVycykge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEFsbEZpbHRlcnMsXG4gICAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgaWQgPSBjb2x1bW4uaWQsXG4gICAgICAgICAgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgY29sdW1uRGVmYXVsdENhbkZpbHRlciA9IGNvbHVtbi5kZWZhdWx0Q2FuRmlsdGVyLFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVGaWx0ZXJzID0gY29sdW1uLmRpc2FibGVGaWx0ZXJzOyAvLyBEZXRlcm1pbmUgaWYgYSBjb2x1bW4gaXMgZmlsdGVyYWJsZVxuXG4gICAgICBjb2x1bW4uY2FuRmlsdGVyID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZUZpbHRlcnMgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUZpbHRlcnMgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoY29sdW1uRGVmYXVsdENhbkZpbHRlciwgZGVmYXVsdENhbkZpbHRlciwgZmFsc2UpOyAvLyBQcm92aWRlIHRoZSBjb2x1bW4gYSB3YXkgb2YgdXBkYXRpbmcgdGhlIGZpbHRlciB2YWx1ZVxuXG4gICAgICBjb2x1bW4uc2V0RmlsdGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKGNvbHVtbi5pZCwgdmFsKTtcbiAgICAgIH07IC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlIHRvIHRoZSBjb2x1bW4gZm9yXG4gICAgICAvLyBjb252ZW5pZW5jZVxuXG5cbiAgICAgIHZhciBmb3VuZCA9IGZpbHRlcnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGNvbHVtbi5maWx0ZXJWYWx1ZSA9IGZvdW5kICYmIGZvdW5kLnZhbHVlO1xuICAgIH0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWFudWFsRmlsdGVycyB8fCAhZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtyb3dzLCBmbGF0Um93cywgcm93c0J5SWRdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIGZpbHRlcmVkUm93c0J5SWQgPSB7fTsgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG5cbiAgICAgIHZhciBmaWx0ZXJSb3dzID0gZnVuY3Rpb24gZmlsdGVyUm93cyhyb3dzLCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJlZFJvd3MgPSByb3dzO1xuICAgICAgICBmaWx0ZXJlZFJvd3MgPSBmaWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAoZmlsdGVyZWRTb0ZhciwgX3JlZikge1xuICAgICAgICAgIHZhciBjb2x1bW5JZCA9IF9yZWYuaWQsXG4gICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaWx0ZXJzIGNvbHVtblxuICAgICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbHVtbi5wcmVGaWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFNvRmFyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoY29sdW1uLmZpbHRlciwgdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgICAgICBpZiAoIWZpbHRlck1ldGhvZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlcicgZm9yIGNvbHVtbiB3aXRoIHRoZSBJRDogXCIgKyBjb2x1bW4uaWQgKyBcIi5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9IC8vIFBhc3MgdGhlIHJvd3MsIGlkLCBmaWx0ZXJWYWx1ZSBhbmQgY29sdW1uIHRvIHRoZSBmaWx0ZXJNZXRob2RcbiAgICAgICAgICAvLyB0byBnZXQgdGhlIGZpbHRlcmVkIHJvd3MgYmFja1xuXG5cbiAgICAgICAgICBjb2x1bW4uZmlsdGVyZWRSb3dzID0gZmlsdGVyTWV0aG9kKGZpbHRlcmVkU29GYXIsIFtjb2x1bW5JZF0sIGZpbHRlclZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uLmZpbHRlcmVkUm93cztcbiAgICAgICAgfSwgcm93cyk7IC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICAgICAgLy8gV2UgdGVjaG5pY2FsbHkgY291bGQgZG8gdGhpcyByZWN1cnNpdmVseSBpbiB0aGUgYWJvdmUgbG9vcCxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgc2V2ZXJlbHkgaGluZGVyIHRoZSBBUEkgZm9yIHRoZSB1c2VyLCBzaW5jZSB0aGV5XG4gICAgICAgIC8vIHdvdWxkIGJlIHJlcXVpcmVkIHRvIGRvIHRoYXQgcmVjdXJzaW9uIGluIHNvbWUgc2NlbmFyaW9zXG5cbiAgICAgICAgZmlsdGVyZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIGZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcblxuICAgICAgICAgIGlmICghcm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHJvdy5zdWJSb3dzICYmIHJvdy5zdWJSb3dzLmxlbmd0aCA+IDAgPyBmaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpIDogcm93LnN1YlJvd3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRSb3dzO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFtmaWx0ZXJSb3dzKHJvd3MpLCBmaWx0ZXJlZEZsYXRSb3dzLCBmaWx0ZXJlZFJvd3NCeUlkXTtcbiAgICB9LCBbbWFudWFsRmlsdGVycywgZmlsdGVycywgcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBhbGxDb2x1bW5zLCB1c2VyRmlsdGVyVHlwZXNdKSxcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGZpbHRlcmVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZmlsdGVyZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBOb3cgdGhhdCBlYWNoIGZpbHRlcmVkIGNvbHVtbiBoYXMgaXQncyBwYXJ0aWFsbHkgZmlsdGVyZWQgcm93cyxcbiAgICAgIC8vIGxldHMgYXNzaWduIHRoZSBmaW5hbCBmaWx0ZXJlZCByb3dzIHRvIGFsbCBvZiB0aGUgb3RoZXIgY29sdW1uc1xuICAgICAgdmFyIG5vbkZpbHRlcmVkQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuICFmaWx0ZXJzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBUaGlzIGVzc2VudGlhbGx5IGVuYWJsZXMgZmFjZXRlZCBmaWx0ZXIgb3B0aW9ucyB0byBiZSBidWlsdCBlYXNpbHlcbiAgICAgIC8vIHVzaW5nIGV2ZXJ5IGNvbHVtbidzIHByZUZpbHRlcmVkUm93cyB2YWx1ZVxuXG4gICAgICBub25GaWx0ZXJlZENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIGNvbHVtbi5wcmVGaWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFJvd3M7XG4gICAgICAgIGNvbHVtbi5maWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFJvd3M7XG4gICAgICB9KTtcbiAgICB9LCBbZmlsdGVyZWRSb3dzLCBmaWx0ZXJzLCBhbGxDb2x1bW5zXSk7XG4gICAgdmFyIGdldEF1dG9SZXNldEZpbHRlcnMgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0RmlsdGVycyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0RmlsdGVycygpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0RmlsdGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbEZpbHRlcnMgPyBudWxsIDogZGF0YV0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHByZUZpbHRlcmVkUm93czogcm93cyxcbiAgICAgIHByZUZpbHRlcmVkRmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgcHJlRmlsdGVyZWRSb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICBmaWx0ZXJlZFJvd3M6IGZpbHRlcmVkUm93cyxcbiAgICAgIGZpbHRlcmVkRmxhdFJvd3M6IGZpbHRlcmVkRmxhdFJvd3MsXG4gICAgICBmaWx0ZXJlZFJvd3NCeUlkOiBmaWx0ZXJlZFJvd3NCeUlkLFxuICAgICAgcm93czogZmlsdGVyZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGZpbHRlcmVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogZmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHNldEZpbHRlcjogc2V0RmlsdGVyLFxuICAgICAgc2V0QWxsRmlsdGVyczogc2V0QWxsRmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlciA9ICdyZXNldEdsb2JhbEZpbHRlcic7XG4gIGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyID0gJ3NldEdsb2JhbEZpbHRlcic7XG4gIHZhciB1c2VHbG9iYWxGaWx0ZXIgPSBmdW5jdGlvbiB1c2VHbG9iYWxGaWx0ZXIoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQzKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDMpO1xuICB9O1xuICB1c2VHbG9iYWxGaWx0ZXIucGx1Z2luTmFtZSA9ICd1c2VHbG9iYWxGaWx0ZXInO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkMyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBnbG9iYWxGaWx0ZXI6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIgfHwgdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyKSB7XG4gICAgICB2YXIgZmlsdGVyVmFsdWUgPSBhY3Rpb24uZmlsdGVyVmFsdWU7XG4gICAgICB2YXIgdXNlckZpbHRlclR5cGVzID0gaW5zdGFuY2UudXNlckZpbHRlclR5cGVzO1xuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChpbnN0YW5jZS5nbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuICAgICAgdmFyIG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVyVmFsdWUsIHN0YXRlLmdsb2JhbEZpbHRlcik7IC8vXG5cbiAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlck1ldGhvZC5hdXRvUmVtb3ZlLCBuZXdGaWx0ZXIpKSB7XG4gICAgICAgIHZhciBnbG9iYWxGaWx0ZXIgPSBzdGF0ZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgICAgICBzdGF0ZVdpdGhvdXRHbG9iYWxGaWx0ZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzdGF0ZSwgW1wiZ2xvYmFsRmlsdGVyXCJdKTtcblxuICAgICAgICByZXR1cm4gc3RhdGVXaXRob3V0R2xvYmFsRmlsdGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdsb2JhbEZpbHRlcjogbmV3RmlsdGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQzKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzLFxuICAgICAgICBnbG9iYWxGaWx0ZXIgPSBpbnN0YW5jZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgIG1hbnVhbEdsb2JhbEZpbHRlciA9IGluc3RhbmNlLm1hbnVhbEdsb2JhbEZpbHRlcixcbiAgICAgICAgZ2xvYmFsRmlsdGVyVmFsdWUgPSBpbnN0YW5jZS5zdGF0ZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRHbCA9IGluc3RhbmNlLmF1dG9SZXNldEdsb2JhbEZpbHRlcixcbiAgICAgICAgYXV0b1Jlc2V0R2xvYmFsRmlsdGVyID0gX2luc3RhbmNlJGF1dG9SZXNldEdsID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEdsLFxuICAgICAgICBkaXNhYmxlR2xvYmFsRmlsdGVyID0gaW5zdGFuY2UuZGlzYWJsZUdsb2JhbEZpbHRlcjtcbiAgICB2YXIgc2V0R2xvYmFsRmlsdGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpbHRlclZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyLFxuICAgICAgICBmaWx0ZXJWYWx1ZTogZmlsdGVyVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyBUT0RPOiBDcmVhdGUgYSBmaWx0ZXIgY2FjaGUgZm9yIGluY3JlbWVudGFsIGhpZ2ggc3BlZWQgbXVsdGktZmlsdGVyaW5nXG4gICAgLy8gVGhpcyBnZXRzIHByZXR0eSBjb21wbGljYXRlZCBwcmV0dHkgZmFzdCwgc2luY2UgeW91IGhhdmUgdG8gbWFpbnRhaW4gYVxuICAgIC8vIGNhY2hlIGZvciBlYWNoIHJvdyBncm91cCAodG9wLWxldmVsIHJvd3MsIGFuZCBlYWNoIHJvdydzIHJlY3Vyc2l2ZSBzdWJyb3dzKVxuICAgIC8vIFRoaXMgd291bGQgbWFrZSBtdWx0aS1maWx0ZXJpbmcgYSBsb3QgZmFzdGVyIHRob3VnaC4gVG9vIGZhcj9cblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEdsb2JhbEZpbHRlciB8fCB0eXBlb2YgZ2xvYmFsRmlsdGVyVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBmaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGdsb2JhbEZpbHRlciwgdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgIGlmICghZmlsdGVyTWV0aG9kKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2dsb2JhbEZpbHRlcicgb3B0aW9uLlwiKTtcbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICB9XG5cbiAgICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBjb2x1bW5EaXNhYmxlR2xvYmFsRmlsdGVyID0gY29sdW1uLmRpc2FibGVHbG9iYWxGaWx0ZXI7XG4gICAgICAgIGNvbHVtbi5jYW5GaWx0ZXIgPSBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZUdsb2JhbEZpbHRlciA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlR2xvYmFsRmlsdGVyID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVyYWJsZUNvbHVtbnMgPSBhbGxDb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5jYW5GaWx0ZXIgPT09IHRydWU7XG4gICAgICB9KTsgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG5cbiAgICAgIHZhciBmaWx0ZXJSb3dzID0gZnVuY3Rpb24gZmlsdGVyUm93cyhmaWx0ZXJlZFJvd3MpIHtcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gZmlsdGVyTWV0aG9kKGZpbHRlcmVkUm93cywgZmlsdGVyYWJsZUNvbHVtbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgIH0pLCBnbG9iYWxGaWx0ZXJWYWx1ZSk7XG4gICAgICAgIGZpbHRlcmVkUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBmaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSByb3cuc3ViUm93cyAmJiByb3cuc3ViUm93cy5sZW5ndGggPyBmaWx0ZXJSb3dzKHJvdy5zdWJSb3dzKSA6IHJvdy5zdWJSb3dzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBbZmlsdGVyUm93cyhyb3dzKSwgZmlsdGVyZWRGbGF0Um93cywgZmlsdGVyZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEdsb2JhbEZpbHRlciwgZ2xvYmFsRmlsdGVyVmFsdWUsIGdsb2JhbEZpbHRlciwgdXNlckZpbHRlclR5cGVzLCBhbGxDb2x1bW5zLCByb3dzLCBmbGF0Um93cywgcm93c0J5SWQsIGRpc2FibGVHbG9iYWxGaWx0ZXJdKSxcbiAgICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgdmFyIGdldEF1dG9SZXNldEdsb2JhbEZpbHRlciA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRHbG9iYWxGaWx0ZXIpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEdsb2JhbEZpbHRlcigpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0R2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsR2xvYmFsRmlsdGVyID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHByZUdsb2JhbEZpbHRlcmVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzOiBnbG9iYWxGaWx0ZXJlZFJvd3MsXG4gICAgICBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzOiBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZDogZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGdsb2JhbEZpbHRlcmVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdsb2JhbEZpbHRlcmVkUm93c0J5SWQsXG4gICAgICBzZXRHbG9iYWxGaWx0ZXI6IHNldEdsb2JhbEZpbHRlcixcbiAgICAgIGRpc2FibGVHbG9iYWxGaWx0ZXI6IGRpc2FibGVHbG9iYWxGaWx0ZXJcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1bSh2YWx1ZXMsIGFnZ3JlZ2F0ZWRWYWx1ZXMpIHtcbiAgICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZWRWYWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIG5leHQpIHtcbiAgICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHQgPT09ICdudW1iZXInID8gbmV4dCA6IDApO1xuICAgIH0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIG1pbih2YWx1ZXMpIHtcbiAgICB2YXIgbWluID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGZ1bmN0aW9uIG1heCh2YWx1ZXMpIHtcbiAgICB2YXIgbWF4ID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIG1pbk1heCh2YWx1ZXMpIHtcbiAgICB2YXIgbWluID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFyIG1heCA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtaW4gKyBcIi4uXCIgKyBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gYXZlcmFnZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gc3VtKG51bGwsIHZhbHVlcykgLyB2YWx1ZXMubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG1lZGlhbih2YWx1ZXMpIHtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgICB2YXIgbnVtcyA9IFtdLmNvbmNhdCh2YWx1ZXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIHVuaXF1ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykudmFsdWVzKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHVuaXF1ZUNvdW50KHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcykuc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBhZ2dyZWdhdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHN1bTogc3VtLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIG1pbk1heDogbWluTWF4LFxuICAgIGF2ZXJhZ2U6IGF2ZXJhZ2UsXG4gICAgbWVkaWFuOiBtZWRpYW4sXG4gICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgdW5pcXVlQ291bnQ6IHVuaXF1ZUNvdW50LFxuICAgIGNvdW50OiBjb3VudFxuICB9KTtcblxuICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICB2YXIgZW1wdHlPYmplY3QgPSB7fTsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRHcm91cEJ5ID0gJ3Jlc2V0R3JvdXBCeSc7XG4gIGFjdGlvbnMuc2V0R3JvdXBCeSA9ICdzZXRHcm91cEJ5JztcbiAgYWN0aW9ucy50b2dnbGVHcm91cEJ5ID0gJ3RvZ2dsZUdyb3VwQnknO1xuICB2YXIgdXNlR3JvdXBCeSA9IGZ1bmN0aW9uIHVzZUdyb3VwQnkoaG9va3MpIHtcbiAgICBob29rcy5nZXRHcm91cEJ5VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNCk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnNEZXBzLnB1c2goZnVuY3Rpb24gKGRlcHMsIF9yZWYpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGRlcHMsIFtpbnN0YW5jZS5zdGF0ZS5ncm91cEJ5XSk7XG4gICAgfSk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ0KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQxKTtcbiAgfTtcbiAgdXNlR3JvdXBCeS5wbHVnaW5OYW1lID0gJ3VzZUdyb3VwQnknO1xuXG4gIHZhciBkZWZhdWx0R2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgaGVhZGVyID0gX3JlZjIuaGVhZGVyO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGhlYWRlci5jYW5Hcm91cEJ5ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgIGhlYWRlci50b2dnbGVHcm91cEJ5KCk7XG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiBoZWFkZXIuY2FuR3JvdXBCeSA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEdyb3VwQnknXG4gICAgfV07XG4gIH07IC8vIFJlZHVjZXJcblxuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNChzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBncm91cEJ5OiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEdyb3VwQnkpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZ3JvdXBCeTogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmdyb3VwQnkgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRHcm91cEJ5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY3Rpb24udmFsdWU7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlR3JvdXBCeSkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIHNldEdyb3VwQnkgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgcmVzb2x2ZWRHcm91cEJ5ID0gdHlwZW9mIHNldEdyb3VwQnkgIT09ICd1bmRlZmluZWQnID8gc2V0R3JvdXBCeSA6ICFzdGF0ZS5ncm91cEJ5LmluY2x1ZGVzKGNvbHVtbklkKTtcblxuICAgICAgaWYgKHJlc29sdmVkR3JvdXBCeSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZ3JvdXBCeTogW10uY29uY2F0KHN0YXRlLmdyb3VwQnksIFtjb2x1bW5JZF0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IHN0YXRlLmdyb3VwQnkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZUNvbHVtbnMoY29sdW1ucywgX3JlZjMpIHtcbiAgICB2YXIgZ3JvdXBCeSA9IF9yZWYzLmluc3RhbmNlLnN0YXRlLmdyb3VwQnk7XG4gICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgIC8vIGJlZm9yZSB0aGUgaGVhZGVycyBhcmUgYnVpbHRcbiAgICB2YXIgZ3JvdXBCeUNvbHVtbnMgPSBncm91cEJ5Lm1hcChmdW5jdGlvbiAoZykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHJldHVybiBjb2wuaWQgPT09IGc7XG4gICAgICB9KTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgdmFyIG5vbkdyb3VwQnlDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgcmV0dXJuICFncm91cEJ5LmluY2x1ZGVzKGNvbC5pZCk7XG4gICAgfSk7XG4gICAgY29sdW1ucyA9IFtdLmNvbmNhdChncm91cEJ5Q29sdW1ucywgbm9uR3JvdXBCeUNvbHVtbnMpO1xuICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNHcm91cGVkID0gZ3JvdXBCeS5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgY29sdW1uLmdyb3VwZWRJbmRleCA9IGdyb3VwQnkuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5zO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRVc2VyQWdncmVnYXRpb25zID0ge307XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNChpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBfaW5zdGFuY2UkZ3JvdXBCeUZuID0gaW5zdGFuY2UuZ3JvdXBCeUZuLFxuICAgICAgICBncm91cEJ5Rm4gPSBfaW5zdGFuY2UkZ3JvdXBCeUZuID09PSB2b2lkIDAgPyBkZWZhdWx0R3JvdXBCeUZuIDogX2luc3RhbmNlJGdyb3VwQnlGbixcbiAgICAgICAgbWFudWFsR3JvdXBCeSA9IGluc3RhbmNlLm1hbnVhbEdyb3VwQnksXG4gICAgICAgIF9pbnN0YW5jZSRhZ2dyZWdhdGlvbiA9IGluc3RhbmNlLmFnZ3JlZ2F0aW9ucyxcbiAgICAgICAgdXNlckFnZ3JlZ2F0aW9ucyA9IF9pbnN0YW5jZSRhZ2dyZWdhdGlvbiA9PT0gdm9pZCAwID8gZGVmYXVsdFVzZXJBZ2dyZWdhdGlvbnMgOiBfaW5zdGFuY2UkYWdncmVnYXRpb24sXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBncm91cEJ5ID0gaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEdyID0gaW5zdGFuY2UuYXV0b1Jlc2V0R3JvdXBCeSxcbiAgICAgICAgYXV0b1Jlc2V0R3JvdXBCeSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRHciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRHcixcbiAgICAgICAgZGlzYWJsZUdyb3VwQnkgPSBpbnN0YW5jZS5kaXNhYmxlR3JvdXBCeSxcbiAgICAgICAgZGVmYXVsdENhbkdyb3VwQnkgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuR3JvdXBCeSxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUNvbHVtbk9yZGVyJywgJ3VzZUZpbHRlcnMnXSwgJ3VzZUdyb3VwQnknKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgZGVmYXVsdENvbHVtbkdyb3VwQnkgPSBjb2x1bW4uZGVmYXVsdEdyb3VwQnksXG4gICAgICAgICAgY29sdW1uRGlzYWJsZUdyb3VwQnkgPSBjb2x1bW4uZGlzYWJsZUdyb3VwQnk7XG4gICAgICBjb2x1bW4uY2FuR3JvdXBCeSA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5Hcm91cEJ5LCBjb2x1bW5EaXNhYmxlR3JvdXBCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlR3JvdXBCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKSA6IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuR3JvdXBCeSwgZGVmYXVsdENvbHVtbkdyb3VwQnksIGRlZmF1bHRDYW5Hcm91cEJ5LCBmYWxzZSk7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuR3JvdXBCeSkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBCeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudG9nZ2xlR3JvdXBCeShjb2x1bW4uaWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4uQWdncmVnYXRlZCA9IGNvbHVtbi5BZ2dyZWdhdGVkIHx8IGNvbHVtbi5DZWxsO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVHcm91cEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUdyb3VwQnksXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0R3JvdXBCeSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEdyb3VwQnksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICBoZWFkZXIuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRHcm91cEJ5VG9nZ2xlUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGhlYWRlcjogaGVhZGVyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEdyb3VwQnkgfHwgIWdyb3VwQnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH0gLy8gRW5zdXJlIHRoYXQgdGhlIGxpc3Qgb2YgZmlsdGVyZWQgY29sdW1ucyBleGlzdFxuXG5cbiAgICAgIHZhciBleGlzdGluZ0dyb3VwQnkgPSBncm91cEJ5LmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICByZXR1cm4gY29sLmlkID09PSBnO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBGaW5kIHRoZSBjb2x1bW5zIHRoYXQgY2FuIG9yIGFyZSBhZ2dyZWdhdGluZ1xuICAgICAgLy8gVXNlcyBlYWNoIGNvbHVtbiB0byBhZ2dyZWdhdGUgcm93cyBpbnRvIGEgc2luZ2xlIHZhbHVlXG5cbiAgICAgIHZhciBhZ2dyZWdhdGVSb3dzVG9WYWx1ZXMgPSBmdW5jdGlvbiBhZ2dyZWdhdGVSb3dzVG9WYWx1ZXMobGVhZlJvd3MsIGdyb3VwZWRSb3dzLCBkZXB0aCkge1xuICAgICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYWdncmVnYXRlIGNvbHVtbnMgdGhhdCBhcmUgaW4gdGhlIGdyb3VwQnlcbiAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICAgIHZhbHVlc1tjb2x1bW4uaWRdID0gZ3JvdXBlZFJvd3NbMF0gPyBncm91cGVkUm93c1swXS52YWx1ZXNbY29sdW1uLmlkXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBBZ2dyZWdhdGUgdGhlIHZhbHVlc1xuXG5cbiAgICAgICAgICB2YXIgYWdncmVnYXRlRm4gPSB0eXBlb2YgY29sdW1uLmFnZ3JlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5hZ2dyZWdhdGUgOiB1c2VyQWdncmVnYXRpb25zW2NvbHVtbi5hZ2dyZWdhdGVdIHx8IGFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlXTtcblxuICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb2x1bW5WYWx1ZXMgdG8gYWdncmVnYXRlXG4gICAgICAgICAgICB2YXIgZ3JvdXBlZFZhbHVlcyA9IGdyb3VwZWRSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cudmFsdWVzW2NvbHVtbi5pZF07XG4gICAgICAgICAgICB9KTsgLy8gR2V0IHRoZSBjb2x1bW5WYWx1ZXMgdG8gYWdncmVnYXRlXG5cbiAgICAgICAgICAgIHZhciBsZWFmVmFsdWVzID0gbGVhZlJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbHVtblZhbHVlID0gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuXG4gICAgICAgICAgICAgIGlmICghZGVwdGggJiYgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0ZVZhbHVlRm4gPSB0eXBlb2YgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlID09PSAnZnVuY3Rpb24nID8gY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlIDogdXNlckFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlVmFsdWVdIHx8IGFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhZ2dyZWdhdGVWYWx1ZUZuKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBUYWJsZTogSW52YWxpZCBjb2x1bW4uYWdncmVnYXRlVmFsdWUgb3B0aW9uIGZvciBjb2x1bW4gbGlzdGVkIGFib3ZlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtblZhbHVlID0gYWdncmVnYXRlVmFsdWVGbihjb2x1bW5WYWx1ZSwgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtblZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IGFnZ3JlZ2F0ZUZuKGxlYWZWYWx1ZXMsIGdyb3VwZWRWYWx1ZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKHtcbiAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IEludmFsaWQgY29sdW1uLmFnZ3JlZ2F0ZSBvcHRpb24gZm9yIGNvbHVtbiBsaXN0ZWQgYWJvdmVcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1tjb2x1bW4uaWRdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIG9ubHlHcm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBvbmx5R3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgICB2YXIgbm9uR3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgbm9uR3JvdXBlZFJvd3NCeUlkID0ge307IC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG5cbiAgICAgIHZhciBncm91cFVwUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiBncm91cFVwUmVjdXJzaXZlbHkocm93cywgZGVwdGgsIHBhcmVudElkKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCBsZXZlbCwganVzdCByZXR1cm4gdGhlIHJvd3NcbiAgICAgICAgaWYgKGRlcHRoID09PSBleGlzdGluZ0dyb3VwQnkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcm93LCB7XG4gICAgICAgICAgICAgIGRlcHRoOiBkZXB0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwQnlbZGVwdGhdOyAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuXG4gICAgICAgIHZhciByb3dHcm91cHNNYXAgPSBncm91cEJ5Rm4ocm93cywgY29sdW1uSWQpOyAvLyBQZWZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG5cbiAgICAgICAgdmFyIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cyA9IE9iamVjdC5lbnRyaWVzKHJvd0dyb3Vwc01hcCkubWFwKGZ1bmN0aW9uIChfcmVmNCwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBCeVZhbCA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICBncm91cGVkUm93cyA9IF9yZWY0WzFdO1xuICAgICAgICAgIHZhciBpZCA9IGNvbHVtbklkICsgXCI6XCIgKyBncm91cEJ5VmFsO1xuICAgICAgICAgIGlkID0gcGFyZW50SWQgPyBwYXJlbnRJZCArIFwiPlwiICsgaWQgOiBpZDsgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG5cbiAgICAgICAgICB2YXIgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZCk7IC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG5cbiAgICAgICAgICB2YXIgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgJ2xlYWZSb3dzJykgOiBncm91cGVkUm93cztcbiAgICAgICAgICB2YXIgdmFsdWVzID0gYWdncmVnYXRlUm93c1RvVmFsdWVzKGxlYWZSb3dzLCBncm91cGVkUm93cywgZGVwdGgpO1xuICAgICAgICAgIHZhciByb3cgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpc0dyb3VwZWQ6IHRydWUsXG4gICAgICAgICAgICBncm91cEJ5SUQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgZ3JvdXBCeVZhbDogZ3JvdXBCeVZhbCxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgc3ViUm93czogc3ViUm93cyxcbiAgICAgICAgICAgIGxlYWZSb3dzOiBsZWFmUm93cyxcbiAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJSb3cpIHtcbiAgICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcblxuICAgICAgICAgICAgaWYgKHN1YlJvdy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWdncmVnYXRlZEdyb3VwZWRSb3dzO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdyb3VwZWRSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd3MpO1xuICAgICAgZ3JvdXBlZFJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuXG4gICAgICAgIGlmIChzdWJSb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBBc3NpZ24gdGhlIG5ldyBkYXRhXG5cbiAgICAgIHJldHVybiBbZ3JvdXBlZFJvd3MsIGdyb3VwZWRGbGF0Um93cywgZ3JvdXBlZFJvd3NCeUlkLCBvbmx5R3JvdXBlZEZsYXRSb3dzLCBvbmx5R3JvdXBlZFJvd3NCeUlkLCBub25Hcm91cGVkRmxhdFJvd3MsIG5vbkdyb3VwZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEdyb3VwQnksIGdyb3VwQnksIHJvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgYWxsQ29sdW1ucywgdXNlckFnZ3JlZ2F0aW9ucywgZ3JvdXBCeUZuXSksXG4gICAgICAgIGdyb3VwZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzFdLFxuICAgICAgICBncm91cGVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXSxcbiAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzNdLFxuICAgICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bNF0sXG4gICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzVdLFxuICAgICAgICBub25Hcm91cGVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1s2XTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRHcm91cEJ5ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEdyb3VwQnkpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEdyb3VwQnkoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEdyb3VwQnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW51YWxHcm91cEJ5ID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVHcm91cGVkUm93czogcm93cyxcbiAgICAgIHByZUdyb3VwZWRGbGF0Um93OiBmbGF0Um93cyxcbiAgICAgIHByZUdyb3VwZWRSb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICBncm91cGVkUm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBncm91cGVkRmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIGdyb3VwZWRSb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkLFxuICAgICAgb25seUdyb3VwZWRGbGF0Um93czogb25seUdyb3VwZWRGbGF0Um93cyxcbiAgICAgIG9ubHlHcm91cGVkUm93c0J5SWQ6IG9ubHlHcm91cGVkUm93c0J5SWQsXG4gICAgICBub25Hcm91cGVkRmxhdFJvd3M6IG5vbkdyb3VwZWRGbGF0Um93cyxcbiAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZDogbm9uR3JvdXBlZFJvd3NCeUlkLFxuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIHRvZ2dsZUdyb3VwQnk6IHRvZ2dsZUdyb3VwQnksXG4gICAgICBzZXRHcm91cEJ5OiBzZXRHcm91cEJ5XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDEocm93KSB7XG4gICAgcm93LmFsbENlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG5cbiAgICAgIC8vIEdyb3VwZWQgY2VsbHMgYXJlIGluIHRoZSBncm91cEJ5IGFuZCB0aGUgcGl2b3QgY2VsbCBmb3IgdGhlIHJvd1xuICAgICAgY2VsbC5pc0dyb3VwZWQgPSBjZWxsLmNvbHVtbi5pc0dyb3VwZWQgJiYgY2VsbC5jb2x1bW4uaWQgPT09IHJvdy5ncm91cEJ5SUQ7IC8vIFBsYWNlaG9sZGVyIGNlbGxzIGFyZSBhbnkgY29sdW1ucyBpbiB0aGUgZ3JvdXBCeSB0aGF0IGFyZSBub3QgZ3JvdXBlZFxuXG4gICAgICBjZWxsLmlzUGxhY2Vob2xkZXIgPSAhY2VsbC5pc0dyb3VwZWQgJiYgY2VsbC5jb2x1bW4uaXNHcm91cGVkOyAvLyBBZ2dyZWdhdGVkIGNlbGxzIGFyZSBub3QgZ3JvdXBlZCwgbm90IHJlcGVhdGVkLCBidXQgc3RpbGwgaGF2ZSBzdWJSb3dzXG5cbiAgICAgIGNlbGwuaXNBZ2dyZWdhdGVkID0gIWNlbGwuaXNHcm91cGVkICYmICFjZWxsLmlzUGxhY2Vob2xkZXIgJiYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEdyb3VwQnlGbihyb3dzLCBjb2x1bW5JZCkge1xuICAgIHJldHVybiByb3dzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcm93LCBpKSB7XG4gICAgICAvLyBUT0RPOiBNaWdodCB3YW50IHRvIGltcGxlbWVudCBhIGtleSBzZXJpYWxpemVyIGhlcmUgc29cbiAgICAgIC8vIGlycmVndWxhciBjb2x1bW4gdmFsdWVzIGNhbiBzdGlsbCBiZSBncm91cGVkIGlmIG5lZWRlZD9cbiAgICAgIHZhciByZXNLZXkgPSBcIlwiICsgcm93LnZhbHVlc1tjb2x1bW5JZF07XG4gICAgICBwcmV2W3Jlc0tleV0gPSBBcnJheS5pc0FycmF5KHByZXZbcmVzS2V5XSkgPyBwcmV2W3Jlc0tleV0gOiBbXTtcbiAgICAgIHByZXZbcmVzS2V5XS5wdXNoKHJvdyk7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgcmVTcGxpdEFscGhhTnVtZXJpYyA9IC8oWzAtOV0rKS9nbTsgLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuICAvLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4gIC8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XG5cbiAgdmFyIGFscGhhbnVtZXJpYyA9IGZ1bmN0aW9uIGFscGhhbnVtZXJpYyhyb3dBLCByb3dCLCBjb2x1bW5JZCkge1xuICAgIHZhciBfZ2V0Um93VmFsdWVzQnlDb2x1bW4gPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtblswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtblsxXTsgLy8gRm9yY2UgdG8gc3RyaW5ncyAob3IgXCJcIiBmb3IgdW5zdXBwb3J0ZWQgdHlwZXMpXG5cblxuICAgIGEgPSB0b1N0cmluZyhhKTtcbiAgICBiID0gdG9TdHJpbmcoYik7IC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG5cbiAgICBhID0gYS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgYiA9IGIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pOyAvLyBXaGlsZVxuXG4gICAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgICB2YXIgYWEgPSBhLnNoaWZ0KCk7XG4gICAgICB2YXIgYmIgPSBiLnNoaWZ0KCk7XG4gICAgICB2YXIgYW4gPSBwYXJzZUludChhYSwgMTApO1xuICAgICAgdmFyIGJuID0gcGFyc2VJbnQoYmIsIDEwKTtcbiAgICAgIHZhciBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTsgLy8gQm90aCBhcmUgc3RyaW5nXG5cbiAgICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcbiAgICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG5cblxuICAgICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xuICAgICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xuICAgICAgfSAvLyBCb3RoIGFyZSBudW1iZXJzXG5cblxuICAgICAgaWYgKGFuID4gYm4pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChibiA+IGFuKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gZGF0ZXRpbWUocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uMiA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uMlswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjJbMV07XG5cbiAgICBhID0gYS5nZXRUaW1lKCk7XG4gICAgYiA9IGIuZ2V0VGltZSgpO1xuICAgIHJldHVybiBjb21wYXJlQmFzaWMoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gYmFzaWMocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uMyA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uM1swXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjNbMV07XG5cbiAgICByZXR1cm4gY29tcGFyZUJhc2ljKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZyhyb3dBLCByb3dCLCBjb2x1bW5JZCkge1xuICAgIHZhciBfZ2V0Um93VmFsdWVzQnlDb2x1bW40ID0gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3dBLCByb3dCLCBjb2x1bW5JZCksXG4gICAgICAgIGEgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW40WzBdLFxuICAgICAgICBiID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNFsxXTtcblxuICAgIGEgPSBhLnNwbGl0KCcnKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgYiA9IGIuc3BsaXQoJycpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgICAgdmFyIGFhID0gYS5zaGlmdCgpO1xuICAgICAgdmFyIGJiID0gYi5zaGlmdCgpO1xuICAgICAgdmFyIGFsb3dlciA9IGFhLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgYmxvd2VyID0gYmIudG9Mb3dlckNhc2UoKTsgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uIHVudGlsIGNoYXJhY3RlcnMgbWF0Y2hcblxuICAgICAgaWYgKGFsb3dlciA+IGJsb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb3dlciA+IGFsb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IC8vIElmIGxvd2VyY2FzZSBjaGFyYWN0ZXJzIGFyZSBpZGVudGljYWxcblxuXG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uNSA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNVswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjVbMV07XG5cbiAgICB2YXIgcmVwbGFjZU5vbk51bWVyaWMgPSAvW14wLTkuXS9naTtcbiAgICBhID0gTnVtYmVyKFN0cmluZyhhKS5yZXBsYWNlKHJlcGxhY2VOb25OdW1lcmljLCAnJykpO1xuICAgIGIgPSBOdW1iZXIoU3RyaW5nKGIpLnJlcGxhY2UocmVwbGFjZU5vbk51bWVyaWMsICcnKSk7XG4gICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhhLCBiKTtcbiAgfSAvLyBVdGlsc1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvdzEsIHJvdzIsIGNvbHVtbklkKSB7XG4gICAgcmV0dXJuIFtyb3cxLnZhbHVlc1tjb2x1bW5JZF0sIHJvdzIudmFsdWVzW2NvbHVtbklkXV07XG4gIH1cblxuICBmdW5jdGlvbiB0b1N0cmluZyhhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHNvcnRUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWxwaGFudW1lcmljOiBhbHBoYW51bWVyaWMsXG4gICAgZGF0ZXRpbWU6IGRhdGV0aW1lLFxuICAgIGJhc2ljOiBiYXNpYyxcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBudW1iZXI6IG51bWJlclxuICB9KTtcblxuICBhY3Rpb25zLnJlc2V0U29ydEJ5ID0gJ3Jlc2V0U29ydEJ5JztcbiAgYWN0aW9ucy5zZXRTb3J0QnkgPSAnc2V0U29ydEJ5JztcbiAgYWN0aW9ucy50b2dnbGVTb3J0QnkgPSAndG9nZ2xlU29ydEJ5JztcbiAgYWN0aW9ucy5jbGVhclNvcnRCeSA9ICdjbGVhclNvcnRCeSc7XG4gIGRlZmF1bHRDb2x1bW4uc29ydFR5cGUgPSAnYWxwaGFudW1lcmljJztcbiAgZGVmYXVsdENvbHVtbi5zb3J0RGVzY0ZpcnN0ID0gZmFsc2U7XG4gIHZhciB1c2VTb3J0QnkgPSBmdW5jdGlvbiB1c2VTb3J0QnkoaG9va3MpIHtcbiAgICBob29rcy5nZXRTb3J0QnlUb2dnbGVQcm9wcyA9IFtkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDUpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNSk7XG4gIH07XG4gIHVzZVNvcnRCeS5wbHVnaW5OYW1lID0gJ3VzZVNvcnRCeSc7XG5cbiAgdmFyIGRlZmF1bHRHZXRTb3J0QnlUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRTb3J0QnlUb2dnbGVQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICAgIGNvbHVtbiA9IF9yZWYuY29sdW1uO1xuICAgIHZhciBfaW5zdGFuY2UkaXNNdWx0aVNvcnQgPSBpbnN0YW5jZS5pc011bHRpU29ydEV2ZW50LFxuICAgICAgICBpc011bHRpU29ydEV2ZW50ID0gX2luc3RhbmNlJGlzTXVsdGlTb3J0ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XG4gICAgfSA6IF9pbnN0YW5jZSRpc011bHRpU29ydDtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBjb2x1bW4uY2FuU29ydCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydEJ5KHVuZGVmaW5lZCwgIWluc3RhbmNlLmRpc2FibGVNdWx0aVNvcnQgJiYgaXNNdWx0aVNvcnRFdmVudChlKSk7XG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiBjb2x1bW4uY2FuU29ydCA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiBjb2x1bW4uY2FuU29ydCA/ICdUb2dnbGUgU29ydEJ5JyA6IHVuZGVmaW5lZFxuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDUoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgc29ydEJ5OiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFNvcnRCeSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzb3J0Qnk6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5zb3J0QnkgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jbGVhclNvcnRCeSkge1xuICAgICAgdmFyIHNvcnRCeSA9IHN0YXRlLnNvcnRCeTtcbiAgICAgIHZhciBuZXdTb3J0QnkgPSBzb3J0QnkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkICE9PSBhY3Rpb24uY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBuZXdTb3J0QnlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRTb3J0QnkpIHtcbiAgICAgIHZhciBfc29ydEJ5ID0gYWN0aW9uLnNvcnRCeTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBfc29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlU29ydEJ5KSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgZGVzYyA9IGFjdGlvbi5kZXNjLFxuICAgICAgICAgIG11bHRpID0gYWN0aW9uLm11bHRpO1xuICAgICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIGRpc2FibGVNdWx0aVNvcnQgPSBpbnN0YW5jZS5kaXNhYmxlTXVsdGlTb3J0LFxuICAgICAgICAgIGRpc2FibGVTb3J0UmVtb3ZlID0gaW5zdGFuY2UuZGlzYWJsZVNvcnRSZW1vdmUsXG4gICAgICAgICAgZGlzYWJsZU11bHRpUmVtb3ZlID0gaW5zdGFuY2UuZGlzYWJsZU11bHRpUmVtb3ZlLFxuICAgICAgICAgIF9pbnN0YW5jZSRtYXhNdWx0aVNvciA9IGluc3RhbmNlLm1heE11bHRpU29ydENvbENvdW50LFxuICAgICAgICAgIG1heE11bHRpU29ydENvbENvdW50ID0gX2luc3RhbmNlJG1heE11bHRpU29yID09PSB2b2lkIDAgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IF9pbnN0YW5jZSRtYXhNdWx0aVNvcjtcbiAgICAgIHZhciBfc29ydEJ5MiA9IHN0YXRlLnNvcnRCeTsgLy8gRmluZCB0aGUgY29sdW1uIGZvciB0aGlzIGNvbHVtbklkXG5cbiAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydERlc2NGaXJzdCA9IGNvbHVtbi5zb3J0RGVzY0ZpcnN0OyAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0QnkgZm9yIHRoaXMgY29sdW1uXG5cbiAgICAgIHZhciBleGlzdGluZ1NvcnRCeSA9IF9zb3J0QnkyLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBleGlzdGluZ0luZGV4ID0gX3NvcnRCeTIuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGFzRGVzY0RlZmluZWQgPSB0eXBlb2YgZGVzYyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzYyAhPT0gbnVsbDtcbiAgICAgIHZhciBfbmV3U29ydEJ5ID0gW107IC8vIFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdGhpcyBzb3J0IGFjdGlvbj9cblxuICAgICAgdmFyIHNvcnRBY3Rpb247XG5cbiAgICAgIGlmICghZGlzYWJsZU11bHRpU29ydCAmJiBtdWx0aSkge1xuICAgICAgICBpZiAoZXhpc3RpbmdTb3J0QnkpIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICdhZGQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gX3NvcnRCeTIubGVuZ3RoIC0gMSB8fCBfc29ydEJ5Mi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydEJ5KSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydEJ5XG5cblxuICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnICYmIC8vIE11c3QgYmUgdG9nZ2xpbmdcbiAgICAgICFkaXNhYmxlU29ydFJlbW92ZSAmJiAvLyBJZiBkaXNhYmxlU29ydFJlbW92ZSwgZGlzYWJsZSBpbiBnZW5lcmFsXG4gICAgICAhaGFzRGVzY0RlZmluZWQgJiYgKCAvLyBNdXN0IG5vdCBiZSBzZXR0aW5nIGRlc2NcbiAgICAgIG11bHRpID8gIWRpc2FibGVNdWx0aVJlbW92ZSA6IHRydWUpICYmICggLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGRpc2FibGVNdWx0aVJlbW92ZVxuICAgICAgZXhpc3RpbmdTb3J0QnkgJiYgLy8gRmluYWxseSwgZGV0ZWN0IGlmIGl0IHNob3VsZCBpbmRlZWQgYmUgcmVtb3ZlZFxuICAgICAgZXhpc3RpbmdTb3J0QnkuZGVzYyAmJiAhc29ydERlc2NGaXJzdCB8fCAhZXhpc3RpbmdTb3J0QnkuZGVzYyAmJiBzb3J0RGVzY0ZpcnN0KSkge1xuICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0QWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgX25ld1NvcnRCeSA9IFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGRlc2M6IGhhc0Rlc2NEZWZpbmVkID8gZGVzYyA6IHNvcnREZXNjRmlyc3RcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgIF9uZXdTb3J0QnkgPSBbXS5jb25jYXQoX3NvcnRCeTIsIFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGRlc2M6IGhhc0Rlc2NEZWZpbmVkID8gZGVzYyA6IHNvcnREZXNjRmlyc3RcbiAgICAgICAgfV0pOyAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcblxuICAgICAgICBfbmV3U29ydEJ5LnNwbGljZSgwLCBfbmV3U29ydEJ5Lmxlbmd0aCAtIG1heE11bHRpU29ydENvbENvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXG4gICAgICAgIF9uZXdTb3J0QnkgPSBfc29ydEJ5Mi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZCwge1xuICAgICAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiAhZXhpc3RpbmdTb3J0QnkuZGVzY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICBfbmV3U29ydEJ5ID0gX3NvcnRCeTIuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzb3J0Qnk6IF9uZXdTb3J0QnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDUoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IGluc3RhbmNlLmZsYXRSb3dzLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgX2luc3RhbmNlJG9yZGVyQnlGbiA9IGluc3RhbmNlLm9yZGVyQnlGbixcbiAgICAgICAgb3JkZXJCeUZuID0gX2luc3RhbmNlJG9yZGVyQnlGbiA9PT0gdm9pZCAwID8gZGVmYXVsdE9yZGVyQnlGbiA6IF9pbnN0YW5jZSRvcmRlckJ5Rm4sXG4gICAgICAgIHVzZXJTb3J0VHlwZXMgPSBpbnN0YW5jZS5zb3J0VHlwZXMsXG4gICAgICAgIG1hbnVhbFNvcnRCeSA9IGluc3RhbmNlLm1hbnVhbFNvcnRCeSxcbiAgICAgICAgZGVmYXVsdENhblNvcnQgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuU29ydCxcbiAgICAgICAgZGlzYWJsZVNvcnRCeSA9IGluc3RhbmNlLmRpc2FibGVTb3J0QnksXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIHNvcnRCeSA9IGluc3RhbmNlLnN0YXRlLnNvcnRCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRTbyA9IGluc3RhbmNlLmF1dG9SZXNldFNvcnRCeSxcbiAgICAgICAgYXV0b1Jlc2V0U29ydEJ5ID0gX2luc3RhbmNlJGF1dG9SZXNldFNvID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldFNvO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlRmlsdGVycycsICd1c2VHbG9iYWxGaWx0ZXInLCAndXNlR3JvdXBCeScsICd1c2VQaXZvdENvbHVtbnMnXSwgJ3VzZVNvcnRCeScpO1xuICAgIHZhciBzZXRTb3J0QnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoc29ydEJ5KSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0U29ydEJ5LFxuICAgICAgICBzb3J0Qnk6IHNvcnRCeVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7IC8vIFVwZGF0ZXMgc29ydGluZyBiYXNlZCBvbiBhIGNvbHVtbklkLCBkZXNjIGZsYWcgYW5kIG11bHRpIGZsYWdcblxuICAgIHZhciB0b2dnbGVTb3J0QnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIGRlc2MsIG11bHRpKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlU29ydEJ5LFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIGRlc2M6IGRlc2MsXG4gICAgICAgIG11bHRpOiBtdWx0aVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7IC8vIHVzZSByZWZlcmVuY2UgdG8gYXZvaWQgbWVtb3J5IGxlYWsgaW4gIzE2MDhcblxuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZSk7IC8vIEFkZCB0aGUgZ2V0U29ydEJ5VG9nZ2xlUHJvcHMgbWV0aG9kIHRvIGNvbHVtbnMgYW5kIGhlYWRlcnNcblxuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5DYW5Tb3J0ID0gY29sdW1uLmNhblNvcnQsXG4gICAgICAgICAgY29sdW1uRGlzYWJsZVNvcnRCeSA9IGNvbHVtbi5kaXNhYmxlU29ydEJ5LFxuICAgICAgICAgIGlkID0gY29sdW1uLmlkO1xuICAgICAgdmFyIGNhblNvcnQgPSBhY2Nlc3NvciA/IGdldEZpcnN0RGVmaW5lZChjb2x1bW5EaXNhYmxlU29ydEJ5ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVTb3J0QnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoZGVmYXVsdENhblNvcnQsIGRlZmF1bHRDb2x1bW5DYW5Tb3J0LCBmYWxzZSk7XG4gICAgICBjb2x1bW4uY2FuU29ydCA9IGNhblNvcnQ7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuU29ydCkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydEJ5ID0gZnVuY3Rpb24gKGRlc2MsIG11bHRpKSB7XG4gICAgICAgICAgcmV0dXJuIHRvZ2dsZVNvcnRCeShjb2x1bW4uaWQsIGRlc2MsIG11bHRpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb2x1bW4uY2xlYXJTb3J0QnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogYWN0aW9ucy5jbGVhclNvcnRCeSxcbiAgICAgICAgICAgIGNvbHVtbklkOiBjb2x1bW4uaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29sdW1uLmdldFNvcnRCeVRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRTb3J0QnlUb2dnbGVQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbHVtblNvcnQgPSBzb3J0QnkuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGNvbHVtbi5pc1NvcnRlZCA9ICEhY29sdW1uU29ydDtcbiAgICAgIGNvbHVtbi5zb3J0ZWRJbmRleCA9IHNvcnRCeS5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uaXNTb3J0ZWREZXNjID0gY29sdW1uLmlzU29ydGVkID8gY29sdW1uU29ydC5kZXNjIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWFudWFsU29ydEJ5IHx8ICFzb3J0QnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3NdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc29ydGVkRmxhdFJvd3MgPSBbXTsgLy8gRmlsdGVyIG91dCBzb3J0QnlzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuXG4gICAgICB2YXIgYXZhaWxhYmxlU29ydEJ5ID0gc29ydEJ5LmZpbHRlcihmdW5jdGlvbiAoc29ydCkge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICByZXR1cm4gY29sLmlkID09PSBzb3J0LmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydERhdGEgPSBmdW5jdGlvbiBzb3J0RGF0YShyb3dzKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgb3JkZXJCeUZuIHRvIGNvbXBvc2UgbXVsdGlwbGUgc29ydEJ5J3MgdG9nZXRoZXIuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgICAgdmFyIHNvcnRlZERhdGEgPSBvcmRlckJ5Rm4ocm93cywgYXZhaWxhYmxlU29ydEJ5Lm1hcChmdW5jdGlvbiAoc29ydCkge1xuICAgICAgICAgIC8vIFN1cHBvcnQgY3VzdG9tIHNvcnRpbmcgbWV0aG9kcyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC1UYWJsZTogQ291bGQgbm90IGZpbmQgYSBjb2x1bW4gd2l0aCBpZDogXCIgKyBzb3J0LmlkICsgXCIgd2hpbGUgc29ydGluZ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc29ydFR5cGUgPSBjb2x1bW4uc29ydFR5cGU7IC8vIExvb2sgdXAgc29ydEJ5IGZ1bmN0aW9ucyBpbiB0aGlzIG9yZGVyOlxuICAgICAgICAgIC8vIGNvbHVtbiBmdW5jdGlvblxuICAgICAgICAgIC8vIGNvbHVtbiBzdHJpbmcgbG9va3VwIG9uIHVzZXIgc29ydFR5cGVcbiAgICAgICAgICAvLyBjb2x1bW4gc3RyaW5nIGxvb2t1cCBvbiBidWlsdC1pbiBzb3J0VHlwZVxuICAgICAgICAgIC8vIGRlZmF1bHQgZnVuY3Rpb25cbiAgICAgICAgICAvLyBkZWZhdWx0IHN0cmluZyBsb29rdXAgb24gdXNlciBzb3J0VHlwZVxuICAgICAgICAgIC8vIGRlZmF1bHQgc3RyaW5nIGxvb2t1cCBvbiBidWlsdC1pbiBzb3J0VHlwZVxuXG4gICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSBpc0Z1bmN0aW9uKHNvcnRUeXBlKSB8fCAodXNlclNvcnRUeXBlcyB8fCB7fSlbc29ydFR5cGVdIHx8IHNvcnRUeXBlc1tzb3J0VHlwZV07XG5cbiAgICAgICAgICBpZiAoIXNvcnRNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LVRhYmxlOiBDb3VsZCBub3QgZmluZCBhIHZhbGlkIHNvcnRUeXBlIG9mICdcIiArIHNvcnRUeXBlICsgXCInIGZvciBjb2x1bW4gJ1wiICsgc29ydC5pZCArIFwiJy5cIik7XG4gICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGNvcnJlY3Qgc29ydEZuLlxuICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXG5cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRNZXRob2QoYSwgYiwgc29ydC5pZCwgc29ydC5kZXNjKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSwgLy8gTWFwIHRoZSBkaXJlY3Rpb25zXG4gICAgICAgIGF2YWlsYWJsZVNvcnRCeS5tYXAoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgICAvLyBEZXRlY3QgYW5kIHVzZSB0aGUgc29ydEludmVydGVkIG9wdGlvblxuICAgICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkID09PSBzb3J0LmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uc29ydEludmVydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydC5kZXNjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhc29ydC5kZXNjO1xuICAgICAgICB9KSk7IC8vIElmIHRoZXJlIGFyZSBzdWItcm93cywgc29ydCB0aGVtXG5cbiAgICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBzb3J0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgICBpZiAoIXJvdy5zdWJSb3dzIHx8IHJvdy5zdWJSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc29ydERhdGEocm93LnN1YlJvd3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gW3NvcnREYXRhKHJvd3MpLCBzb3J0ZWRGbGF0Um93c107XG4gICAgfSwgW21hbnVhbFNvcnRCeSwgc29ydEJ5LCByb3dzLCBmbGF0Um93cywgYWxsQ29sdW1ucywgb3JkZXJCeUZuLCB1c2VyU29ydFR5cGVzXSksXG4gICAgICAgIHNvcnRlZFJvd3MgPSBfUmVhY3QkdXNlTWVtb1swXSxcbiAgICAgICAgc29ydGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRTb3J0QnkgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0U29ydEJ5KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRTb3J0QnkoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFNvcnRCeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbbWFudWFsU29ydEJ5ID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVTb3J0ZWRSb3dzOiByb3dzLFxuICAgICAgcHJlU29ydGVkRmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgc29ydGVkUm93czogc29ydGVkUm93cyxcbiAgICAgIHNvcnRlZEZsYXRSb3dzOiBzb3J0ZWRGbGF0Um93cyxcbiAgICAgIHJvd3M6IHNvcnRlZFJvd3MsXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICBzZXRTb3J0Qnk6IHNldFNvcnRCeSxcbiAgICAgIHRvZ2dsZVNvcnRCeTogdG9nZ2xlU29ydEJ5XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0T3JkZXJCeUZuKGFyciwgZnVuY3MsIGRpcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGFycikuc29ydChmdW5jdGlvbiAocm93QSwgcm93Qikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc29ydEZuID0gZnVuY3NbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGlyc1tpXSA9PT0gZmFsc2UgfHwgZGlyc1tpXSA9PT0gJ2Rlc2MnO1xuICAgICAgICB2YXIgc29ydEludCA9IHNvcnRGbihyb3dBLCByb3dCKTtcblxuICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBkZXNjID8gLXNvcnRJbnQgOiBzb3J0SW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJzWzBdID8gcm93QS5pbmRleCAtIHJvd0IuaW5kZXggOiByb3dCLmluZGV4IC0gcm93QS5pbmRleDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwbHVnaW5OYW1lID0gJ3VzZVBhZ2luYXRpb24nOyAvLyBBY3Rpb25zXG5cbiAgYWN0aW9ucy5yZXNldFBhZ2UgPSAncmVzZXRQYWdlJztcbiAgYWN0aW9ucy5nb3RvUGFnZSA9ICdnb3RvUGFnZSc7XG4gIGFjdGlvbnMuc2V0UGFnZVNpemUgPSAnc2V0UGFnZVNpemUnO1xuICB2YXIgdXNlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIHVzZVBhZ2luYXRpb24oaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ2KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDYpO1xuICB9O1xuICB1c2VQYWdpbmF0aW9uLnBsdWdpbk5hbWUgPSBwbHVnaW5OYW1lO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNihzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICAgIHBhZ2VJbmRleDogMFxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFBhZ2UpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucGFnZUluZGV4IHx8IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5nb3RvUGFnZSkge1xuICAgICAgdmFyIHBhZ2VDb3VudCA9IGluc3RhbmNlLnBhZ2VDb3VudCxcbiAgICAgICAgICBwYWdlID0gaW5zdGFuY2UucGFnZTtcbiAgICAgIHZhciBuZXdQYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKGFjdGlvbi5wYWdlSW5kZXgsIHN0YXRlLnBhZ2VJbmRleCk7XG4gICAgICB2YXIgY2FuTmF2aWdhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKG5ld1BhZ2VJbmRleCA+IHN0YXRlLnBhZ2VJbmRleCkge1xuICAgICAgICAvLyBuZXh0IHBhZ2VcbiAgICAgICAgY2FuTmF2aWdhdGUgPSBwYWdlQ291bnQgPT09IC0xID8gcGFnZS5sZW5ndGggPj0gc3RhdGUucGFnZVNpemUgOiBuZXdQYWdlSW5kZXggPCBwYWdlQ291bnQ7XG4gICAgICB9IGVsc2UgaWYgKG5ld1BhZ2VJbmRleCA8IHN0YXRlLnBhZ2VJbmRleCkge1xuICAgICAgICAvLyBwcmV2IHBhZ2VcbiAgICAgICAgY2FuTmF2aWdhdGUgPSBuZXdQYWdlSW5kZXggPiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5OYXZpZ2F0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBuZXdQYWdlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRQYWdlU2l6ZSkge1xuICAgICAgdmFyIHBhZ2VTaXplID0gYWN0aW9uLnBhZ2VTaXplO1xuICAgICAgdmFyIHRvcFJvd0luZGV4ID0gc3RhdGUucGFnZVNpemUgKiBzdGF0ZS5wYWdlSW5kZXg7XG4gICAgICB2YXIgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNihpbnN0YW5jZSkge1xuICAgIHZhciByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFBhID0gaW5zdGFuY2UuYXV0b1Jlc2V0UGFnZSxcbiAgICAgICAgYXV0b1Jlc2V0UGFnZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRQYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRQYSxcbiAgICAgICAgX2luc3RhbmNlJG1hbnVhbEV4cGFuID0gaW5zdGFuY2UubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbEV4cGFuID09PSB2b2lkIDAgPyAnZXhwYW5kZWQnIDogX2luc3RhbmNlJG1hbnVhbEV4cGFuLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgdXNlclBhZ2VDb3VudCA9IGluc3RhbmNlLnBhZ2VDb3VudCxcbiAgICAgICAgX2luc3RhbmNlJHBhZ2luYXRlRXhwID0gaW5zdGFuY2UucGFnaW5hdGVFeHBhbmRlZFJvd3MsXG4gICAgICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzID0gX2luc3RhbmNlJHBhZ2luYXRlRXhwID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHBhZ2luYXRlRXhwLFxuICAgICAgICBfaW5zdGFuY2UkZXhwYW5kU3ViUm8gPSBpbnN0YW5jZS5leHBhbmRTdWJSb3dzLFxuICAgICAgICBleHBhbmRTdWJSb3dzID0gX2luc3RhbmNlJGV4cGFuZFN1YlJvID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGV4cGFuZFN1YlJvLFxuICAgICAgICBfaW5zdGFuY2Ukc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgcGFnZVNpemUgPSBfaW5zdGFuY2Ukc3RhdGUucGFnZVNpemUsXG4gICAgICAgIHBhZ2VJbmRleCA9IF9pbnN0YW5jZSRzdGF0ZS5wYWdlSW5kZXgsXG4gICAgICAgIGV4cGFuZGVkID0gX2luc3RhbmNlJHN0YXRlLmV4cGFuZGVkLFxuICAgICAgICBnbG9iYWxGaWx0ZXIgPSBfaW5zdGFuY2Ukc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBmaWx0ZXJzID0gX2luc3RhbmNlJHN0YXRlLmZpbHRlcnMsXG4gICAgICAgIGdyb3VwQnkgPSBfaW5zdGFuY2Ukc3RhdGUuZ3JvdXBCeSxcbiAgICAgICAgc29ydEJ5ID0gX2luc3RhbmNlJHN0YXRlLnNvcnRCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIG1hbnVhbFBhZ2luYXRpb24gPSBpbnN0YW5jZS5tYW51YWxQYWdpbmF0aW9uO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlR2xvYmFsRmlsdGVyJywgJ3VzZUZpbHRlcnMnLCAndXNlR3JvdXBCeScsICd1c2VTb3J0QnknLCAndXNlRXhwYW5kZWQnXSwgJ3VzZVBhZ2luYXRpb24nKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0UGFnZSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRQYWdlKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRQYWdlKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRQYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsUGFnaW5hdGlvbiA/IG51bGwgOiBkYXRhLCBnbG9iYWxGaWx0ZXIsIGZpbHRlcnMsIGdyb3VwQnksIHNvcnRCeV0pO1xuICAgIHZhciBwYWdlQ291bnQgPSBtYW51YWxQYWdpbmF0aW9uID8gdXNlclBhZ2VDb3VudCA6IE1hdGguY2VpbChyb3dzLmxlbmd0aCAvIHBhZ2VTaXplKTtcbiAgICB2YXIgcGFnZU9wdGlvbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwYWdlQ291bnQgPiAwID8gW10uY29uY2F0KG5ldyBBcnJheShwYWdlQ291bnQpKS5maWxsKG51bGwpLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pIDogW107XG4gICAgfSwgW3BhZ2VDb3VudF0pO1xuICAgIHZhciBwYWdlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFnZTtcblxuICAgICAgaWYgKG1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgcGFnZSA9IHJvd3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFnZVN0YXJ0ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG4gICAgICAgIHZhciBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XG4gICAgICAgIHBhZ2UgPSByb3dzLnNsaWNlKHBhZ2VTdGFydCwgcGFnZUVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cGFuZFJvd3MocGFnZSwge1xuICAgICAgICBtYW51YWxFeHBhbmRlZEtleTogbWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZCxcbiAgICAgICAgZXhwYW5kU3ViUm93czogZXhwYW5kU3ViUm93c1xuICAgICAgfSk7XG4gICAgfSwgW2V4cGFuZFN1YlJvd3MsIGV4cGFuZGVkLCBtYW51YWxFeHBhbmRlZEtleSwgbWFudWFsUGFnaW5hdGlvbiwgcGFnZUluZGV4LCBwYWdlU2l6ZSwgcGFnaW5hdGVFeHBhbmRlZFJvd3MsIHJvd3NdKTtcbiAgICB2YXIgY2FuUHJldmlvdXNQYWdlID0gcGFnZUluZGV4ID4gMDtcbiAgICB2YXIgY2FuTmV4dFBhZ2UgPSBwYWdlQ291bnQgPT09IC0xID8gcGFnZS5sZW5ndGggPj0gcGFnZVNpemUgOiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIHZhciBnb3RvUGFnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5nb3RvUGFnZSxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXhcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBwcmV2aW91c1BhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ290b1BhZ2UoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICByZXR1cm4gb2xkIC0gMTtcbiAgICAgIH0pO1xuICAgIH0sIFtnb3RvUGFnZV0pO1xuICAgIHZhciBuZXh0UGFnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnb3RvUGFnZShmdW5jdGlvbiAob2xkKSB7XG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xuICAgICAgfSk7XG4gICAgfSwgW2dvdG9QYWdlXSk7XG4gICAgdmFyIHNldFBhZ2VTaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhZ2VTaXplKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0UGFnZVNpemUsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcGFnZU9wdGlvbnM6IHBhZ2VPcHRpb25zLFxuICAgICAgcGFnZUNvdW50OiBwYWdlQ291bnQsXG4gICAgICBwYWdlOiBwYWdlLFxuICAgICAgY2FuUHJldmlvdXNQYWdlOiBjYW5QcmV2aW91c1BhZ2UsXG4gICAgICBjYW5OZXh0UGFnZTogY2FuTmV4dFBhZ2UsXG4gICAgICBnb3RvUGFnZTogZ290b1BhZ2UsXG4gICAgICBwcmV2aW91c1BhZ2U6IHByZXZpb3VzUGFnZSxcbiAgICAgIG5leHRQYWdlOiBuZXh0UGFnZSxcbiAgICAgIHNldFBhZ2VTaXplOiBzZXRQYWdlU2l6ZVxuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldFBpdm90ID0gJ3Jlc2V0UGl2b3QnO1xuICBhY3Rpb25zLnRvZ2dsZVBpdm90ID0gJ3RvZ2dsZVBpdm90JztcbiAgdmFyIF9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMgPSBmdW5jdGlvbiBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0UGl2b3RUb2dnbGVQcm9wcyA9IFtkZWZhdWx0R2V0UGl2b3RUb2dnbGVQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2VBZnRlckRhdGEucHVzaCh1c2VJbnN0YW5jZUFmdGVyRGF0YSk7XG4gICAgaG9va3MuYWxsQ29sdW1ucy5wdXNoKGFsbENvbHVtbnMpO1xuICAgIGhvb2tzLmFjY2Vzc1ZhbHVlLnB1c2goYWNjZXNzVmFsdWUpO1xuICAgIGhvb2tzLm1hdGVyaWFsaXplZENvbHVtbnMucHVzaChtYXRlcmlhbGl6ZWRDb2x1bW5zKTtcbiAgICBob29rcy5tYXRlcmlhbGl6ZWRDb2x1bW5zRGVwcy5wdXNoKG1hdGVyaWFsaXplZENvbHVtbnNEZXBzKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1ucy5wdXNoKHZpc2libGVDb2x1bW5zJDEpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKHZpc2libGVDb2x1bW5zRGVwcyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ3KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQyKTtcbiAgfTtcbiAgX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucy5wbHVnaW5OYW1lID0gJ3VzZVBpdm90Q29sdW1ucyc7XG4gIHZhciBkZWZhdWx0UGl2b3RDb2x1bW5zID0gW107XG5cbiAgdmFyIGRlZmF1bHRHZXRQaXZvdFRvZ2dsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFBpdm90VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaGVhZGVyID0gX3JlZi5oZWFkZXI7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogaGVhZGVyLmNhblBpdm90ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgIGhlYWRlci50b2dnbGVQaXZvdCgpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogaGVhZGVyLmNhblBpdm90ID8gJ3BvaW50ZXInIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUGl2b3QnXG4gICAgfV07XG4gIH07IC8vIFJlZHVjZXJcblxuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBwaXZvdENvbHVtbnM6IGRlZmF1bHRQaXZvdENvbHVtbnNcbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRQaXZvdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBwaXZvdENvbHVtbnM6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5waXZvdENvbHVtbnMgfHwgZGVmYXVsdFBpdm90Q29sdW1uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVBpdm90KSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgc2V0UGl2b3QgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgcmVzb2x2ZWRQaXZvdCA9IHR5cGVvZiBzZXRQaXZvdCAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRQaXZvdCA6ICFzdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uSWQpO1xuXG4gICAgICBpZiAocmVzb2x2ZWRQaXZvdCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgcGl2b3RDb2x1bW5zOiBbXS5jb25jYXQoc3RhdGUucGl2b3RDb2x1bW5zLCBbY29sdW1uSWRdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBwaXZvdENvbHVtbnM6IHN0YXRlLnBpdm90Q29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZCAhPT0gY29sdW1uSWQ7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZUFmdGVyRGF0YShpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNQaXZvdFNvdXJjZSA9IGluc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsQ29sdW1ucyhjb2x1bW5zLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNQaXZvdFNvdXJjZSA9IGluc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgY29sdW1uLnVuaXF1ZVZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2Vzc1ZhbHVlKHZhbHVlLCBfcmVmMykge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG5cbiAgICBpZiAoY29sdW1uLnVuaXF1ZVZhbHVlcyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2x1bW4udW5pcXVlVmFsdWVzLmFkZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0ZXJpYWxpemVkQ29sdW1ucyhtYXRlcmlhbGl6ZWQsIF9yZWY0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjQuaW5zdGFuY2U7XG4gICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKCFzdGF0ZS5waXZvdENvbHVtbnMubGVuZ3RoIHx8ICFzdGF0ZS5ncm91cEJ5IHx8ICFzdGF0ZS5ncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1hdGVyaWFsaXplZDtcbiAgICB9XG5cbiAgICB2YXIgcGl2b3RDb2x1bW5zID0gc3RhdGUucGl2b3RDb2x1bW5zLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHZhciBzb3VyY2VDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAhZC5pc1Bpdm90U291cmNlICYmICFzdGF0ZS5ncm91cEJ5LmluY2x1ZGVzKGQuaWQpICYmICFzdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoZC5pZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgYnVpbGRQaXZvdENvbHVtbnMgPSBmdW5jdGlvbiBidWlsZFBpdm90Q29sdW1ucyhkZXB0aCwgcGFyZW50LCBwaXZvdEZpbHRlcnMpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpdm90RmlsdGVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBpdm90RmlsdGVycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGl2b3RDb2x1bW4gPSBwaXZvdENvbHVtbnNbZGVwdGhdO1xuXG4gICAgICBpZiAoIXBpdm90Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VDb2x1bW5zLm1hcChmdW5jdGlvbiAoc291cmNlQ29sdW1uKSB7XG4gICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgb2ZmZXIgc3VwcG9ydCBoZXJlIGZvciByZW5lc3RpbmcgcGl2b3RlZFxuICAgICAgICAgIC8vIGNvbHVtbnMgaW5zaWRlIGNvcGllcyBvZiB0aGVpciBoZWFkZXIgZ3JvdXBzLiBGb3Igbm93LFxuICAgICAgICAgIC8vIHRoYXQgc2VlbXMgbGlrZSBpdCB3b3VsZCBiZSAoMSkgb3ZlcmtpbGwgb24gbmVzdGluZywgY29uc2lkZXJpbmdcbiAgICAgICAgICAvLyB5b3UgYWxyZWFkeSBnZXQgbmVzdGluZyBmb3IgZXZlcnkgcGl2b3QgbGV2ZWwgYW5kICgyKVxuICAgICAgICAgIC8vIHJlYWxseSBoYXJkLiA6KVxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc291cmNlQ29sdW1uLCB7XG4gICAgICAgICAgICBjYW5QaXZvdDogZmFsc2UsXG4gICAgICAgICAgICBpc1Bpdm90ZWQ6IHRydWUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgIGlkOiBcIlwiICsgKHBhcmVudCA/IHBhcmVudC5pZCArIFwiLlwiICsgc291cmNlQ29sdW1uLmlkIDogc291cmNlQ29sdW1uLmlkKSxcbiAgICAgICAgICAgIGFjY2Vzc29yOiBmdW5jdGlvbiBhY2Nlc3NvcihvcmlnaW5hbFJvdywgaSwgcm93KSB7XG4gICAgICAgICAgICAgIGlmIChwaXZvdEZpbHRlcnMuZXZlcnkoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIocm93KTtcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1tzb3VyY2VDb2x1bW4uaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdW5pcXVlVmFsdWVzID0gQXJyYXkuZnJvbShwaXZvdENvbHVtbi51bmlxdWVWYWx1ZXMpLnNvcnQoKTtcbiAgICAgIHJldHVybiB1bmlxdWVWYWx1ZXMubWFwKGZ1bmN0aW9uICh1bmlxdWVWYWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uR3JvdXAgPSBfZXh0ZW5kcyh7fSwgcGl2b3RDb2x1bW4sIHtcbiAgICAgICAgICBIZWFkZXI6IHBpdm90Q29sdW1uLlBpdm90SGVhZGVyIHx8IHR5cGVvZiBwaXZvdENvbHVtbi5oZWFkZXIgPT09ICdzdHJpbmcnID8gcGl2b3RDb2x1bW4uSGVhZGVyICsgXCI6IFwiICsgdW5pcXVlVmFsdWUgOiB1bmlxdWVWYWx1ZSxcbiAgICAgICAgICBpc1Bpdm90R3JvdXA6IHRydWUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgIGlkOiBwYXJlbnQgPyBwYXJlbnQuaWQgKyBcIi5cIiArIHBpdm90Q29sdW1uLmlkICsgXCIuXCIgKyB1bmlxdWVWYWx1ZSA6IHBpdm90Q29sdW1uLmlkICsgXCIuXCIgKyB1bmlxdWVWYWx1ZSxcbiAgICAgICAgICBwaXZvdFZhbHVlOiB1bmlxdWVWYWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb2x1bW5Hcm91cC5jb2x1bW5zID0gYnVpbGRQaXZvdENvbHVtbnMoZGVwdGggKyAxLCBjb2x1bW5Hcm91cCwgW10uY29uY2F0KHBpdm90RmlsdGVycywgW2Z1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1twaXZvdENvbHVtbi5pZF0gPT09IHVuaXF1ZVZhbHVlO1xuICAgICAgICB9XSkpO1xuICAgICAgICByZXR1cm4gY29sdW1uR3JvdXA7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG5ld01hdGVyaWFsaXplZCA9IGZsYXR0ZW5Db2x1bW5zKGJ1aWxkUGl2b3RDb2x1bW5zKCkpO1xuICAgIHJldHVybiBbXS5jb25jYXQobWF0ZXJpYWxpemVkLCBuZXdNYXRlcmlhbGl6ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0ZXJpYWxpemVkQ29sdW1uc0RlcHMoZGVwcywgX3JlZjUpIHtcbiAgICB2YXIgX3JlZjUkaW5zdGFuY2Ukc3RhdGUgPSBfcmVmNS5pbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgcGl2b3RDb2x1bW5zID0gX3JlZjUkaW5zdGFuY2Ukc3RhdGUucGl2b3RDb2x1bW5zLFxuICAgICAgICBncm91cEJ5ID0gX3JlZjUkaW5zdGFuY2Ukc3RhdGUuZ3JvdXBCeTtcbiAgICByZXR1cm4gW10uY29uY2F0KGRlcHMsIFtwaXZvdENvbHVtbnMsIGdyb3VwQnldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zJDEodmlzaWJsZUNvbHVtbnMsIF9yZWY2KSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjYuaW5zdGFuY2Uuc3RhdGU7XG4gICAgdmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAhZC5pc1Bpdm90U291cmNlO1xuICAgIH0pO1xuXG4gICAgaWYgKHN0YXRlLnBpdm90Q29sdW1ucy5sZW5ndGggJiYgc3RhdGUuZ3JvdXBCeSAmJiBzdGF0ZS5ncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgdmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uLmlzR3JvdXBlZCB8fCBjb2x1bW4uaXNQaXZvdGVkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2libGVDb2x1bW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZUNvbHVtbnNEZXBzKGRlcHMsIF9yZWY3KSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjcuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUucGl2b3RDb2x1bW5zLCBpbnN0YW5jZS5zdGF0ZS5ncm91cEJ5XSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ3KGluc3RhbmNlKSB7XG4gICAgdmFyIGNvbHVtbnMgPSBpbnN0YW5jZS5jb2x1bW5zLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRQaSA9IGluc3RhbmNlLmF1dG9SZXNldFBpdm90LFxuICAgICAgICBhdXRvUmVzZXRQaXZvdCA9IF9pbnN0YW5jZSRhdXRvUmVzZXRQaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRQaSxcbiAgICAgICAgbWFuYXVsUGl2b3QgPSBpbnN0YW5jZS5tYW5hdWxQaXZvdCxcbiAgICAgICAgZGlzYWJsZVBpdm90ID0gaW5zdGFuY2UuZGlzYWJsZVBpdm90LFxuICAgICAgICBkZWZhdWx0Q2FuUGl2b3QgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuUGl2b3Q7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VHcm91cEJ5J10sICd1c2VQaXZvdENvbHVtbnMnKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgZGVmYXVsdENvbHVtblBpdm90ID0gY29sdW1uLmRlZmF1bHRQaXZvdCxcbiAgICAgICAgICBjb2x1bW5EaXNhYmxlUGl2b3QgPSBjb2x1bW4uZGlzYWJsZVBpdm90O1xuICAgICAgY29sdW1uLmNhblBpdm90ID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uLmNhblBpdm90LCBjb2x1bW5EaXNhYmxlUGl2b3QgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZVBpdm90ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5QaXZvdCwgZGVmYXVsdENvbHVtblBpdm90LCBkZWZhdWx0Q2FuUGl2b3QsIGZhbHNlKTtcblxuICAgICAgaWYgKGNvbHVtbi5jYW5QaXZvdCkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlUGl2b3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVBpdm90KGNvbHVtbi5pZCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi5BZ2dyZWdhdGVkID0gY29sdW1uLkFnZ3JlZ2F0ZWQgfHwgY29sdW1uLkNlbGw7XG4gICAgfSk7XG5cbiAgICB2YXIgdG9nZ2xlUGl2b3QgPSBmdW5jdGlvbiB0b2dnbGVQaXZvdChjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVQaXZvdCxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIGhlYWRlci5nZXRQaXZvdFRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRQaXZvdFRvZ2dsZVByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGdldEF1dG9SZXNldFBpdm90ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFBpdm90KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRQaXZvdCgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0UGl2b3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW5hdWxQaXZvdCA/IG51bGwgOiBjb2x1bW5zXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgdG9nZ2xlUGl2b3Q6IHRvZ2dsZVBpdm90XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDIocm93KSB7XG4gICAgcm93LmFsbENlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIC8vIEdyb3VwZWQgY2VsbHMgYXJlIGluIHRoZSBwaXZvdENvbHVtbnMgYW5kIHRoZSBwaXZvdCBjZWxsIGZvciB0aGUgcm93XG4gICAgICBjZWxsLmlzUGl2b3RlZCA9IGNlbGwuY29sdW1uLmlzUGl2b3RlZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwbHVnaW5OYW1lJDEgPSAndXNlUm93U2VsZWN0JzsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRTZWxlY3RlZFJvd3MgPSAncmVzZXRTZWxlY3RlZFJvd3MnO1xuICBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9ICd0b2dnbGVBbGxSb3dzU2VsZWN0ZWQnO1xuICBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkID0gJ3RvZ2dsZVJvd1NlbGVjdGVkJztcbiAgYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gJ3RvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQnO1xuICB2YXIgdXNlUm93U2VsZWN0ID0gZnVuY3Rpb24gdXNlUm93U2VsZWN0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzXTtcbiAgICBob29rcy5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkOCk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ4KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQzKTtcbiAgfTtcbiAgdXNlUm93U2VsZWN0LnBsdWdpbk5hbWUgPSBwbHVnaW5OYW1lJDE7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICByb3cgPSBfcmVmLnJvdztcbiAgICB2YXIgX2luc3RhbmNlJG1hbnVhbFJvd1NlID0gaW5zdGFuY2UubWFudWFsUm93U2VsZWN0ZWRLZXksXG4gICAgICAgIG1hbnVhbFJvd1NlbGVjdGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbFJvd1NlID09PSB2b2lkIDAgPyAnaXNTZWxlY3RlZCcgOiBfaW5zdGFuY2UkbWFudWFsUm93U2U7XG4gICAgdmFyIGNoZWNrZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb3cub3JpZ2luYWwgJiYgcm93Lm9yaWdpbmFsW21hbnVhbFJvd1NlbGVjdGVkS2V5XSkge1xuICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrZWQgPSByb3cuaXNTZWxlY3RlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICByb3cudG9nZ2xlUm93U2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiBjaGVja2VkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUm93IFNlbGVjdGVkJyxcbiAgICAgIGluZGV0ZXJtaW5hdGU6IHJvdy5pc1NvbWVTZWxlY3RlZFxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjIuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogaW5zdGFuY2UuaXNBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgUm93cyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiBCb29sZWFuKCFpbnN0YW5jZS5pc0FsbFJvd3NTZWxlY3RlZCAmJiBPYmplY3Qua2V5cyhpbnN0YW5jZS5zdGF0ZS5zZWxlY3RlZFJvd0lkcykubGVuZ3RoKVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBpbnN0YW5jZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogaW5zdGFuY2UuaXNBbGxQYWdlUm93c1NlbGVjdGVkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIEN1cnJlbnQgUGFnZSBSb3dzIFNlbGVjdGVkJyxcbiAgICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4oIWluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBpbnN0YW5jZS5wYWdlLnNvbWUoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWY0LmlkO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgfSkpXG4gICAgfV07XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDgoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHM6IHt9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0U2VsZWN0ZWRSb3dzKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuc2VsZWN0ZWRSb3dJZHMgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZXRTZWxlY3RlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBpc0FsbFJvd3NTZWxlY3RlZCA9IGluc3RhbmNlLmlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgICAgX2luc3RhbmNlJG5vbkdyb3VwZWRSID0gaW5zdGFuY2Uubm9uR3JvdXBlZFJvd3NCeUlkLFxuICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZCA9IF9pbnN0YW5jZSRub25Hcm91cGVkUiA9PT0gdm9pZCAwID8gcm93c0J5SWQgOiBfaW5zdGFuY2Ukbm9uR3JvdXBlZFI7XG4gICAgICB2YXIgc2VsZWN0QWxsID0gdHlwZW9mIHNldFNlbGVjdGVkICE9PSAndW5kZWZpbmVkJyA/IHNldFNlbGVjdGVkIDogIWlzQWxsUm93c1NlbGVjdGVkOyAvLyBPbmx5IHJlbW92ZS9hZGQgdGhlIHJvd3MgdGhhdCBhcmUgdmlzaWJsZSBvbiB0aGUgc2NyZWVuXG4gICAgICAvLyAgTGVhdmUgYWxsIHRoZSBvdGhlciByb3dzIHRoYXQgYXJlIHNlbGVjdGVkIGFsb25lLlxuXG4gICAgICB2YXIgc2VsZWN0ZWRSb3dJZHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zZWxlY3RlZFJvd0lkcyk7XG5cbiAgICAgIGlmIChzZWxlY3RBbGwpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIHNlbGVjdGVkUm93SWRzW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tyb3dJZF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBzZWxlY3RlZFJvd0lkc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkKSB7XG4gICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgX3NldFNlbGVjdGVkID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIF9yb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICAgIF9pbnN0YW5jZSRzZWxlY3RTdWJSbyA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgICAgc2VsZWN0U3ViUm93cyA9IF9pbnN0YW5jZSRzZWxlY3RTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRzZWxlY3RTdWJSbyxcbiAgICAgICAgICBnZXRTdWJSb3dzID0gaW5zdGFuY2UuZ2V0U3ViUm93cztcbiAgICAgIHZhciBpc1NlbGVjdGVkID0gc3RhdGUuc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgdmFyIHNob3VsZEV4aXN0ID0gdHlwZW9mIF9zZXRTZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgPyBfc2V0U2VsZWN0ZWQgOiAhaXNTZWxlY3RlZDtcblxuICAgICAgaWYgKGlzU2VsZWN0ZWQgPT09IHNob3VsZEV4aXN0KSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlbGVjdGVkUm93SWRzID0gX2V4dGVuZHMoe30sIHN0YXRlLnNlbGVjdGVkUm93SWRzKTtcblxuICAgICAgdmFyIGhhbmRsZVJvd0J5SWQgPSBmdW5jdGlvbiBoYW5kbGVSb3dCeUlkKGlkKSB7XG4gICAgICAgIHZhciByb3cgPSBfcm93c0J5SWRbaWRdO1xuXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICBpZiAoIXJvdy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRFeGlzdCkge1xuICAgICAgICAgICAgICBuZXdTZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5ld1NlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0U3ViUm93cyAmJiBnZXRTdWJSb3dzKHJvdykpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJSb3dzKHJvdykuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSb3dCeUlkKHJvdy5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZVJvd0J5SWQoaWQpO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogbmV3U2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKSB7XG4gICAgICB2YXIgX3NldFNlbGVjdGVkMiA9IGFjdGlvbi52YWx1ZTtcblxuICAgICAgdmFyIHBhZ2UgPSBpbnN0YW5jZS5wYWdlLFxuICAgICAgICAgIF9yb3dzQnlJZDIgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgICBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yID0gaW5zdGFuY2Uuc2VsZWN0U3ViUm93cyxcbiAgICAgICAgICBfc2VsZWN0U3ViUm93cyA9IF9pbnN0YW5jZSRzZWxlY3RTdWJSbzIgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yLFxuICAgICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgICAgICBfZ2V0U3ViUm93cyA9IGluc3RhbmNlLmdldFN1YlJvd3M7XG5cbiAgICAgIHZhciBfc2VsZWN0QWxsID0gdHlwZW9mIF9zZXRTZWxlY3RlZDIgIT09ICd1bmRlZmluZWQnID8gX3NldFNlbGVjdGVkMiA6ICFpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XG5cbiAgICAgIHZhciBfbmV3U2VsZWN0ZWRSb3dJZHMgPSBfZXh0ZW5kcyh7fSwgc3RhdGUuc2VsZWN0ZWRSb3dJZHMpO1xuXG4gICAgICB2YXIgX2hhbmRsZVJvd0J5SWQgPSBmdW5jdGlvbiBfaGFuZGxlUm93QnlJZChpZCkge1xuICAgICAgICB2YXIgcm93ID0gX3Jvd3NCeUlkMltpZF07XG5cbiAgICAgICAgaWYgKCFyb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgaWYgKF9zZWxlY3RBbGwpIHtcbiAgICAgICAgICAgIF9uZXdTZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgX25ld1NlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3NlbGVjdFN1YlJvd3MgJiYgX2dldFN1YlJvd3Mocm93KSkge1xuICAgICAgICAgIHJldHVybiBfZ2V0U3ViUm93cyhyb3cpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIF9oYW5kbGVSb3dCeUlkKHJvdy5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBhZ2UuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiBfaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBfbmV3U2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDgoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgX2luc3RhbmNlJG5vbkdyb3VwZWRSMiA9IGluc3RhbmNlLm5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkID0gX2luc3RhbmNlJG5vbkdyb3VwZWRSMiA9PT0gdm9pZCAwID8gcm93c0J5SWQgOiBfaW5zdGFuY2Ukbm9uR3JvdXBlZFIyLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UgPSBpbnN0YW5jZS5hdXRvUmVzZXRTZWxlY3RlZFJvd3MsXG4gICAgICAgIGF1dG9SZXNldFNlbGVjdGVkUm93cyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRTZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRTZSxcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHMgPSBpbnN0YW5jZS5zdGF0ZS5zZWxlY3RlZFJvd0lkcyxcbiAgICAgICAgX2luc3RhbmNlJHNlbGVjdFN1YlJvMyA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgIHNlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8zID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHNlbGVjdFN1YlJvMyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgcGFnZSA9IGluc3RhbmNlLnBhZ2UsXG4gICAgICAgIGdldFN1YlJvd3MgPSBpbnN0YW5jZS5nZXRTdWJSb3dzO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlRmlsdGVycycsICd1c2VHcm91cEJ5JywgJ3VzZVNvcnRCeScsICd1c2VFeHBhbmRlZCcsICd1c2VQYWdpbmF0aW9uJ10sICd1c2VSb3dTZWxlY3QnKTtcbiAgICB2YXIgc2VsZWN0ZWRGbGF0Um93cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0U3ViUm93cyA/IGdldFJvd0lzU2VsZWN0ZWQocm93LCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93cykgOiAhIXNlbGVjdGVkUm93SWRzW3Jvdy5pZF07XG4gICAgICAgIHJvdy5pc1NlbGVjdGVkID0gISFpc1NlbGVjdGVkO1xuICAgICAgICByb3cuaXNTb21lU2VsZWN0ZWQgPSBpc1NlbGVjdGVkID09PSBudWxsO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkRmxhdFJvd3M7XG4gICAgfSwgW3Jvd3MsIHNlbGVjdFN1YlJvd3MsIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzXSk7XG4gICAgdmFyIGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihPYmplY3Qua2V5cyhub25Hcm91cGVkUm93c0J5SWQpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykubGVuZ3RoKTtcbiAgICB2YXIgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gaXNBbGxSb3dzU2VsZWN0ZWQ7XG5cbiAgICBpZiAoaXNBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub25Hcm91cGVkUm93c0J5SWQpLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgfSkpIHtcbiAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICBpZiAocGFnZSAmJiBwYWdlLmxlbmd0aCAmJiBwYWdlLnNvbWUoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWY1LmlkO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRBdXRvUmVzZXRTZWxlY3RlZFJvd3MgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0U2VsZWN0ZWRSb3dzKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRTZWxlY3RlZFJvd3MoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFNlbGVjdGVkUm93c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGRhdGFdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciB0b2dnbGVSb3dTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUm93U2VsZWN0ZWQsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgdmFyIGdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHNlbGVjdGVkRmxhdFJvd3M6IHNlbGVjdGVkRmxhdFJvd3MsXG4gICAgICBpc0FsbFJvd3NTZWxlY3RlZDogaXNBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ6IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgIHRvZ2dsZVJvd1NlbGVjdGVkOiB0b2dnbGVSb3dTZWxlY3RlZCxcbiAgICAgIHRvZ2dsZUFsbFJvd3NTZWxlY3RlZDogdG9nZ2xlQWxsUm93c1NlbGVjdGVkLFxuICAgICAgZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHM6IGdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzLFxuICAgICAgZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzOiBnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMsXG4gICAgICB0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkOiB0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDMocm93LCBfcmVmNikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY2Lmluc3RhbmNlO1xuXG4gICAgcm93LnRvZ2dsZVJvd1NlbGVjdGVkID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVJvd1NlbGVjdGVkKHJvdy5pZCwgc2V0KTtcbiAgICB9O1xuXG4gICAgcm93LmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihpbnN0YW5jZS5nZXRIb29rcygpLmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHJvdzogcm93XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3dJc1NlbGVjdGVkKHJvdywgc2VsZWN0ZWRSb3dJZHMsIGdldFN1YlJvd3MpIHtcbiAgICBpZiAoc2VsZWN0ZWRSb3dJZHNbcm93LmlkXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN1YlJvd3MgPSBnZXRTdWJSb3dzKHJvdyk7XG5cbiAgICBpZiAoc3ViUm93cyAmJiBzdWJSb3dzLmxlbmd0aCkge1xuICAgICAgdmFyIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdmFyIHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJSb3cpIHtcbiAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgICAgIGlmIChzb21lU2VsZWN0ZWQgJiYgIWFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0Um93SXNTZWxlY3RlZChzdWJSb3csIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzKSkge1xuICAgICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxDaGlsZHJlblNlbGVjdGVkID8gdHJ1ZSA6IHNvbWVTZWxlY3RlZCA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gZnVuY3Rpb24gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yKHJvdykge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IGZ1bmN0aW9uIGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IoY2VsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfTsgLy8gQWN0aW9uc1xuXG5cbiAgYWN0aW9ucy5zZXRSb3dTdGF0ZSA9ICdzZXRSb3dTdGF0ZSc7XG4gIGFjdGlvbnMuc2V0Q2VsbFN0YXRlID0gJ3NldENlbGxTdGF0ZSc7XG4gIGFjdGlvbnMucmVzZXRSb3dTdGF0ZSA9ICdyZXNldFJvd1N0YXRlJztcbiAgdmFyIHVzZVJvd1N0YXRlID0gZnVuY3Rpb24gdXNlUm93U3RhdGUoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ5KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDkpO1xuICAgIGhvb2tzLnByZXBhcmVSb3cucHVzaChwcmVwYXJlUm93JDQpO1xuICB9O1xuICB1c2VSb3dTdGF0ZS5wbHVnaW5OYW1lID0gJ3VzZVJvd1N0YXRlJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJDkoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJGluaXRpYWxSb3dTID0gaW5zdGFuY2UuaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxSb3dTID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IgOiBfaW5zdGFuY2UkaW5pdGlhbFJvd1MsXG4gICAgICAgIF9pbnN0YW5jZSRpbml0aWFsQ2VsbCA9IGluc3RhbmNlLmluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcixcbiAgICAgICAgaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxDZWxsID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxDZWxsLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkO1xuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHJvd1N0YXRlOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJvd1N0YXRlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHJvd1N0YXRlOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucm93U3RhdGUgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRSb3dTdGF0ZSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHJvd0lkID0gYWN0aW9uLnJvd0lkLFxuICAgICAgICAgIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIG9sZFJvd1N0YXRlID0gdHlwZW9mIHN0YXRlLnJvd1N0YXRlW3Jvd0lkXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdGF0ZS5yb3dTdGF0ZVtyb3dJZF0gOiBpbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3dzQnlJZFtyb3dJZF0pO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICByb3dTdGF0ZTogX2V4dGVuZHMoe30sIHN0YXRlLnJvd1N0YXRlLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltyb3dJZF0gPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBvbGRSb3dTdGF0ZSksIF9leHRlbmRzMikpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Q2VsbFN0YXRlKSB7XG4gICAgICB2YXIgX29sZFJvd1N0YXRlJGNlbGxTdGF0LCBfcm93c0J5SWQkX3Jvd0lkLCBfcm93c0J5SWQkX3Jvd0lkJGNlbGwsIF9leHRlbmRzMywgX2V4dGVuZHM0O1xuXG4gICAgICB2YXIgX3Jvd0lkID0gYWN0aW9uLnJvd0lkLFxuICAgICAgICAgIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIF92YWx1ZSA9IGFjdGlvbi52YWx1ZTtcblxuICAgICAgdmFyIF9vbGRSb3dTdGF0ZSA9IHR5cGVvZiBzdGF0ZS5yb3dTdGF0ZVtfcm93SWRdICE9PSAndW5kZWZpbmVkJyA/IHN0YXRlLnJvd1N0YXRlW19yb3dJZF0gOiBpbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3dzQnlJZFtfcm93SWRdKTtcblxuICAgICAgdmFyIG9sZENlbGxTdGF0ZSA9IHR5cGVvZiAoX29sZFJvd1N0YXRlID09IG51bGwgPyB2b2lkIDAgOiAoX29sZFJvd1N0YXRlJGNlbGxTdGF0ID0gX29sZFJvd1N0YXRlLmNlbGxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vbGRSb3dTdGF0ZSRjZWxsU3RhdFtjb2x1bW5JZF0pICE9PSAndW5kZWZpbmVkJyA/IF9vbGRSb3dTdGF0ZS5jZWxsU3RhdGVbY29sdW1uSWRdIDogaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKChfcm93c0J5SWQkX3Jvd0lkID0gcm93c0J5SWRbX3Jvd0lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfcm93c0J5SWQkX3Jvd0lkJGNlbGwgPSBfcm93c0J5SWQkX3Jvd0lkLmNlbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3Jvd3NCeUlkJF9yb3dJZCRjZWxsLmZpbmQoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcm93U3RhdGU6IF9leHRlbmRzKHt9LCBzdGF0ZS5yb3dTdGF0ZSwgKF9leHRlbmRzNCA9IHt9LCBfZXh0ZW5kczRbX3Jvd0lkXSA9IF9leHRlbmRzKHt9LCBfb2xkUm93U3RhdGUsIHtcbiAgICAgICAgICBjZWxsU3RhdGU6IF9leHRlbmRzKHt9LCBfb2xkUm93U3RhdGUuY2VsbFN0YXRlIHx8IHt9LCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tjb2x1bW5JZF0gPSBmdW5jdGlvbmFsVXBkYXRlKF92YWx1ZSwgb2xkQ2VsbFN0YXRlKSwgX2V4dGVuZHMzKSlcbiAgICAgICAgfSksIF9leHRlbmRzNCkpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ5KGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRhdXRvUmVzZXRSbyA9IGluc3RhbmNlLmF1dG9SZXNldFJvd1N0YXRlLFxuICAgICAgICBhdXRvUmVzZXRSb3dTdGF0ZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRSbyxcbiAgICAgICAgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgdmFyIHNldFJvd1N0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvd0lkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRSb3dTdGF0ZSxcbiAgICAgICAgcm93SWQ6IHJvd0lkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBzZXRDZWxsU3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocm93SWQsIGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRDZWxsU3RhdGUsXG4gICAgICAgIHJvd0lkOiByb3dJZCxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRSb3dTdGF0ZSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRSb3dTdGF0ZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0Um93U3RhdGUoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJvd1N0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgc2V0Um93U3RhdGU6IHNldFJvd1N0YXRlLFxuICAgICAgc2V0Q2VsbFN0YXRlOiBzZXRDZWxsU3RhdGVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVSb3ckNChyb3csIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHZhciBfaW5zdGFuY2UkaW5pdGlhbFJvd1MyID0gaW5zdGFuY2UuaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxSb3dTMiA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxSb3dTMixcbiAgICAgICAgX2luc3RhbmNlJGluaXRpYWxDZWxsMiA9IGluc3RhbmNlLmluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcixcbiAgICAgICAgaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxDZWxsMiA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIsXG4gICAgICAgIHJvd1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUucm93U3RhdGU7XG5cbiAgICBpZiAocm93KSB7XG4gICAgICByb3cuc3RhdGUgPSB0eXBlb2Ygcm93U3RhdGVbcm93LmlkXSAhPT0gJ3VuZGVmaW5lZCcgPyByb3dTdGF0ZVtyb3cuaWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93KTtcblxuICAgICAgcm93LnNldFN0YXRlID0gZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnNldFJvd1N0YXRlKHJvdy5pZCwgdXBkYXRlcik7XG4gICAgICB9O1xuXG4gICAgICByb3cuY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBpZiAoIXJvdy5zdGF0ZS5jZWxsU3RhdGUpIHtcbiAgICAgICAgICByb3cuc3RhdGUuY2VsbFN0YXRlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsLnN0YXRlID0gdHlwZW9mIHJvdy5zdGF0ZS5jZWxsU3RhdGVbY2VsbC5jb2x1bW4uaWRdICE9PSAndW5kZWZpbmVkJyA/IHJvdy5zdGF0ZS5jZWxsU3RhdGVbY2VsbC5jb2x1bW4uaWRdIDogaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKGNlbGwpO1xuXG4gICAgICAgIGNlbGwuc2V0U3RhdGUgPSBmdW5jdGlvbiAodXBkYXRlcikge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5zZXRDZWxsU3RhdGUocm93LmlkLCBjZWxsLmNvbHVtbi5pZCwgdXBkYXRlcik7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhY3Rpb25zLnJlc2V0Q29sdW1uT3JkZXIgPSAncmVzZXRDb2x1bW5PcmRlcic7XG4gIGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIgPSAnc2V0Q29sdW1uT3JkZXInO1xuICB2YXIgdXNlQ29sdW1uT3JkZXIgPSBmdW5jdGlvbiB1c2VDb2x1bW5PcmRlcihob29rcykge1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJGEpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuY29sdW1uT3JkZXJdKTtcbiAgICB9KTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1ucy5wdXNoKHZpc2libGVDb2x1bW5zJDIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkYSk7XG4gIH07XG4gIHVzZUNvbHVtbk9yZGVyLnBsdWdpbk5hbWUgPSAndXNlQ29sdW1uT3JkZXInO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkYShzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjb2x1bW5PcmRlcjogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRDb2x1bW5PcmRlcikge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5PcmRlcjogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyIHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uT3JkZXI6IGZ1bmN0aW9uYWxVcGRhdGUoYWN0aW9uLmNvbHVtbk9yZGVyLCBzdGF0ZS5jb2x1bW5PcmRlcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zJDIoY29sdW1ucywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uT3JkZXIgPSBfcmVmMi5pbnN0YW5jZS5zdGF0ZS5jb2x1bW5PcmRlcjtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgaWYgKCFjb2x1bW5PcmRlciB8fCAhY29sdW1uT3JkZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9XG5cbiAgICB2YXIgY29sdW1uT3JkZXJDb3B5ID0gW10uY29uY2F0KGNvbHVtbk9yZGVyKTsgLy8gSWYgdGhlcmUgaXMgYW4gb3JkZXIsIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1uc0NvcHkgPSBbXS5jb25jYXQoY29sdW1ucyk7IC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgIHZhciBjb2x1bW5zSW5PcmRlciA9IFtdOyAvLyBMb29wIG92ZXIgdGhlIGNvbHVtbnMgYW5kIHBsYWNlIHRoZW0gaW4gb3JkZXIgaW50byB0aGUgbmV3IGFycmF5XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciB0YXJnZXRDb2x1bW5JZCA9IGNvbHVtbk9yZGVyQ29weS5zaGlmdCgpO1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSBjb2x1bW5zQ29weS5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IHRhcmdldENvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgY29sdW1uc0luT3JkZXIucHVzaChjb2x1bW5zQ29weS5zcGxpY2UoZm91bmRJbmRleCwgMSlbMF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfSAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuXG5cbiAgICByZXR1cm4gW10uY29uY2F0KGNvbHVtbnNJbk9yZGVyLCBjb2x1bW5zQ29weSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSRhKGluc3RhbmNlKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgaW5zdGFuY2Uuc2V0Q29sdW1uT3JkZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIsXG4gICAgICAgIGNvbHVtbk9yZGVyOiBjb2x1bW5PcmRlclxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gIH1cblxuICBkZWZhdWx0Q29sdW1uLmNhblJlc2l6ZSA9IHRydWU7IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcgPSAnY29sdW1uU3RhcnRSZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uUmVzaXppbmcgPSAnY29sdW1uUmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZyA9ICdjb2x1bW5Eb25lUmVzaXppbmcnO1xuICBhY3Rpb25zLnJlc2V0UmVzaXplID0gJ3Jlc2V0UmVzaXplJztcbiAgdmFyIHVzZVJlc2l6ZUNvbHVtbnMgPSBmdW5jdGlvbiB1c2VSZXNpemVDb2x1bW5zKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0UmVzaXplclByb3BzID0gW2RlZmF1bHRHZXRSZXNpemVyUHJvcHNdO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciRiKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJGIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucy5wdXNoKHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyQxKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFJlc2l6ZXJQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSZXNpemVyUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICBoZWFkZXIgPSBfcmVmLmhlYWRlcjtcbiAgICB2YXIgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaDtcblxuICAgIHZhciBvblJlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gb25SZXNpemVTdGFydChlLCBoZWFkZXIpIHtcbiAgICAgIHZhciBpc1RvdWNoRXZlbnQgPSBmYWxzZTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIGxldHMgbm90IHJlc3BvbmQgdG8gbXVsdGlwbGUgdG91Y2hlcyAoZS5nLiAyIG9yIDMgZmluZ2VycylcbiAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzVG91Y2hFdmVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWFkZXJzVG9SZXNpemUgPSBnZXRMZWFmSGVhZGVycyhoZWFkZXIpO1xuICAgICAgdmFyIGhlYWRlcklkV2lkdGhzID0gaGVhZGVyc1RvUmVzaXplLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gW2QuaWQsIGQudG90YWxXaWR0aF07XG4gICAgICB9KTtcbiAgICAgIHZhciBjbGllbnRYID0gaXNUb3VjaEV2ZW50ID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICB2YXIgcmFmO1xuICAgICAgdmFyIG1vc3RSZWNlbnRDbGllbnRYO1xuXG4gICAgICB2YXIgZGlzcGF0Y2hFbmQgPSBmdW5jdGlvbiBkaXNwYXRjaEVuZCgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgICAgIHJhZiA9IG51bGw7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZ1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaXNwYXRjaE1vdmUgPSBmdW5jdGlvbiBkaXNwYXRjaE1vdmUoKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgICByYWYgPSBudWxsO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5jb2x1bW5SZXNpemluZyxcbiAgICAgICAgICBjbGllbnRYOiBtb3N0UmVjZW50Q2xpZW50WFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzY2hlZHVsZURpc3BhdGNoTW92ZU9uTmV4dEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShjbGllbnRYUG9zKSB7XG4gICAgICAgIG1vc3RSZWNlbnRDbGllbnRYID0gY2xpZW50WFBvcztcblxuICAgICAgICBpZiAoIXJhZikge1xuICAgICAgICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGlzcGF0Y2hNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGhhbmRsZXJzQW5kRXZlbnRzID0ge1xuICAgICAgICBtb3VzZToge1xuICAgICAgICAgIG1vdmVFdmVudDogJ21vdXNlbW92ZScsXG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGZ1bmN0aW9uIG1vdmVIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZURpc3BhdGNoTW92ZU9uTmV4dEFuaW1hdGlvbkZyYW1lKGUuY2xpZW50WCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEV2ZW50OiAnbW91c2V1cCcsXG4gICAgICAgICAgdXBIYW5kbGVyOiBmdW5jdGlvbiB1cEhhbmRsZXIoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcnNBbmRFdmVudHMubW91c2UubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBkaXNwYXRjaEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2g6IHtcbiAgICAgICAgICBtb3ZlRXZlbnQ6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgIG1vdmVIYW5kbGVyOiBmdW5jdGlvbiBtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShlLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEV2ZW50OiAndG91Y2hlbmQnLFxuICAgICAgICAgIHVwSGFuZGxlcjogZnVuY3Rpb24gdXBIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlcnNBbmRFdmVudHMudG91Y2gubW92ZUV2ZW50LCBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLnVwRXZlbnQsIGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGV2ZW50cyA9IGlzVG91Y2hFdmVudCA/IGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoIDogaGFuZGxlcnNBbmRFdmVudHMubW91c2U7XG4gICAgICB2YXIgcGFzc2l2ZUlmU3VwcG9ydGVkID0gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkgPyB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9IDogZmFsc2U7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5tb3ZlRXZlbnQsIGV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLnVwRXZlbnQsIGV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZyxcbiAgICAgICAgY29sdW1uSWQ6IGhlYWRlci5pZCxcbiAgICAgICAgY29sdW1uV2lkdGg6IGhlYWRlci50b3RhbFdpZHRoLFxuICAgICAgICBoZWFkZXJJZFdpZHRoczogaGVhZGVySWRXaWR0aHMsXG4gICAgICAgIGNsaWVudFg6IGNsaWVudFhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICByZXR1cm4gZS5wZXJzaXN0KCkgfHwgb25SZXNpemVTdGFydChlLCBoZWFkZXIpO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgcmV0dXJuIGUucGVyc2lzdCgpIHx8IG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdjb2wtcmVzaXplJ1xuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICByb2xlOiAnc2VwYXJhdG9yJ1xuICAgIH1dO1xuICB9O1xuXG4gIHVzZVJlc2l6ZUNvbHVtbnMucGx1Z2luTmFtZSA9ICd1c2VSZXNpemVDb2x1bW5zJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJGIoc3RhdGUsIGFjdGlvbikge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjb2x1bW5SZXNpemluZzoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJlc2l6ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcpIHtcbiAgICAgIHZhciBjbGllbnRYID0gYWN0aW9uLmNsaWVudFgsXG4gICAgICAgICAgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgY29sdW1uV2lkdGggPSBhY3Rpb24uY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHMgPSBhY3Rpb24uaGVhZGVySWRXaWR0aHM7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBzdGFydFg6IGNsaWVudFgsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHM6IGhlYWRlcklkV2lkdGhzLFxuICAgICAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW5JZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICB2YXIgX2NsaWVudFggPSBhY3Rpb24uY2xpZW50WDtcblxuICAgICAgdmFyIF9zdGF0ZSRjb2x1bW5SZXNpemluZyA9IHN0YXRlLmNvbHVtblJlc2l6aW5nLFxuICAgICAgICAgIHN0YXJ0WCA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZy5zdGFydFgsXG4gICAgICAgICAgX2NvbHVtbldpZHRoID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nLmNvbHVtbldpZHRoLFxuICAgICAgICAgIF9zdGF0ZSRjb2x1bW5SZXNpemluZzIgPSBfc3RhdGUkY29sdW1uUmVzaXppbmcuaGVhZGVySWRXaWR0aHMsXG4gICAgICAgICAgX2hlYWRlcklkV2lkdGhzID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nMiA9PT0gdm9pZCAwID8gW10gOiBfc3RhdGUkY29sdW1uUmVzaXppbmcyO1xuXG4gICAgICB2YXIgZGVsdGFYID0gX2NsaWVudFggLSBzdGFydFg7XG4gICAgICB2YXIgcGVyY2VudGFnZURlbHRhWCA9IGRlbHRhWCAvIF9jb2x1bW5XaWR0aDtcbiAgICAgIHZhciBuZXdDb2x1bW5XaWR0aHMgPSB7fTtcblxuICAgICAgX2hlYWRlcklkV2lkdGhzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBoZWFkZXJJZCA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBfcmVmMlsxXTtcbiAgICAgICAgbmV3Q29sdW1uV2lkdGhzW2hlYWRlcklkXSA9IE1hdGgubWF4KGhlYWRlcldpZHRoICsgaGVhZGVyV2lkdGggKiBwZXJjZW50YWdlRGVsdGFYLCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IF9leHRlbmRzKHt9LCBzdGF0ZS5jb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aHMsIHt9LCBuZXdDb2x1bW5XaWR0aHMpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBzdGFydFg6IG51bGwsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogbnVsbFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyQxID0gZnVuY3Rpb24gdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zKGluc3RhbmNlKSB7XG4gICAgdmFyIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGRpc2FibGVSZXNpemluZyA9IGluc3RhbmNlLmRpc2FibGVSZXNpemluZyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgY29sdW1uUmVzaXppbmcgPSBpbnN0YW5jZS5zdGF0ZS5jb2x1bW5SZXNpemluZztcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgdmFyIGNhblJlc2l6ZSA9IGdldEZpcnN0RGVmaW5lZChoZWFkZXIuZGlzYWJsZVJlc2l6aW5nID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVSZXNpemluZyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIGhlYWRlci5jYW5SZXNpemUgPSBjYW5SZXNpemU7XG4gICAgICBoZWFkZXIud2lkdGggPSBjb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aHNbaGVhZGVyLmlkXSB8fCBoZWFkZXIub3JpZ2luYWxXaWR0aCB8fCBoZWFkZXIud2lkdGg7XG4gICAgICBoZWFkZXIuaXNSZXNpemluZyA9IGNvbHVtblJlc2l6aW5nLmlzUmVzaXppbmdDb2x1bW4gPT09IGhlYWRlci5pZDtcblxuICAgICAgaWYgKGNhblJlc2l6ZSkge1xuICAgICAgICBoZWFkZXIuZ2V0UmVzaXplclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRSZXNpemVyUHJvcHMsIHtcbiAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSRiKGluc3RhbmNlKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUgPSBpbnN0YW5jZS5hdXRvUmVzZXRSZXNpemUsXG4gICAgICAgIGF1dG9SZXNldFJlc2l6ZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRSZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRSZSxcbiAgICAgICAgY29sdW1ucyA9IGluc3RhbmNlLmNvbHVtbnM7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VBYnNvbHV0ZUxheW91dCddLCAndXNlUmVzaXplQ29sdW1ucycpO1xuICAgIHZhciBnZXRBdXRvUmVzZXRSZXNpemUgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0UmVzaXplKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRSZXNpemUoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJlc2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbY29sdW1uc10pO1xuICAgIHZhciByZXNldFJlc2l6aW5nID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJlc2l6ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcmVzZXRSZXNpemluZzogcmVzZXRSZXNpemluZ1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGVhZkhlYWRlcnMoaGVhZGVyKSB7XG4gICAgdmFyIGxlYWZIZWFkZXJzID0gW107XG5cbiAgICB2YXIgcmVjdXJzZUhlYWRlciA9IGZ1bmN0aW9uIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmNvbHVtbnMgJiYgaGVhZGVyLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGhlYWRlci5jb2x1bW5zLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgIH1cblxuICAgICAgbGVhZkhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgIH07XG5cbiAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgcmV0dXJuIGxlYWZIZWFkZXJzO1xuICB9XG5cbiAgdmFyIGNlbGxTdHlsZXMgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwXG4gIH07XG4gIHZhciB1c2VBYnNvbHV0ZUxheW91dCA9IGZ1bmN0aW9uIHVzZUFic29sdXRlTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VGFibGVCb2R5UHJvcHMucHVzaChnZXRSb3dTdHlsZXMpO1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRIZWFkZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZikge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYuY29sdW1uO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMsIHtcbiAgICAgICAgICBsZWZ0OiBjb2x1bW4udG90YWxMZWZ0ICsgXCJweFwiLFxuICAgICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gICAgaG9va3MuZ2V0Q2VsbFByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMikge1xuICAgICAgdmFyIGNlbGwgPSBfcmVmMi5jZWxsO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMsIHtcbiAgICAgICAgICBsZWZ0OiBjZWxsLmNvbHVtbi50b3RhbExlZnQgKyBcInB4XCIsXG4gICAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMykge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYzLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY29sdW1uLnRvdGFsTGVmdCArIFwicHhcIixcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICB9O1xuICB1c2VBYnNvbHV0ZUxheW91dC5wbHVnaW5OYW1lID0gJ3VzZUFic29sdXRlTGF5b3V0JztcblxuICB2YXIgZ2V0Um93U3R5bGVzID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmNCkge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY0Lmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB3aWR0aDogaW5zdGFuY2UudG90YWxDb2x1bW5zV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgY2VsbFN0eWxlcyQxID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gIH07XG5cbiAgdmFyIGdldFJvd1N0eWxlcyQxID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIHdpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciB1c2VCbG9ja0xheW91dCA9IGZ1bmN0aW9uIHVzZUJsb2NrTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMSk7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQxKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMikge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjMpIHtcbiAgICAgIHZhciBjZWxsID0gX3JlZjMuY2VsbDtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY2VsbC5jb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWY0KSB7XG4gICAgICB2YXIgY29sdW1uID0gX3JlZjQuY29sdW1uO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMkMSwge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gIH07XG4gIHVzZUJsb2NrTGF5b3V0LnBsdWdpbk5hbWUgPSAndXNlQmxvY2tMYXlvdXQnO1xuXG4gIGZ1bmN0aW9uIHVzZUZsZXhMYXlvdXQoaG9va3MpIHtcbiAgICBob29rcy5nZXRUYWJsZVByb3BzLnB1c2goZ2V0VGFibGVQcm9wcyk7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMik7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQyKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzJDIpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZ2V0SGVhZGVyUHJvcHMpO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGdldENlbGxQcm9wcyk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyUHJvcHMucHVzaChnZXRGb290ZXJQcm9wcyk7XG4gIH1cbiAgdXNlRmxleExheW91dC5wbHVnaW5OYW1lID0gJ3VzZUZsZXhMYXlvdXQnO1xuXG4gIHZhciBnZXRUYWJsZVByb3BzID0gZnVuY3Rpb24gZ2V0VGFibGVQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWluV2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc01pbldpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldFJvd1N0eWxlcyQyID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleDogJzEgMCBhdXRvJyxcbiAgICAgICAgbWluV2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc01pbldpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldEhlYWRlclByb3BzID0gZnVuY3Rpb24gZ2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYzLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZmxleDogY29sdW1uLnRvdGFsRmxleFdpZHRoID8gY29sdW1uLnRvdGFsRmxleFdpZHRoICsgXCIgMCBhdXRvXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIG1pbldpZHRoOiBjb2x1bW4udG90YWxNaW5XaWR0aCArIFwicHhcIixcbiAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldENlbGxQcm9wcyA9IGZ1bmN0aW9uIGdldENlbGxQcm9wcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgY2VsbCA9IF9yZWY0LmNlbGw7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNlbGwuY29sdW1uLnRvdGFsRmxleFdpZHRoICsgXCIgMCBhdXRvXCIsXG4gICAgICAgIG1pbldpZHRoOiBjZWxsLmNvbHVtbi50b3RhbE1pbldpZHRoICsgXCJweFwiLFxuICAgICAgICB3aWR0aDogY2VsbC5jb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRGb290ZXJQcm9wcyA9IGZ1bmN0aW9uIGdldEZvb3RlclByb3BzKHByb3BzLCBfcmVmNSkge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmNS5jb2x1bW47XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNvbHVtbi50b3RhbEZsZXhXaWR0aCA/IGNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiIDogdW5kZWZpbmVkLFxuICAgICAgICBtaW5XaWR0aDogY29sdW1uLnRvdGFsTWluV2lkdGggKyBcInB4XCIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZyA9ICdjb2x1bW5TdGFydFJlc2l6aW5nJztcbiAgYWN0aW9ucy5jb2x1bW5SZXNpemluZyA9ICdjb2x1bW5SZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nID0gJ2NvbHVtbkRvbmVSZXNpemluZyc7XG4gIGFjdGlvbnMucmVzZXRSZXNpemUgPSAncmVzZXRSZXNpemUnO1xuICBmdW5jdGlvbiB1c2VHcmlkTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkYyk7XG4gICAgaG9va3MuZ2V0VGFibGVQcm9wcy5wdXNoKGdldFRhYmxlUHJvcHMkMSk7XG4gICAgaG9va3MuZ2V0SGVhZGVyUHJvcHMucHVzaChnZXRIZWFkZXJQcm9wcyQxKTtcbiAgICBob29rcy5nZXRSb3dQcm9wcy5wdXNoKGdldFJvd1Byb3BzKTtcbiAgfVxuICB1c2VHcmlkTGF5b3V0LnBsdWdpbk5hbWUgPSAndXNlR3JpZExheW91dCc7XG5cbiAgdmFyIGdldFRhYmxlUHJvcHMkMSA9IGZ1bmN0aW9uIGdldFRhYmxlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHZhciBncmlkVGVtcGxhdGVDb2x1bW5zID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHZhciBfaW5zdGFuY2Ukc3RhdGUkY29sdW07XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5ncmlkTGF5b3V0LmNvbHVtbldpZHRoc1tjb2x1bW4uaWRdKSByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHNbY29sdW1uLmlkXSArIFwicHhcIjsgLy8gV2hlbiByZXNpemluZywgbG9jayB0aGUgd2lkdGggb2YgYWxsIHVuc2V0IGNvbHVtbnNcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgdXNlci1wcm92aWRlZCB3aWR0aCBvciBkZWZhdWx0Q29sdW1uIHdpZHRoLFxuICAgICAgLy8gd2hpY2ggY291bGQgcG90ZW50aWFsbHkgYmUgJ2F1dG8nIG9yICdmcicgdW5pdHMgdGhhdCBkb24ndCBzY2FsZSBsaW5lYXJseVxuXG4gICAgICBpZiAoKF9pbnN0YW5jZSRzdGF0ZSRjb2x1bSA9IGluc3RhbmNlLnN0YXRlLmNvbHVtblJlc2l6aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHN0YXRlJGNvbHVtLmlzUmVzaXppbmdDb2x1bW4pIHJldHVybiBpbnN0YW5jZS5zdGF0ZS5ncmlkTGF5b3V0LnN0YXJ0V2lkdGhzW2NvbHVtbi5pZF0gKyBcInB4XCI7XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbi53aWR0aCA9PT0gJ251bWJlcicpIHJldHVybiBjb2x1bW4ud2lkdGggKyBcInB4XCI7XG4gICAgICByZXR1cm4gY29sdW1uLndpZHRoO1xuICAgIH0pO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBncmlkVGVtcGxhdGVDb2x1bW5zLmpvaW4oXCIgXCIpXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldEhlYWRlclByb3BzJDEgPSBmdW5jdGlvbiBnZXRIZWFkZXJQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjIuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIGlkOiBcImhlYWRlci1jZWxsLVwiICsgY29sdW1uLmlkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIC8vZW5hYmxlcyBhIHNjcm9sbCB3cmFwcGVyIHRvIGJlIHBsYWNlZCBhcm91bmQgdGhlIHRhYmxlIGFuZCBoYXZlIHN0aWNreSBoZWFkZXJzXG4gICAgICAgIGdyaWRDb2x1bW46IFwic3BhbiBcIiArIGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudFxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRSb3dQcm9wcyA9IGZ1bmN0aW9uIGdldFJvd1Byb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciByb3cgPSBfcmVmMy5yb3c7XG5cbiAgICBpZiAocm93LmlzRXhwYW5kZWQpIHtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBncmlkQ29sdW1uOiBcIjEgLyBcIiArIChyb3cuY2VsbHMubGVuZ3RoICsgMSlcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtwcm9wcywge31dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkYyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBncmlkTGF5b3V0OiB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiB7fVxuICAgICAgICB9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0UmVzaXplKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nKSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHMgPSBhY3Rpb24uaGVhZGVySWRXaWR0aHM7XG4gICAgICB2YXIgY29sdW1uV2lkdGggPSBnZXRFbGVtZW50V2lkdGgoY29sdW1uSWQpO1xuXG4gICAgICBpZiAoY29sdW1uV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnRXaWR0aHMgPSBpbnN0YW5jZS52aXNpYmxlQ29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY29sdW1uKSB7XG4gICAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltjb2x1bW4uaWRdID0gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbi5pZCksIF9leHRlbmRzMikpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBtaW5XaWR0aHMgPSBpbnN0YW5jZS52aXNpYmxlQ29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY29sdW1uKSB7XG4gICAgICAgICAgdmFyIF9leHRlbmRzMztcblxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tjb2x1bW4uaWRdID0gY29sdW1uLm1pbldpZHRoLCBfZXh0ZW5kczMpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgbWF4V2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczQ7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzNCA9IHt9LCBfZXh0ZW5kczRbY29sdW1uLmlkXSA9IGNvbHVtbi5tYXhXaWR0aCwgX2V4dGVuZHM0KSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGhlYWRlcklkR3JpZFdpZHRocyA9IGhlYWRlcklkV2lkdGhzLm1hcChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmNFswXTtcbiAgICAgICAgICByZXR1cm4gW2hlYWRlcklkLCBnZXRFbGVtZW50V2lkdGgoaGVhZGVySWQpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgICAgc3RhcnRXaWR0aHM6IHN0YXJ0V2lkdGhzLFxuICAgICAgICAgICAgbWluV2lkdGhzOiBtaW5XaWR0aHMsXG4gICAgICAgICAgICBtYXhXaWR0aHM6IG1heFdpZHRocyxcbiAgICAgICAgICAgIGhlYWRlcklkR3JpZFdpZHRoczogaGVhZGVySWRHcmlkV2lkdGhzLFxuICAgICAgICAgICAgY29sdW1uV2lkdGg6IGNvbHVtbldpZHRoXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGFjdGlvbi5jbGllbnRYO1xuICAgICAgdmFyIHN0YXJ0WCA9IHN0YXRlLmNvbHVtblJlc2l6aW5nLnN0YXJ0WDtcblxuICAgICAgdmFyIF9zdGF0ZSRncmlkTGF5b3V0ID0gc3RhdGUuZ3JpZExheW91dCxcbiAgICAgICAgICBfY29sdW1uV2lkdGggPSBfc3RhdGUkZ3JpZExheW91dC5jb2x1bW5XaWR0aCxcbiAgICAgICAgICBfbWluV2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQubWluV2lkdGhzLFxuICAgICAgICAgIF9tYXhXaWR0aHMgPSBfc3RhdGUkZ3JpZExheW91dC5tYXhXaWR0aHMsXG4gICAgICAgICAgX3N0YXRlJGdyaWRMYXlvdXQkaGVhID0gX3N0YXRlJGdyaWRMYXlvdXQuaGVhZGVySWRHcmlkV2lkdGhzLFxuICAgICAgICAgIF9oZWFkZXJJZEdyaWRXaWR0aHMgPSBfc3RhdGUkZ3JpZExheW91dCRoZWEgPT09IHZvaWQgMCA/IFtdIDogX3N0YXRlJGdyaWRMYXlvdXQkaGVhO1xuXG4gICAgICB2YXIgZGVsdGFYID0gY2xpZW50WCAtIHN0YXJ0WDtcbiAgICAgIHZhciBwZXJjZW50YWdlRGVsdGFYID0gZGVsdGFYIC8gX2NvbHVtbldpZHRoO1xuICAgICAgdmFyIG5ld0NvbHVtbldpZHRocyA9IHt9O1xuXG4gICAgICBfaGVhZGVySWRHcmlkV2lkdGhzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBoZWFkZXJJZCA9IF9yZWY1WzBdLFxuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBfcmVmNVsxXTtcbiAgICAgICAgbmV3Q29sdW1uV2lkdGhzW2hlYWRlcklkXSA9IE1hdGgubWluKE1hdGgubWF4KF9taW5XaWR0aHNbaGVhZGVySWRdLCBoZWFkZXJXaWR0aCArIGhlYWRlcldpZHRoICogcGVyY2VudGFnZURlbHRhWCksIF9tYXhXaWR0aHNbaGVhZGVySWRdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5ncmlkTGF5b3V0LCB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHMsIHt9LCBuZXdDb2x1bW5XaWR0aHMpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5ncmlkTGF5b3V0LCB7XG4gICAgICAgICAgc3RhcnRXaWR0aHM6IHt9LFxuICAgICAgICAgIG1pbldpZHRoczoge30sXG4gICAgICAgICAgbWF4V2lkdGhzOiB7fVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbklkKSB7XG4gICAgdmFyIF9kb2N1bWVudCRnZXRFbGVtZW50QjtcblxuICAgIHZhciB3aWR0aCA9IChfZG9jdW1lbnQkZ2V0RWxlbWVudEIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYWRlci1jZWxsLVwiICsgY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50JGdldEVsZW1lbnRCLm9mZnNldFdpZHRoO1xuXG4gICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLl9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMgPSBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zO1xuICBleHBvcnRzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICBleHBvcnRzLmRlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uO1xuICBleHBvcnRzLmRlZmF1bHRHcm91cEJ5Rm4gPSBkZWZhdWx0R3JvdXBCeUZuO1xuICBleHBvcnRzLmRlZmF1bHRPcmRlckJ5Rm4gPSBkZWZhdWx0T3JkZXJCeUZuO1xuICBleHBvcnRzLmRlZmF1bHRSZW5kZXJlciA9IGRlZmF1bHRSZW5kZXJlcjtcbiAgZXhwb3J0cy5lbXB0eVJlbmRlcmVyID0gZW1wdHlSZW5kZXJlcjtcbiAgZXhwb3J0cy5lbnN1cmVQbHVnaW5PcmRlciA9IGVuc3VyZVBsdWdpbk9yZGVyO1xuICBleHBvcnRzLmZsZXhSZW5kZXIgPSBmbGV4UmVuZGVyO1xuICBleHBvcnRzLmZ1bmN0aW9uYWxVcGRhdGUgPSBmdW5jdGlvbmFsVXBkYXRlO1xuICBleHBvcnRzLmxvb3BIb29rcyA9IGxvb3BIb29rcztcbiAgZXhwb3J0cy5tYWtlUHJvcEdldHRlciA9IG1ha2VQcm9wR2V0dGVyO1xuICBleHBvcnRzLm1ha2VSZW5kZXJlciA9IG1ha2VSZW5kZXJlcjtcbiAgZXhwb3J0cy5yZWR1Y2VIb29rcyA9IHJlZHVjZUhvb2tzO1xuICBleHBvcnRzLnNhZmVVc2VMYXlvdXRFZmZlY3QgPSBzYWZlVXNlTGF5b3V0RWZmZWN0O1xuICBleHBvcnRzLnVzZUFic29sdXRlTGF5b3V0ID0gdXNlQWJzb2x1dGVMYXlvdXQ7XG4gIGV4cG9ydHMudXNlQXN5bmNEZWJvdW5jZSA9IHVzZUFzeW5jRGVib3VuY2U7XG4gIGV4cG9ydHMudXNlQmxvY2tMYXlvdXQgPSB1c2VCbG9ja0xheW91dDtcbiAgZXhwb3J0cy51c2VDb2x1bW5PcmRlciA9IHVzZUNvbHVtbk9yZGVyO1xuICBleHBvcnRzLnVzZUV4cGFuZGVkID0gdXNlRXhwYW5kZWQ7XG4gIGV4cG9ydHMudXNlRmlsdGVycyA9IHVzZUZpbHRlcnM7XG4gIGV4cG9ydHMudXNlRmxleExheW91dCA9IHVzZUZsZXhMYXlvdXQ7XG4gIGV4cG9ydHMudXNlR2V0TGF0ZXN0ID0gdXNlR2V0TGF0ZXN0O1xuICBleHBvcnRzLnVzZUdsb2JhbEZpbHRlciA9IHVzZUdsb2JhbEZpbHRlcjtcbiAgZXhwb3J0cy51c2VHcmlkTGF5b3V0ID0gdXNlR3JpZExheW91dDtcbiAgZXhwb3J0cy51c2VHcm91cEJ5ID0gdXNlR3JvdXBCeTtcbiAgZXhwb3J0cy51c2VNb3VudGVkTGF5b3V0RWZmZWN0ID0gdXNlTW91bnRlZExheW91dEVmZmVjdDtcbiAgZXhwb3J0cy51c2VQYWdpbmF0aW9uID0gdXNlUGFnaW5hdGlvbjtcbiAgZXhwb3J0cy51c2VSZXNpemVDb2x1bW5zID0gdXNlUmVzaXplQ29sdW1ucztcbiAgZXhwb3J0cy51c2VSb3dTZWxlY3QgPSB1c2VSb3dTZWxlY3Q7XG4gIGV4cG9ydHMudXNlUm93U3RhdGUgPSB1c2VSb3dTdGF0ZTtcbiAgZXhwb3J0cy51c2VTb3J0QnkgPSB1c2VTb3J0Qnk7XG4gIGV4cG9ydHMudXNlVGFibGUgPSB1c2VUYWJsZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtdGFibGUuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC10YWJsZS5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=